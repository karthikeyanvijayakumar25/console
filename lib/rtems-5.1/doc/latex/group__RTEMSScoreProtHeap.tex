\hypertarget{group__RTEMSScoreProtHeap}{}\section{Protected Heap Handler}
\label{group__RTEMSScoreProtHeap}\index{Protected Heap Handler@{Protected Heap Handler}}


Provides protected heap services.  


\subsection*{Files}
\begin{DoxyCompactItemize}
\item 
file \mbox{\hyperlink{protectedheap_8h}{protectedheap.\+h}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler A\+PI. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapallocate_8c}{pheapallocate.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapextend_8c}{pheapextend.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapfree_8c}{pheapfree.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapgetblocksize_8c}{pheapgetblocksize.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapgetfreeinfo_8c}{pheapgetfreeinfo.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapgetinfo_8c}{pheapgetinfo.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapgetsize_8c}{pheapgetsize.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapinit_8c}{pheapinit.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapiterate_8c}{pheapiterate.\+c}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{group__RTEMSScoreHeap_ga568d8a3b62e8b4b060940770bdeee254}{\+\_\+\+Heap\+\_\+\+Iterate()}} implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapresizeblock_8c}{pheapresizeblock.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\item 
file \mbox{\hyperlink{pheapwalk_8c}{pheapwalk.\+c}}
\begin{DoxyCompactList}\small\item\em Protected Heap Handler implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} uintptr\+\_\+t \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga0f09fcdd50fcb5de78cdb10c0cb3b7e5}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Initialize}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, void $\ast$area\+\_\+begin, uintptr\+\_\+t area\+\_\+size, uintptr\+\_\+t page\+\_\+size)
\begin{DoxyCompactList}\small\item\em Initializes the protected heap. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_gaeafd4fefda9100f0b9484f97f19d1093}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Extend}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, void $\ast$area\+\_\+begin, uintptr\+\_\+t area\+\_\+size)
\begin{DoxyCompactList}\small\item\em Extends the protected heap. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga76e8188c79871f71f9af86616c6ebc53}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Allocate\+\_\+aligned\+\_\+with\+\_\+boundary}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, uintptr\+\_\+t \mbox{\hyperlink{sun4u_2tte_8h_a245260f6f74972558f61b85227df5aae}{size}}, uintptr\+\_\+t alignment, uintptr\+\_\+t boundary)
\begin{DoxyCompactList}\small\item\em Allocates an aligned memory area with boundary constraint for the protected heap. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void $\ast$ \mbox{\hyperlink{group__RTEMSScoreProtHeap_gaf60206138a64a845eea1a2e6519b9ae2}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Allocate\+\_\+aligned}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, uintptr\+\_\+t \mbox{\hyperlink{sun4u_2tte_8h_a245260f6f74972558f61b85227df5aae}{size}}, uintptr\+\_\+t alignment)
\begin{DoxyCompactList}\small\item\em Allocates an aligned memory area. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void $\ast$ \mbox{\hyperlink{group__RTEMSScoreProtHeap_gab7cdb2ee3416572258caab80416e312a}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Allocate}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, uintptr\+\_\+t \mbox{\hyperlink{sun4u_2tte_8h_a245260f6f74972558f61b85227df5aae}{size}})
\begin{DoxyCompactList}\small\item\em Allocates a memory area. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga8b33f6ca130ff4c89c97e318f0f5d347}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+block\+\_\+size}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, void $\ast$addr, uintptr\+\_\+t $\ast$\mbox{\hyperlink{sun4u_2tte_8h_a245260f6f74972558f61b85227df5aae}{size}})
\begin{DoxyCompactList}\small\item\em Returns the size of the allocatable memory area. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga44f1fdece094ff00c7e0fdbafa22918d}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Resize\+\_\+block}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, void $\ast$addr, uintptr\+\_\+t \mbox{\hyperlink{sun4u_2tte_8h_a245260f6f74972558f61b85227df5aae}{size}})
\begin{DoxyCompactList}\small\item\em Resizes the block of the allocated memory area. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_gabfcf102ec8b1ec0fa0f620ce3694722b}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Free}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, void $\ast$addr)
\begin{DoxyCompactList}\small\item\em Frees the allocated memory area. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga87a4c8acb0a309a5c9a22a93f105cf2e}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Walk}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, int source, bool dump)
\begin{DoxyCompactList}\small\item\em Verifies the integrity of the heap. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga8bdc01fbd6baf99d53c193ebd965b7ad}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Iterate}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, \mbox{\hyperlink{group__RTEMSScoreHeap_gab5fc026bfabc31c620545e574d579b64}{Heap\+\_\+\+Block\+\_\+visitor}} visitor, void $\ast$visitor\+\_\+arg)
\begin{DoxyCompactList}\small\item\em Iterates over all blocks of the heap. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga327ad8c35910aeef2bad64e4ba05bbbf}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+information}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, \mbox{\hyperlink{structHeap__Information__block}{Heap\+\_\+\+Information\+\_\+block}} $\ast$info)
\begin{DoxyCompactList}\small\item\em Returns information about used and free blocks for the heap. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga54aae0cfc83e761f71d9219228f614d4}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+free\+\_\+information}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap, \mbox{\hyperlink{structHeap__Information}{Heap\+\_\+\+Information}} $\ast$info)
\begin{DoxyCompactList}\small\item\em Returns information about free blocks for the heap. \end{DoxyCompactList}\item 
uintptr\+\_\+t \mbox{\hyperlink{group__RTEMSScoreProtHeap_ga1f617743f0fc81830ede1e14e194ffc7}{\+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+size}} (\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$heap)
\begin{DoxyCompactList}\small\item\em Returns the size of the allocatable area in bytes. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Provides protected heap services. 

The Score\+Allocator\+Mutex is used to protect the heap accesses. 

\subsection{Function Documentation}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_gab7cdb2ee3416572258caab80416e312a}\label{group__RTEMSScoreProtHeap_gab7cdb2ee3416572258caab80416e312a}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Allocate@{\_Protected\_heap\_Allocate}}
\index{\_Protected\_heap\_Allocate@{\_Protected\_heap\_Allocate}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Allocate()}{\_Protected\_heap\_Allocate()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void$\ast$ \+\_\+\+Protected\+\_\+heap\+\_\+\+Allocate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{uintptr\+\_\+t}]{size }\end{DoxyParamCaption})}



Allocates a memory area. 

A size value of zero will return a unique address which may be freed with \mbox{\hyperlink{group__RTEMSScoreHeap_gab9a1cc19751295ceb71d1d495fa56b39}{\+\_\+\+Heap\+\_\+\+Free()}}. This method first locks the allocator and after the allocation of the memory area, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap to allocate a memory are from. \\
\hline
 & {\em size} & The size of the desired memory are in bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em pointer} & The starting address of the allocated memory area. \\
\hline
{\em N\+U\+LL} & No memory is available of the parameters are inconsistent. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_gaf60206138a64a845eea1a2e6519b9ae2}\label{group__RTEMSScoreProtHeap_gaf60206138a64a845eea1a2e6519b9ae2}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Allocate\_aligned@{\_Protected\_heap\_Allocate\_aligned}}
\index{\_Protected\_heap\_Allocate\_aligned@{\_Protected\_heap\_Allocate\_aligned}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Allocate\_aligned()}{\_Protected\_heap\_Allocate\_aligned()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void$\ast$ \+\_\+\+Protected\+\_\+heap\+\_\+\+Allocate\+\_\+aligned (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{uintptr\+\_\+t}]{size,  }\item[{uintptr\+\_\+t}]{alignment }\end{DoxyParamCaption})}



Allocates an aligned memory area. 

A size value of zero will return a unique address which may be freed with \mbox{\hyperlink{group__RTEMSScoreHeap_gab9a1cc19751295ceb71d1d495fa56b39}{\+\_\+\+Heap\+\_\+\+Free()}}. This method first locks the allocator and after the allocation of the memory area, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap to allocate a memory are from. \\
\hline
 & {\em size} & The size of the desired memory are in bytes. \\
\hline
 & {\em alignment} & The allocated memory area will begin at an address aligned by this value.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em pointer} & The starting address of the allocated memory area. \\
\hline
{\em N\+U\+LL} & No memory is available of the parameters are inconsistent. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga76e8188c79871f71f9af86616c6ebc53}\label{group__RTEMSScoreProtHeap_ga76e8188c79871f71f9af86616c6ebc53}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Allocate\_aligned\_with\_boundary@{\_Protected\_heap\_Allocate\_aligned\_with\_boundary}}
\index{\_Protected\_heap\_Allocate\_aligned\_with\_boundary@{\_Protected\_heap\_Allocate\_aligned\_with\_boundary}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Allocate\_aligned\_with\_boundary()}{\_Protected\_heap\_Allocate\_aligned\_with\_boundary()}}
{\footnotesize\ttfamily void$\ast$ \+\_\+\+Protected\+\_\+heap\+\_\+\+Allocate\+\_\+aligned\+\_\+with\+\_\+boundary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{uintptr\+\_\+t}]{size,  }\item[{uintptr\+\_\+t}]{alignment,  }\item[{uintptr\+\_\+t}]{boundary }\end{DoxyParamCaption})}



Allocates an aligned memory area with boundary constraint for the protected heap. 

A size value of zero will return a unique address which may be freed with \mbox{\hyperlink{group__RTEMSScoreHeap_gab9a1cc19751295ceb71d1d495fa56b39}{\+\_\+\+Heap\+\_\+\+Free()}}. This method first locks the allocator and after the allocation of the memory area, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap to allocate a memory are from. \\
\hline
 & {\em size} & The size of the desired memory are in bytes. \\
\hline
 & {\em alignment} & The allocated memory area will begin at an address aligned by this value. \\
\hline
 & {\em boundary} & The allocated memory area will fulfill a boundary constraint, if this value is not equal to zero. The boundary value specifies the set of addresses which are aligned by the boundary value. The interior of the allocated memory area will not contain an element of this set. The begin or end address of the area may be a member of the set.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em pointer} & The starting address of the allocated memory area. \\
\hline
{\em N\+U\+LL} & No memory is available of the parameters are inconsistent. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_gaeafd4fefda9100f0b9484f97f19d1093}\label{group__RTEMSScoreProtHeap_gaeafd4fefda9100f0b9484f97f19d1093}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Extend@{\_Protected\_heap\_Extend}}
\index{\_Protected\_heap\_Extend@{\_Protected\_heap\_Extend}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Extend()}{\_Protected\_heap\_Extend()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Extend (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{void $\ast$}]{area\+\_\+begin,  }\item[{uintptr\+\_\+t}]{area\+\_\+size }\end{DoxyParamCaption})}



Extends the protected heap. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap to extend. \\
\hline
 & {\em area\+\_\+begin} & The starting addres of the area to extend {\itshape heap} with. \\
\hline
 & {\em area\+\_\+size} & The size of the heap area.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & The operation succeeded. \\
\hline
{\em false} & The operation failed. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_gabfcf102ec8b1ec0fa0f620ce3694722b}\label{group__RTEMSScoreProtHeap_gabfcf102ec8b1ec0fa0f620ce3694722b}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Free@{\_Protected\_heap\_Free}}
\index{\_Protected\_heap\_Free@{\_Protected\_heap\_Free}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Free()}{\_Protected\_heap\_Free()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Free (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{void $\ast$}]{addr }\end{DoxyParamCaption})}



Frees the allocated memory area. 

Inappropriate values for {\itshape addr} may corrupt the heap. This method first locks the allocator and after the free operation, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap of the allocated memory area. \\
\hline
 & {\em addr} & The starting address of the memory area to be freed.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & The allocated memory area was successfully freed. \\
\hline
{\em false} & The method failed. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga8b33f6ca130ff4c89c97e318f0f5d347}\label{group__RTEMSScoreProtHeap_ga8b33f6ca130ff4c89c97e318f0f5d347}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Get\_block\_size@{\_Protected\_heap\_Get\_block\_size}}
\index{\_Protected\_heap\_Get\_block\_size@{\_Protected\_heap\_Get\_block\_size}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Get\_block\_size()}{\_Protected\_heap\_Get\_block\_size()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+block\+\_\+size (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{void $\ast$}]{addr,  }\item[{uintptr\+\_\+t $\ast$}]{size }\end{DoxyParamCaption})}



Returns the size of the allocatable memory area. 

The size value may be greater than the initially requested size in \mbox{\hyperlink{group__RTEMSScoreHeap_ga15167f1ad5eb93d85f15adb5e5524ff5}{\+\_\+\+Heap\+\_\+\+Allocate\+\_\+aligned\+\_\+with\+\_\+boundary()}}.

Inappropriate values for {\itshape addr} will not corrupt the heap, but may yield invalid size values.

This method first locks the allocator and after the operation, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
 & {\em heap} & The heap to operate upon. \\
\hline
 & {\em addr} & The starting address of the allocatable memory area. \\
\hline
\mbox{\texttt{ out}}  & {\em size} & Stores the size of the allocatable memory area after the method call.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & The operation was successful. \\
\hline
{\em false} & The operation was not successful. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga54aae0cfc83e761f71d9219228f614d4}\label{group__RTEMSScoreProtHeap_ga54aae0cfc83e761f71d9219228f614d4}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Get\_free\_information@{\_Protected\_heap\_Get\_free\_information}}
\index{\_Protected\_heap\_Get\_free\_information@{\_Protected\_heap\_Get\_free\_information}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Get\_free\_information()}{\_Protected\_heap\_Get\_free\_information()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+free\+\_\+information (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{\mbox{\hyperlink{structHeap__Information}{Heap\+\_\+\+Information}} $\ast$}]{info }\end{DoxyParamCaption})}



Returns information about free blocks for the heap. 

This method first locks the allocator and after the operation, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
 & {\em heap} & The heap to get the information from. \\
\hline
\mbox{\texttt{ out}}  & {\em info} & Stores the information about free blocks of {\itshape heap} after the method call. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga327ad8c35910aeef2bad64e4ba05bbbf}\label{group__RTEMSScoreProtHeap_ga327ad8c35910aeef2bad64e4ba05bbbf}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Get\_information@{\_Protected\_heap\_Get\_information}}
\index{\_Protected\_heap\_Get\_information@{\_Protected\_heap\_Get\_information}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Get\_information()}{\_Protected\_heap\_Get\_information()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+information (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{\mbox{\hyperlink{structHeap__Information__block}{Heap\+\_\+\+Information\+\_\+block}} $\ast$}]{info }\end{DoxyParamCaption})}



Returns information about used and free blocks for the heap. 

This method first locks the allocator and after the operation, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
 & {\em heap} & The heap to get the information from. \\
\hline
\mbox{\texttt{ out}}  & {\em info} & Stores the information of the {\itshape heap} after the method call. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga1f617743f0fc81830ede1e14e194ffc7}\label{group__RTEMSScoreProtHeap_ga1f617743f0fc81830ede1e14e194ffc7}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Get\_size@{\_Protected\_heap\_Get\_size}}
\index{\_Protected\_heap\_Get\_size@{\_Protected\_heap\_Get\_size}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Get\_size()}{\_Protected\_heap\_Get\_size()}}
{\footnotesize\ttfamily uintptr\+\_\+t \+\_\+\+Protected\+\_\+heap\+\_\+\+Get\+\_\+size (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap }\end{DoxyParamCaption})}



Returns the size of the allocatable area in bytes. 

This value is an integral multiple of the page size.


\begin{DoxyParams}{Parameters}
{\em heap} & The heap to get the allocatable area from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size of the allocatable area in {\itshape heap} in bytes. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga0f09fcdd50fcb5de78cdb10c0cb3b7e5}\label{group__RTEMSScoreProtHeap_ga0f09fcdd50fcb5de78cdb10c0cb3b7e5}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Initialize@{\_Protected\_heap\_Initialize}}
\index{\_Protected\_heap\_Initialize@{\_Protected\_heap\_Initialize}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Initialize()}{\_Protected\_heap\_Initialize()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} uintptr\+\_\+t \+\_\+\+Protected\+\_\+heap\+\_\+\+Initialize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{void $\ast$}]{area\+\_\+begin,  }\item[{uintptr\+\_\+t}]{area\+\_\+size,  }\item[{uintptr\+\_\+t}]{page\+\_\+size }\end{DoxyParamCaption})}



Initializes the protected heap. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em heap} & The heap to initialize. \\
\hline
 & {\em area\+\_\+begin} & The starting address of the heap area. \\
\hline
 & {\em area\+\_\+size} & The size of the heap area. \\
\hline
 & {\em page\+\_\+size} & The page size for the heap. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga8bdc01fbd6baf99d53c193ebd965b7ad}\label{group__RTEMSScoreProtHeap_ga8bdc01fbd6baf99d53c193ebd965b7ad}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Iterate@{\_Protected\_heap\_Iterate}}
\index{\_Protected\_heap\_Iterate@{\_Protected\_heap\_Iterate}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Iterate()}{\_Protected\_heap\_Iterate()}}
{\footnotesize\ttfamily void \+\_\+\+Protected\+\_\+heap\+\_\+\+Iterate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{\mbox{\hyperlink{group__RTEMSScoreHeap_gab5fc026bfabc31c620545e574d579b64}{Heap\+\_\+\+Block\+\_\+visitor}}}]{visitor,  }\item[{void $\ast$}]{visitor\+\_\+arg }\end{DoxyParamCaption})}



Iterates over all blocks of the heap. 

This method first locks the allocator and after the operation, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap to iterate over. \\
\hline
 & {\em visitor} & This will be called for each heap block with the argument {\itshape visitor\+\_\+arg}. \\
\hline
\mbox{\texttt{ in,out}}  & {\em visitor\+\_\+arg} & The argument for all calls of {\itshape visitor}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga44f1fdece094ff00c7e0fdbafa22918d}\label{group__RTEMSScoreProtHeap_ga44f1fdece094ff00c7e0fdbafa22918d}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Resize\_block@{\_Protected\_heap\_Resize\_block}}
\index{\_Protected\_heap\_Resize\_block@{\_Protected\_heap\_Resize\_block}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Resize\_block()}{\_Protected\_heap\_Resize\_block()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Resize\+\_\+block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{void $\ast$}]{addr,  }\item[{uintptr\+\_\+t}]{size }\end{DoxyParamCaption})}



Resizes the block of the allocated memory area. 

Inappropriate values for {\itshape addr} may corrupt the heap.

This method first locks the allocator and after the resize, unlocks it again.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em heap} & The heap to operate upon. \\
\hline
 & {\em addr} & The starting address of the allocated memory area to be resized. \\
\hline
 & {\em size} & The least possible size for the new memory area. Resize may be impossible and depends on the current heap usage. \\
\hline
\mbox{\texttt{ out}}  & {\em old\+\_\+size} & Stores the size available for allocation in the current block before the resize after the method call. \\
\hline
\mbox{\texttt{ out}}  & {\em new\+\_\+size} & Stores the size available for allocation in the resized block after the method call. In the case of an unsuccessful resize, zero is returned in this parameter\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em H\+E\+A\+P\+\_\+\+R\+E\+S\+I\+Z\+E\+\_\+\+S\+U\+C\+C\+E\+S\+S\+F\+UL} & The resize was successful. \\
\hline
{\em H\+E\+A\+P\+\_\+\+R\+E\+S\+I\+Z\+E\+\_\+\+U\+N\+S\+A\+T\+I\+S\+F\+I\+ED} & The least possible size {\itshape size} was too big. Resize not possible. \\
\hline
{\em H\+E\+A\+P\+\_\+\+R\+E\+S\+I\+Z\+E\+\_\+\+F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR} & The block starting at {\itshape addr} is not part of the heap. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__RTEMSScoreProtHeap_ga87a4c8acb0a309a5c9a22a93f105cf2e}\label{group__RTEMSScoreProtHeap_ga87a4c8acb0a309a5c9a22a93f105cf2e}} 
\index{Protected Heap Handler@{Protected Heap Handler}!\_Protected\_heap\_Walk@{\_Protected\_heap\_Walk}}
\index{\_Protected\_heap\_Walk@{\_Protected\_heap\_Walk}!Protected Heap Handler@{Protected Heap Handler}}
\subsubsection{\texorpdfstring{\_Protected\_heap\_Walk()}{\_Protected\_heap\_Walk()}}
{\footnotesize\ttfamily bool \+\_\+\+Protected\+\_\+heap\+\_\+\+Walk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap__Control}{Heap\+\_\+\+Control}} $\ast$}]{heap,  }\item[{int}]{source,  }\item[{bool}]{dump }\end{DoxyParamCaption})}



Verifies the integrity of the heap. 

Walks the heap to verify its integrity. This method first locks the allocator and after the operation, unlocks it again, if the thread dispatch is enabled.


\begin{DoxyParams}{Parameters}
{\em heap} & The heap whose integrity is to be verified. \\
\hline
{\em source} & If {\itshape dump} is {\ttfamily true}, this is used to mark the output lines. \\
\hline
{\em dump} & Indicates whether diagnostic messages will be printed to standard output.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & No errors occured, the heapÂ´s integrity is not violated. \\
\hline
{\em false} & The heap is corrupt. \\
\hline
\end{DoxyRetVals}
