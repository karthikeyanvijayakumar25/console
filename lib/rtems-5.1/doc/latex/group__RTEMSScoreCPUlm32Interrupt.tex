\hypertarget{group__RTEMSScoreCPUlm32Interrupt}{}\section{Processor Dependent Interrupt Management}
\label{group__RTEMSScoreCPUlm32Interrupt}\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gad1ef5062849284d81496e1e6d33fb7ff}{\+\_\+\+C\+P\+U\+\_\+\+Initialize\+\_\+vectors}}()
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gaca3fde6f372ee51fdd893c260e7d7146}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable}}(\+\_\+isr\+\_\+cookie)~lm32\+\_\+disable\+\_\+interrupts( \+\_\+isr\+\_\+cookie );
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gae3b1e2cd1ea4020d229e759569459664}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable}}(\+\_\+isr\+\_\+cookie)~lm32\+\_\+enable\+\_\+interrupts( \+\_\+isr\+\_\+cookie );
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash}}(\+\_\+isr\+\_\+cookie)~lm32\+\_\+flash\+\_\+interrupts( \+\_\+isr\+\_\+cookie );
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gaed8717a2f15938d954c7124cd11e899f}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level}}(new\+\_\+level)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gaddfaa82155a005077bfd1d41dc6e8cf5}\label{group__RTEMSScoreCPUlm32Interrupt_gaddfaa82155a005077bfd1d41dc6e8cf5}} 
typedef void($\ast$ {\bfseries C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler}) (void)
\item 
\mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_ga6d0204fc99c704f9f7c1e7b4e8b3657a}\label{group__RTEMSScoreCPUlm32Interrupt_ga6d0204fc99c704f9f7c1e7b4e8b3657a}} 
typedef void($\ast$ {\bfseries C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler}) (uint32\+\_\+t)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_ga5254669b54a06e96ebb585fd50a02c4d}\label{group__RTEMSScoreCPUlm32Interrupt_ga5254669b54a06e96ebb585fd50a02c4d}} 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} bool {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Is\+\_\+enabled} (uint32\+\_\+t level)
\item 
uint32\+\_\+t \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_ga1d9dcab9170d532b6634a5620385adbd}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level}} (void)
\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gaa993b7752d5db306f85586ac400432ab}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+raw\+\_\+handler}} (uint32\+\_\+t vector, C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler new\+\_\+handler, C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler $\ast$old\+\_\+handler)
\begin{DoxyCompactList}\small\item\em S\+P\+A\+RC specific raw I\+SR installer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gaa3480454768ad843ce97909111a48a1f}\label{group__RTEMSScoreCPUlm32Interrupt_gaa3480454768ad843ce97909111a48a1f}} 
void {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+vector} (uint32\+\_\+t vector, C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler new\+\_\+handler, C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler $\ast$old\+\_\+handler)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This variable is optional. It is used on C\+P\+Us on which it is difficult to generate an \char`\"{}uninitialized\char`\"{} FP context. It is filled in by \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga869484e3d851b032fd826c69ff21fc72}{\+\_\+\+C\+P\+U\+\_\+\+Initialize}} and copied into the task\textquotesingle{}s FP context area during \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa92701994ad8e3b646667a3e92935ddf}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize}}.

Port Specific Information\+:

X\+XX document implementation including references if appropriate

The following defines the number of bits actually used in the interrupt field of the task mode. How those bits map to the C\+PU interrupt levels is defined by the routine \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga43820ba3d51d7a699c22fce8cac93ef1}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level}}.

Port Specific Information\+:

X\+XX document implementation including references if appropriate

Amount of extra stack (above minimum stack size) required by M\+P\+CI receive server thread. Remember that in a multiprocessor system this thread must exist and be able to process all directives.

Port Specific Information\+:

X\+XX document implementation including references if appropriate

This defines the number of entries in the \+\_\+\+I\+S\+R\+\_\+\+Vector\+\_\+table managed by R\+T\+E\+MS.

Port Specific Information\+:

X\+XX document implementation including references if appropriate

This defines the highest interrupt vector number for this port.

This is defined if the port has a special way to report the I\+SR nesting level. Most ports maintain the variable {\itshape \+\_\+\+I\+S\+R\+\_\+\+Nest\+\_\+level}. 

\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gad1ef5062849284d81496e1e6d33fb7ff}\label{group__RTEMSScoreCPUlm32Interrupt_gad1ef5062849284d81496e1e6d33fb7ff}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_Initialize\_vectors@{\_CPU\_Initialize\_vectors}}
\index{\_CPU\_Initialize\_vectors@{\_CPU\_Initialize\_vectors}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_Initialize\_vectors}{\_CPU\_Initialize\_vectors}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Initialize\+\_\+vectors(\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Support routine to initialize the R\+T\+E\+MS vector table after it is allocated.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gaca3fde6f372ee51fdd893c260e7d7146}\label{group__RTEMSScoreCPUlm32Interrupt_gaca3fde6f372ee51fdd893c260e7d7146}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Disable@{\_CPU\_ISR\_Disable}}
\index{\_CPU\_ISR\_Disable@{\_CPU\_ISR\_Disable}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Disable}{\_CPU\_ISR\_Disable}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})~lm32\+\_\+disable\+\_\+interrupts( \+\_\+isr\+\_\+cookie );}

Disable all interrupts for an R\+T\+E\+MS critical section. The previous level is returned in {\itshape \+\_\+isr\+\_\+cookie}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em \+\_\+isr\+\_\+cookie} & will contain the previous level cookie\\
\hline
\end{DoxyParams}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gae3b1e2cd1ea4020d229e759569459664}\label{group__RTEMSScoreCPUlm32Interrupt_gae3b1e2cd1ea4020d229e759569459664}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Enable@{\_CPU\_ISR\_Enable}}
\index{\_CPU\_ISR\_Enable@{\_CPU\_ISR\_Enable}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Enable}{\_CPU\_ISR\_Enable}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})~lm32\+\_\+enable\+\_\+interrupts( \+\_\+isr\+\_\+cookie );}

Enable interrupts to the previous level (returned by \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable). This indicates the end of an R\+T\+E\+MS critical section. The parameter {\itshape \+\_\+isr\+\_\+cookie} is not modified.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \+\_\+isr\+\_\+cookie} & contain the previous level cookie\\
\hline
\end{DoxyParams}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}\label{group__RTEMSScoreCPUlm32Interrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Flash@{\_CPU\_ISR\_Flash}}
\index{\_CPU\_ISR\_Flash@{\_CPU\_ISR\_Flash}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Flash}{\_CPU\_ISR\_Flash}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})~lm32\+\_\+flash\+\_\+interrupts( \+\_\+isr\+\_\+cookie );}

This temporarily restores the interrupt to {\itshape \+\_\+isr\+\_\+cookie} before immediately disabling them again. This is used to divide long R\+T\+E\+MS critical sections into two or more parts. The parameter {\itshape \+\_\+isr\+\_\+cookie} is not modified.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \+\_\+isr\+\_\+cookie} & contain the previous level cookie\\
\hline
\end{DoxyParams}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gaed8717a2f15938d954c7124cd11e899f}\label{group__RTEMSScoreCPUlm32Interrupt_gaed8717a2f15938d954c7124cd11e899f}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Set\_level@{\_CPU\_ISR\_Set\_level}}
\index{\_CPU\_ISR\_Set\_level@{\_CPU\_ISR\_Set\_level}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Set\_level}{\_CPU\_ISR\_Set\_level}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level(\begin{DoxyParamCaption}\item[{}]{new\+\_\+level }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{    \_CPU\_ISR\_Enable( ( new\_level==0 ) ? 1 : 0 ); \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
This routine and \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga1d9dcab9170d532b6634a5620385adbd}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level}} Map the interrupt level in task mode onto the hardware that the C\+PU actually provides. Currently, interrupt levels which do not map onto the C\+PU in a generic fashion are undefined. Someday, it would be nice if these were \char`\"{}mapped\char`\"{} by the application via a callout. For example, m68k has 8 levels 0 -\/ 7, levels 8 -\/ 255 would be available for bsp/application specific meaning. This could be used to manage a programmable interrupt controller via the rtems\+\_\+task\+\_\+mode directive.

Port Specific Information\+:

X\+XX document implementation including references if appropriate 

\subsection{Function Documentation}
\mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_ga1d9dcab9170d532b6634a5620385adbd}\label{group__RTEMSScoreCPUlm32Interrupt_ga1d9dcab9170d532b6634a5620385adbd}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Get\_level@{\_CPU\_ISR\_Get\_level}}
\index{\_CPU\_ISR\_Get\_level@{\_CPU\_ISR\_Get\_level}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Get\_level()}{\_CPU\_ISR\_Get\_level()}}
{\footnotesize\ttfamily uint32\+\_\+t \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Return the current interrupt disable level for this task in the format used by the interrupt level portion of the task mode.

N\+O\+TE\+: This routine usually must be implemented as a subroutine.

Port Specific Information\+:

X\+XX document implementation including references if appropriate

Return the current interrupt disable level for this task in the format used by the interrupt level portion of the task mode.

\begin{DoxyNote}{Note}
This routine usually must be implemented as a subroutine.
\end{DoxyNote}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{group__RTEMSScoreCPUlm32Interrupt_gaa993b7752d5db306f85586ac400432ab}\label{group__RTEMSScoreCPUlm32Interrupt_gaa993b7752d5db306f85586ac400432ab}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_install\_raw\_handler@{\_CPU\_ISR\_install\_raw\_handler}}
\index{\_CPU\_ISR\_install\_raw\_handler@{\_CPU\_ISR\_install\_raw\_handler}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_install\_raw\_handler()}{\_CPU\_ISR\_install\_raw\_handler()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+raw\+\_\+handler (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{vector,  }\item[{C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler}]{new\+\_\+handler,  }\item[{C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler $\ast$}]{old\+\_\+handler }\end{DoxyParamCaption})}



S\+P\+A\+RC specific raw I\+SR installer. 

This routine installs {\itshape new\+\_\+handler} to be directly called from the trap table.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vector} & is the vector number \\
\hline
\mbox{\texttt{ in}}  & {\em new\+\_\+handler} & is the new I\+SR handler \\
\hline
\mbox{\texttt{ in}}  & {\em old\+\_\+handler} & will contain the old I\+SR handler \\
\hline
\end{DoxyParams}
