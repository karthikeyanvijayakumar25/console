\hypertarget{lm32_2include_2rtems_2score_2cpu_8h}{}\section{cpukit/score/cpu/lm32/include/rtems/score/cpu.h File Reference}
\label{lm32_2include_2rtems_2score_2cpu_8h}\index{cpukit/score/cpu/lm32/include/rtems/score/cpu.h@{cpukit/score/cpu/lm32/include/rtems/score/cpu.h}}


L\+M32 C\+PU Department Source.  


{\ttfamily \#include $<$rtems/score/basedefs.\+h$>$}\newline
{\ttfamily \#include $<$rtems/score/lm32.\+h$>$}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}}
\begin{DoxyCompactList}\small\item\em Thread register context. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structCPU__Interrupt__frame}{C\+P\+U\+\_\+\+Interrupt\+\_\+frame}}
\begin{DoxyCompactList}\small\item\em Interrupt stack frame (I\+SF). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a1eca01dbb1ef2873349cc4e222509f0a}{C\+P\+U\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+E\+C\+T\+O\+R\+E\+D\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+TS}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a30c4d320f85b1383c5059da5b19b164a}{C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+P\+A\+S\+S\+E\+S\+\_\+\+F\+R\+A\+M\+E\+\_\+\+P\+O\+I\+N\+T\+ER}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}\label{lm32_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}} 
\#define {\bfseries C\+P\+U\+\_\+\+H\+A\+R\+D\+W\+A\+R\+E\+\_\+\+FP}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a304f78c61edce38bb88e909f90a326dc}\label{lm32_2include_2rtems_2score_2cpu_8h_a304f78c61edce38bb88e909f90a326dc}} 
\#define {\bfseries C\+P\+U\+\_\+\+S\+O\+F\+T\+W\+A\+R\+E\+\_\+\+FP}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a225de03a8647bf307a73cf907969778d}{C\+P\+U\+\_\+\+A\+L\+L\+\_\+\+T\+A\+S\+K\+S\+\_\+\+A\+R\+E\+\_\+\+FP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_af1c906c8ee4c3d012dc456285e42d3ee}{C\+P\+U\+\_\+\+I\+D\+L\+E\+\_\+\+T\+A\+S\+K\+\_\+\+I\+S\+\_\+\+FP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a155bcf88149016c6c58f30eeab9f1598}{C\+P\+U\+\_\+\+U\+S\+E\+\_\+\+D\+E\+F\+E\+R\+R\+E\+D\+\_\+\+F\+P\+\_\+\+S\+W\+I\+T\+CH}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a0c634f4a6bc9236bcacafc9b6119e011}\label{lm32_2include_2rtems_2score_2cpu_8h_a0c634f4a6bc9236bcacafc9b6119e011}} 
\#define {\bfseries C\+P\+U\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+R\+O\+B\+U\+S\+T\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+D\+I\+S\+P\+A\+T\+CH}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_ac40d98a563f63934a5775f1366ba1b67}{C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+G\+R\+O\+W\+S\+\_\+\+UP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}\label{lm32_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}} 
\#define {\bfseries C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}~32
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_acd43704c7821a2c042d212801156584e}\label{lm32_2include_2rtems_2score_2cpu_8h_acd43704c7821a2c042d212801156584e}} 
\#define {\bfseries C\+P\+U\+\_\+\+S\+T\+R\+U\+C\+T\+U\+R\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}~\mbox{\hyperlink{structRTEMS__ALIGNED}{R\+T\+E\+M\+S\+\_\+\+A\+L\+I\+G\+N\+ED}}( \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}} )
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_af8823e651e33b9683e0d89e5a8054ee6}\label{lm32_2include_2rtems_2score_2cpu_8h_af8823e651e33b9683e0d89e5a8054ee6}} 
\#define {\bfseries C\+P\+U\+\_\+\+M\+O\+D\+E\+S\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+M\+A\+SK}~0x00000001
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_adea68a7fa02909edcebee08748f94223}\label{lm32_2include_2rtems_2score_2cpu_8h_adea68a7fa02909edcebee08748f94223}} 
\#define {\bfseries C\+P\+U\+\_\+\+M\+A\+X\+I\+M\+U\+M\+\_\+\+P\+R\+O\+C\+E\+S\+S\+O\+RS}~32
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Context_ga896055157b72692a6141f7c0039eabdf}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Get\+\_\+\+SP}}(\+\_\+context)~(\+\_\+context)-\/$>$\mbox{\hyperlink{group__mips__regs_ga8d40798874dab99986478ef00ff3e297}{sp}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_ab94869be93a41da88a10fa59771ce2c9}\label{lm32_2include_2rtems_2score_2cpu_8h_ab94869be93a41da88a10fa59771ce2c9}} 
\#define {\bfseries C\+P\+U\+\_\+\+M\+P\+C\+I\+\_\+\+R\+E\+C\+E\+I\+V\+E\+\_\+\+S\+E\+R\+V\+E\+R\+\_\+\+E\+X\+T\+R\+A\+\_\+\+S\+T\+A\+CK}~0
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a937007b12441849696a0462fee2b8d3e}\label{lm32_2include_2rtems_2score_2cpu_8h_a937007b12441849696a0462fee2b8d3e}} 
\#define {\bfseries C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+V\+E\+C\+T\+O\+RS}~32
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a3c2363ae6ca6575fc9147b1b7585b3b4}\label{lm32_2include_2rtems_2score_2cpu_8h_a3c2363ae6ca6575fc9147b1b7585b3b4}} 
\#define {\bfseries C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+M\+A\+X\+I\+M\+U\+M\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+N\+U\+M\+B\+ER}~(\mbox{\hyperlink{sparc_2include_2rtems_2score_2cpu_8h_a937007b12441849696a0462fee2b8d3e}{C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+V\+E\+C\+T\+O\+RS}} -\/ 1)
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a47f6e4d60c72b5f65fc775b0b5dd14ec}\label{lm32_2include_2rtems_2score_2cpu_8h_a47f6e4d60c72b5f65fc775b0b5dd14ec}} 
\#define {\bfseries C\+P\+U\+\_\+\+P\+R\+O\+V\+I\+D\+E\+S\+\_\+\+I\+S\+R\+\_\+\+I\+S\+\_\+\+I\+N\+\_\+\+P\+R\+O\+G\+R\+E\+SS}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a4c92ceea7549cc7b21db2c466916b733}\label{lm32_2include_2rtems_2score_2cpu_8h_a4c92ceea7549cc7b21db2c466916b733}} 
\#define {\bfseries C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+M\+I\+N\+I\+M\+U\+M\+\_\+\+S\+I\+ZE}~(1024$\ast$4)
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_aea4bd2905092d69bc92fbff6103ced8b}\label{lm32_2include_2rtems_2score_2cpu_8h_aea4bd2905092d69bc92fbff6103ced8b}} 
\#define {\bfseries C\+P\+U\+\_\+\+S\+I\+Z\+E\+O\+F\+\_\+\+P\+O\+I\+N\+T\+ER}~4
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~4
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}{C\+P\+U\+\_\+\+H\+E\+A\+P\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~\mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a8aed43eb1b3c346772c127482b4b5372}{C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~\mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a6a578627686e1020a28f5a295703ca74}\label{lm32_2include_2rtems_2score_2cpu_8h_a6a578627686e1020a28f5a295703ca74}} 
\#define {\bfseries C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}~\mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}}
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gad1ef5062849284d81496e1e6d33fb7ff}{\+\_\+\+C\+P\+U\+\_\+\+Initialize\+\_\+vectors}}()
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gaca3fde6f372ee51fdd893c260e7d7146}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable}}(\+\_\+isr\+\_\+cookie)~lm32\+\_\+disable\+\_\+interrupts( \+\_\+isr\+\_\+cookie );
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gae3b1e2cd1ea4020d229e759569459664}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable}}(\+\_\+isr\+\_\+cookie)~lm32\+\_\+enable\+\_\+interrupts( \+\_\+isr\+\_\+cookie );
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash}}(\+\_\+isr\+\_\+cookie)~lm32\+\_\+flash\+\_\+interrupts( \+\_\+isr\+\_\+cookie );
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gaed8717a2f15938d954c7124cd11e899f}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level}}(new\+\_\+level)
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize}(\+\_\+the\+\_\+context,  \+\_\+stack\+\_\+base,  \+\_\+size,  \+\_\+isr,  \+\_\+entry\+\_\+point,  \+\_\+is\+\_\+fp,  \+\_\+tls\+\_\+area)
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a3fb67e174d7b61251322cd32126acd1a}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Restart\+\_\+self}}(\+\_\+the\+\_\+context)~\mbox{\hyperlink{group__RTEMSScoreCPUARM_ga80726ebfe00f31a88b086cc4474c472f}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore}}( (\+\_\+the\+\_\+context) );
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_ac34a28abe9b31559d4096b2c942860a6}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize\+\_\+fp}}(\+\_\+destination)
\item 
\#define \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a4c07c0150ec7894dd128993e931ceee5}{\+\_\+\+C\+P\+U\+\_\+\+Fatal\+\_\+halt}}(\+\_\+source,  \+\_\+error)
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_ab0aff7a561b9c030a4d88eff201f4688}\label{lm32_2include_2rtems_2score_2cpu_8h_ab0aff7a561b9c030a4d88eff201f4688}} 
\#define {\bfseries C\+P\+U\+\_\+\+U\+S\+E\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+B\+I\+T\+F\+I\+E\+L\+D\+\_\+\+C\+O\+DE}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void($\ast$ {\bfseries C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler}) (void)
\item 
typedef void($\ast$ {\bfseries C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler}) (uint32\+\_\+t)
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a09f1943559c701e24e5057e9aaea0d13}\label{lm32_2include_2rtems_2score_2cpu_8h_a09f1943559c701e24e5057e9aaea0d13}} 
typedef \mbox{\hyperlink{structCPU__Interrupt__frame}{C\+P\+U\+\_\+\+Interrupt\+\_\+frame}} {\bfseries C\+P\+U\+\_\+\+Exception\+\_\+frame}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}\label{lm32_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}} 
typedef uint32\+\_\+t {\bfseries C\+P\+U\+\_\+\+Counter\+\_\+ticks}
\item 
typedef uintptr\+\_\+t \mbox{\hyperlink{lm32_2include_2rtems_2score_2cpu_8h_a9fca17f81f850e128fcc8ed5b87ff2ab}{C\+P\+U\+\_\+\+Uint32ptr}}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} bool {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Is\+\_\+enabled} (uint32\+\_\+t level)
\item 
uint32\+\_\+t \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_ga1d9dcab9170d532b6634a5620385adbd}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level}} (void)
\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga869484e3d851b032fd826c69ff21fc72}{\+\_\+\+C\+P\+U\+\_\+\+Initialize}} (void)
\begin{DoxyCompactList}\small\item\em C\+PU initialization. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} void \mbox{\hyperlink{group__RTEMSScoreCPUlm32Interrupt_gaa993b7752d5db306f85586ac400432ab}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+raw\+\_\+handler}} (uint32\+\_\+t vector, C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler new\+\_\+handler, C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler $\ast$old\+\_\+handler)
\begin{DoxyCompactList}\small\item\em S\+P\+A\+RC specific raw I\+SR installer. \end{DoxyCompactList}\item 
void {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+vector} (uint32\+\_\+t vector, C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler new\+\_\+handler, C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler $\ast$old\+\_\+handler)
\item 
void $\ast$ {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Thread\+\_\+\+Idle\+\_\+body} (uintptr\+\_\+t ignored)
\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa9f8cc989454b28232e5375e30c90970}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+switch}} (\mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}} $\ast$run, \mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}} $\ast$heir)
\begin{DoxyCompactList}\small\item\em C\+PU switch context. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUlm32Context_ga80726ebfe00f31a88b086cc4474c472f}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore}} (\mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}} $\ast$new\+\_\+context) \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa2f0ed67aa174f684bb31b7e8bdb386f}{R\+T\+E\+M\+S\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN}}
\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa34a35de496258577c1454ba1ee07ce0}{\+\_\+\+C\+P\+U\+\_\+\+Exception\+\_\+frame\+\_\+print}} (const \mbox{\hyperlink{structCPU__Exception__frame}{C\+P\+U\+\_\+\+Exception\+\_\+frame}} $\ast$frame)
\begin{DoxyCompactList}\small\item\em Prints the exception frame via \mbox{\hyperlink{bspIo_8h_a380cfecc8035cec8a13b68c0cb90f32f}{printk()}}. \end{DoxyCompactList}\item 
uint32\+\_\+t {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Counter\+\_\+frequency} (void)
\item 
\mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}{C\+P\+U\+\_\+\+Counter\+\_\+ticks}} {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Counter\+\_\+read} (void)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a1f629201dc9ea82fadc9180deb2a6f01}\label{lm32_2include_2rtems_2score_2cpu_8h_a1f629201dc9ea82fadc9180deb2a6f01}} 
char {\bfseries \+\_\+gp} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
L\+M32 C\+PU Department Source. 

This include file contains information pertaining to the L\+M32 processor. 

\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a0eb108f0a842cd0659e42289f5757bb3}\label{lm32_2include_2rtems_2score_2cpu_8h_a0eb108f0a842cd0659e42289f5757bb3}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Initialize@{\_CPU\_Context\_Initialize}}
\index{\_CPU\_Context\_Initialize@{\_CPU\_Context\_Initialize}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Initialize}{\_CPU\_Context\_Initialize}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize(\begin{DoxyParamCaption}\item[{}]{\+\_\+the\+\_\+context,  }\item[{}]{\+\_\+stack\+\_\+base,  }\item[{}]{\+\_\+size,  }\item[{}]{\+\_\+isr,  }\item[{}]{\+\_\+entry\+\_\+point,  }\item[{}]{\+\_\+is\+\_\+fp,  }\item[{}]{\+\_\+tls\+\_\+area }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{do} \{ \(\backslash\)}
\DoxyCodeLine{     uint32\_t \_stack = (uint32\_t)(\_stack\_base) + (\_size) - 4; \(\backslash\)}
\DoxyCodeLine{     \(\backslash\)}
\DoxyCodeLine{     (void) \_is\_fp; \textcolor{comment}{/* avoid warning for being unused */} \(\backslash\)}
\DoxyCodeLine{     (void) \_isr;  \textcolor{comment}{/* avoid warning for being unused */} \(\backslash\)}
\DoxyCodeLine{     (\_the\_context)->\mbox{\hyperlink{group__mips__regs_gae9c24f3b396f6bdaacd0e52f68b9a314}{gp}} = (uint32\_t)\_gp; \(\backslash\)}
\DoxyCodeLine{     (\_the\_context)->\mbox{\hyperlink{group__mips__regs_gae771351dd440a8640270282362e338d0}{fp}} = (uint32\_t)\_stack; \(\backslash\)}
\DoxyCodeLine{     (\_the\_context)->\mbox{\hyperlink{group__mips__regs_ga8d40798874dab99986478ef00ff3e297}{sp}} = (uint32\_t)\_stack; \(\backslash\)}
\DoxyCodeLine{     (\_the\_context)->\mbox{\hyperlink{group__mips__regs_ga6c3a7669c6bdfd66528633d977cdb6b8}{ra}} = (uint32\_t)(\_entry\_point); \(\backslash\)}
\DoxyCodeLine{   \} \textcolor{keywordflow}{while} ( 0 )}

\end{DoxyCode}
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_ac34a28abe9b31559d4096b2c942860a6}\label{lm32_2include_2rtems_2score_2cpu_8h_ac34a28abe9b31559d4096b2c942860a6}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Initialize\_fp@{\_CPU\_Context\_Initialize\_fp}}
\index{\_CPU\_Context\_Initialize\_fp@{\_CPU\_Context\_Initialize\_fp}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Initialize\_fp}{\_CPU\_Context\_Initialize\_fp}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize\+\_\+fp(\begin{DoxyParamCaption}\item[{}]{\+\_\+destination }\end{DoxyParamCaption})}

This routine initializes the FP context area passed to it to. There are a few standard ways in which to initialize the floating point context. The code included for this macro assumes that this is a C\+PU in which a \char`\"{}initial\char`\"{} FP context was saved into {\itshape \+\_\+\+C\+P\+U\+\_\+\+Null\+\_\+fp\+\_\+context} and it simply copies it to the destination context passed to it.

Other floating point context save/restore models include\+:
\begin{DoxyEnumerate}
\item not doing anything, and
\item putting a \char`\"{}null F\+P status word\char`\"{} in the correct place in the FP context.
\end{DoxyEnumerate}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \+\_\+destination} & is the floating point context area\\
\hline
\end{DoxyParams}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a3fb67e174d7b61251322cd32126acd1a}\label{lm32_2include_2rtems_2score_2cpu_8h_a3fb67e174d7b61251322cd32126acd1a}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Restart\_self@{\_CPU\_Context\_Restart\_self}}
\index{\_CPU\_Context\_Restart\_self@{\_CPU\_Context\_Restart\_self}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Restart\_self}{\_CPU\_Context\_Restart\_self}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Restart\+\_\+self(\begin{DoxyParamCaption}\item[{}]{\+\_\+the\+\_\+context }\end{DoxyParamCaption})~\mbox{\hyperlink{group__RTEMSScoreCPUARM_ga80726ebfe00f31a88b086cc4474c472f}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore}}( (\+\_\+the\+\_\+context) );}

This routine is responsible for somehow restarting the currently executing task. If you are lucky, then all that is necessary is restoring the context. Otherwise, there will need to be a special assembly routine which does something special in this case. For many ports, simply adding a label to the restore path of \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa9f8cc989454b28232e5375e30c90970}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+switch}} will work. On other ports, it may be possibly to load a few arguments and jump to the restore path. It will not work if restarting self conflicts with the stack frame assumptions of restoring a context.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a4c07c0150ec7894dd128993e931ceee5}\label{lm32_2include_2rtems_2score_2cpu_8h_a4c07c0150ec7894dd128993e931ceee5}} 
\index{cpu.h@{cpu.h}!\_CPU\_Fatal\_halt@{\_CPU\_Fatal\_halt}}
\index{\_CPU\_Fatal\_halt@{\_CPU\_Fatal\_halt}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Fatal\_halt}{\_CPU\_Fatal\_halt}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Fatal\+\_\+halt(\begin{DoxyParamCaption}\item[{}]{\+\_\+source,  }\item[{}]{\+\_\+error }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
This routine copies \+\_\+error into a known place -- typically a stack location or a register, optionally disables interrupts, and halts/stops the C\+PU.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}\label{lm32_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}} 
\index{cpu.h@{cpu.h}!CPU\_ALIGNMENT@{CPU\_ALIGNMENT}}
\index{CPU\_ALIGNMENT@{CPU\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ALIGNMENT}{CPU\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~4}

C\+PU\textquotesingle{}s worst alignment requirement for data types on a byte boundary. This alignment does not take into account the requirements for the stack.

Port Specific Information\+: The L\+M32 architecture manual simply states\+: \char`\"{}\+All memory accesses must be
aligned to the size of the access\char`\"{}, and there is no hardware support whatsoever for 64-\/bit numbers. (lm32\+\_\+archman.\+pdf, July 2009, p. 15) \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a225de03a8647bf307a73cf907969778d}\label{lm32_2include_2rtems_2score_2cpu_8h_a225de03a8647bf307a73cf907969778d}} 
\index{cpu.h@{cpu.h}!CPU\_ALL\_TASKS\_ARE\_FP@{CPU\_ALL\_TASKS\_ARE\_FP}}
\index{CPU\_ALL\_TASKS\_ARE\_FP@{CPU\_ALL\_TASKS\_ARE\_FP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ALL\_TASKS\_ARE\_FP}{CPU\_ALL\_TASKS\_ARE\_FP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+A\+L\+L\+\_\+\+T\+A\+S\+K\+S\+\_\+\+A\+R\+E\+\_\+\+FP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Are all tasks R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT tasks implicitly?

If T\+R\+UE, then the R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task attribute is assumed. If F\+A\+L\+SE, then the R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task attribute is followed.

So far, the only C\+P\+Us in which this option has been used are the HP P\+A-\/\+R\+I\+SC and Power\+PC. On the P\+A-\/\+R\+I\+SC, The HP C compiler and gcc both implicitly used the floating point registers to perform integer multiplies. Similarly, the Power\+PC port of gcc has been seen to allocate floating point local variables and touch the F\+PU even when the flow through a subroutine (like vfprintf()) might not use floating point formats.

If a function which you would not think utilize the FP unit D\+O\+ES, then one can not easily predict which tasks will use the FP hardware. In this case, this option should be T\+R\+UE.

If \mbox{\hyperlink{sparc_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}{C\+P\+U\+\_\+\+H\+A\+R\+D\+W\+A\+R\+E\+\_\+\+FP}} is F\+A\+L\+SE, then this should be F\+A\+L\+SE as well.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}\label{lm32_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}} 
\index{cpu.h@{cpu.h}!CPU\_HEAP\_ALIGNMENT@{CPU\_HEAP\_ALIGNMENT}}
\index{CPU\_HEAP\_ALIGNMENT@{CPU\_HEAP\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_HEAP\_ALIGNMENT}{CPU\_HEAP\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+H\+E\+A\+P\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~\mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}}

This number corresponds to the byte alignment requirement for the heap handler. This alignment requirement may be stricter than that for the data types alignment specified by \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}. It is common for the heap to follow the same alignment requirement as \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}. If the \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} is strict enough for the heap, then this should be set to \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}.

N\+O\+TE\+: This does not have to be a power of 2 although it should be a multiple of 2 greater than or equal to 2. The requirement to be a multiple of 2 is because the heap uses the least significant field of the front and back flags to indicate that a block is in use or free. So you do not want any odd length blocks really putting length data in that bit.

On byte oriented architectures, \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}{C\+P\+U\+\_\+\+H\+E\+A\+P\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} normally will have to be greater or equal to than \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} to ensure that elements allocated from the heap meet all restrictions.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_af1c906c8ee4c3d012dc456285e42d3ee}\label{lm32_2include_2rtems_2score_2cpu_8h_af1c906c8ee4c3d012dc456285e42d3ee}} 
\index{cpu.h@{cpu.h}!CPU\_IDLE\_TASK\_IS\_FP@{CPU\_IDLE\_TASK\_IS\_FP}}
\index{CPU\_IDLE\_TASK\_IS\_FP@{CPU\_IDLE\_TASK\_IS\_FP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_IDLE\_TASK\_IS\_FP}{CPU\_IDLE\_TASK\_IS\_FP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+I\+D\+L\+E\+\_\+\+T\+A\+S\+K\+\_\+\+I\+S\+\_\+\+FP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Should the I\+D\+LE task have a floating point context?

If T\+R\+UE, then the I\+D\+LE task is created as a R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task and it has a floating point context which is switched in and out. If F\+A\+L\+SE, then the I\+D\+LE task does not have a floating point context.

Setting this to T\+R\+UE negatively impacts the time required to preempt the I\+D\+LE task from an interrupt because the floating point context must be saved as part of the preemption.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a30c4d320f85b1383c5059da5b19b164a}\label{lm32_2include_2rtems_2score_2cpu_8h_a30c4d320f85b1383c5059da5b19b164a}} 
\index{cpu.h@{cpu.h}!CPU\_ISR\_PASSES\_FRAME\_POINTER@{CPU\_ISR\_PASSES\_FRAME\_POINTER}}
\index{CPU\_ISR\_PASSES\_FRAME\_POINTER@{CPU\_ISR\_PASSES\_FRAME\_POINTER}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ISR\_PASSES\_FRAME\_POINTER}{CPU\_ISR\_PASSES\_FRAME\_POINTER}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+P\+A\+S\+S\+E\+S\+\_\+\+F\+R\+A\+M\+E\+\_\+\+P\+O\+I\+N\+T\+ER~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Does the R\+T\+E\+MS invoke the user\textquotesingle{}s I\+SR with the vector number and a pointer to the saved interrupt frame (1) or just the vector number (0)?

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a1eca01dbb1ef2873349cc4e222509f0a}\label{lm32_2include_2rtems_2score_2cpu_8h_a1eca01dbb1ef2873349cc4e222509f0a}} 
\index{cpu.h@{cpu.h}!CPU\_SIMPLE\_VECTORED\_INTERRUPTS@{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}}
\index{CPU\_SIMPLE\_VECTORED\_INTERRUPTS@{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+E\+C\+T\+O\+R\+E\+D\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+TS~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Does the C\+PU follow the simple vectored interrupt model?

If T\+R\+UE, then R\+T\+E\+MS allocates the vector table it internally manages. If F\+A\+L\+SE, then the B\+SP is assumed to allocate and manage the vector table

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a8aed43eb1b3c346772c127482b4b5372}\label{lm32_2include_2rtems_2score_2cpu_8h_a8aed43eb1b3c346772c127482b4b5372}} 
\index{cpu.h@{cpu.h}!CPU\_STACK\_ALIGNMENT@{CPU\_STACK\_ALIGNMENT}}
\index{CPU\_STACK\_ALIGNMENT@{CPU\_STACK\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_STACK\_ALIGNMENT}{CPU\_STACK\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~\mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}}

This number corresponds to the byte alignment requirement for the stack. This alignment requirement may be stricter than that for the data types alignment specified by \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}.

Port Specific Information\+:

Stack is software-\/managed \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_ac40d98a563f63934a5775f1366ba1b67}\label{lm32_2include_2rtems_2score_2cpu_8h_ac40d98a563f63934a5775f1366ba1b67}} 
\index{cpu.h@{cpu.h}!CPU\_STACK\_GROWS\_UP@{CPU\_STACK\_GROWS\_UP}}
\index{CPU\_STACK\_GROWS\_UP@{CPU\_STACK\_GROWS\_UP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_STACK\_GROWS\_UP}{CPU\_STACK\_GROWS\_UP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+G\+R\+O\+W\+S\+\_\+\+UP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Does the stack grow up (toward higher addresses) or down (toward lower addresses)?

If T\+R\+UE, then the grows upward. If F\+A\+L\+SE, then the grows toward smaller addresses.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a155bcf88149016c6c58f30eeab9f1598}\label{lm32_2include_2rtems_2score_2cpu_8h_a155bcf88149016c6c58f30eeab9f1598}} 
\index{cpu.h@{cpu.h}!CPU\_USE\_DEFERRED\_FP\_SWITCH@{CPU\_USE\_DEFERRED\_FP\_SWITCH}}
\index{CPU\_USE\_DEFERRED\_FP\_SWITCH@{CPU\_USE\_DEFERRED\_FP\_SWITCH}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_USE\_DEFERRED\_FP\_SWITCH}{CPU\_USE\_DEFERRED\_FP\_SWITCH}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+U\+S\+E\+\_\+\+D\+E\+F\+E\+R\+R\+E\+D\+\_\+\+F\+P\+\_\+\+S\+W\+I\+T\+CH~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Should the saving of the floating point registers be deferred until a context switch is made to another different floating point task?

If T\+R\+UE, then the floating point context will not be stored until necessary. It will remain in the floating point registers and not disturned until another floating point task is switched to.

If F\+A\+L\+SE, then the floating point context is saved when a floating point task is switched out and restored when the next floating point task is restored. The state of the floating point registers between those two operations is not specified.

If the floating point context does N\+OT have to be saved as part of interrupt dispatching, then it should be safe to set this to T\+R\+UE.

Setting this flag to T\+R\+UE results in using a different algorithm for deciding when to save and restore the floating point context. The deferred FP switch algorithm minimizes the number of times the FP context is saved and restored. The FP context is not saved until a context switch is made to another, different FP task. Thus in a system with only one FP task, the FP context will never be saved or restored.

Port Specific Information\+:

X\+XX document implementation including references if appropriate 

\subsection{Typedef Documentation}
\mbox{\Hypertarget{lm32_2include_2rtems_2score_2cpu_8h_a9fca17f81f850e128fcc8ed5b87ff2ab}\label{lm32_2include_2rtems_2score_2cpu_8h_a9fca17f81f850e128fcc8ed5b87ff2ab}} 
\index{cpu.h@{cpu.h}!CPU\_Uint32ptr@{CPU\_Uint32ptr}}
\index{CPU\_Uint32ptr@{CPU\_Uint32ptr}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_Uint32ptr}{CPU\_Uint32ptr}}
{\footnotesize\ttfamily typedef uintptr\+\_\+t \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga9fca17f81f850e128fcc8ed5b87ff2ab}{C\+P\+U\+\_\+\+Uint32ptr}}}

Type that can store a 32-\/bit integer or a pointer. 