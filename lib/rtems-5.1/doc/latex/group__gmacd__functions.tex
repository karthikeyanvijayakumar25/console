\hypertarget{group__gmacd__functions}{}\section{G\+M\+AC Driver Functions}
\label{group__gmacd__functions}\index{GMAC Driver Functions@{GMAC Driver Functions}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__gmacd__functions_ga782194c9b7163c22016beabc6101856c}{G\+M\+A\+C\+D\+\_\+\+Handler}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, gmac\+Que\+List\+\_\+t que\+Idx)
\begin{DoxyCompactList}\small\item\em G\+M\+AC Interrupt handler. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__gmacd__functions_ga8706caf686e1d073851111db1ba2663c}{G\+M\+A\+C\+D\+\_\+\+Init}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, \mbox{\hyperlink{structGmac}{Gmac}} $\ast$p\+Hw, uint8\+\_\+t b\+ID, uint8\+\_\+t enable\+C\+AF, uint8\+\_\+t enable\+N\+BC)
\begin{DoxyCompactList}\small\item\em Initialize the G\+M\+AC with the \mbox{\hyperlink{structGmac}{Gmac}} controller address. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{group__gmacd__functions_ga418589cbbef19de6084670d572b6ae27}{G\+M\+A\+C\+D\+\_\+\+Init\+Transfer}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, const \mbox{\hyperlink{group__gmacd__types_ga5ab53aef1a598e4d862677f8f1928b20}{s\+Gmac\+Init}} $\ast$p\+Init, gmac\+Que\+List\+\_\+t que\+Idx)
\item 
void \mbox{\hyperlink{group__gmacd__functions_gaede5219eb9101a760ecb266722825318}{G\+M\+A\+C\+D\+\_\+\+Reset}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd)
\item 
uint8\+\_\+t \mbox{\hyperlink{group__gmacd__functions_ga4dade176be1ff02c5dfb6371d873b5ed}{G\+M\+A\+C\+D\+\_\+\+Send\+SG}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, const \mbox{\hyperlink{group__gmacd__types_ga97ea4785757f8d33d38ed0563d84bfa4}{s\+Gmac\+S\+G\+List}} $\ast$sgl, \mbox{\hyperlink{group__gmacd__types_ga64979042bf43f697de166e864e3259de}{f\+Gmacd\+Transfer\+Callback}} f\+Tx\+Cb, gmac\+Que\+List\+\_\+t que\+Idx)
\begin{DoxyCompactList}\small\item\em Send a frame split into buffers. If the frame size is larger than transfer buffer size error returned. If frame transfer status is monitored, specify callback for each frame. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{group__gmacd__functions_ga2f3e029556b9627258a2eb1dc4919d95}{G\+M\+A\+C\+D\+\_\+\+Send}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, void $\ast$p\+Buffer, uint32\+\_\+t \mbox{\hyperlink{sun4u_2tte_8h_a245260f6f74972558f61b85227df5aae}{size}}, \mbox{\hyperlink{group__gmacd__types_ga64979042bf43f697de166e864e3259de}{f\+Gmacd\+Transfer\+Callback}} f\+Tx\+Cb, gmac\+Que\+List\+\_\+t que\+Idx)
\begin{DoxyCompactList}\small\item\em Send a packet with G\+M\+AC. If the packet size is larger than transfer buffer size error returned. If packet transfer status is monitored, specify callback for each packet. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{group__gmacd__functions_ga1bd3fe40e63537dce59dd4368dce4253}{G\+M\+A\+C\+D\+\_\+\+Tx\+Load}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, gmac\+Que\+List\+\_\+t que\+Idx)
\item 
uint8\+\_\+t \mbox{\hyperlink{group__gmacd__functions_gaa45b1118c5a1147bde4e3026194bc965}{G\+M\+A\+C\+D\+\_\+\+Poll}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, uint8\+\_\+t $\ast$p\+Frame, uint32\+\_\+t frame\+Size, uint32\+\_\+t $\ast$p\+Rcv\+Size, gmac\+Que\+List\+\_\+t que\+Idx)
\begin{DoxyCompactList}\small\item\em Receive a packet with G\+M\+AC. If not enough buffer for the packet, the remaining data is lost but right frame length is returned. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__gmacd__functions_ga3ea0884def476f9698f1cdbae6b6f3e2}{G\+M\+A\+C\+D\+\_\+\+Set\+Rx\+Callback}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, \mbox{\hyperlink{group__gmacd__types_ga64979042bf43f697de166e864e3259de}{f\+Gmacd\+Transfer\+Callback}} f\+Rx\+Cb, gmac\+Que\+List\+\_\+t que\+Idx)
\begin{DoxyCompactList}\small\item\em Registers p\+Rx\+Cb callback. Callback will be invoked after the next received frame. When G\+M\+A\+C\+\_\+\+Poll() returns G\+M\+A\+C\+\_\+\+R\+X\+\_\+\+N\+O\+\_\+\+D\+A\+TA the application task call G\+M\+A\+C\+\_\+\+Set\+\_\+\+Rx\+Cb() to register p\+Rx\+Cb() callback and enters suspend state. The callback is in charge to resume the task once a new frame has been received. The next time G\+M\+A\+C\+\_\+\+Poll() is called, it will be successful. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{group__gmacd__functions_ga0806a8a23ffb3180d3404ec6d7fbfa1d}{G\+M\+A\+C\+D\+\_\+\+Set\+Tx\+Wakeup\+Callback}} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, \mbox{\hyperlink{group__gmacd__types_ga44e6be4bb53db0660baf6cb50b20a684}{f\+Gmacd\+Wakeup\+Callback}} f\+Wakeup, uint8\+\_\+t b\+Threshold, gmac\+Que\+List\+\_\+t que\+Idx)
\item 
\mbox{\Hypertarget{group__gmacd__functions_ga14397a277fce1b135fe1b2fc486c224f}\label{group__gmacd__functions_ga14397a277fce1b135fe1b2fc486c224f}} 
void {\bfseries G\+M\+A\+C\+D\+\_\+\+Tx\+Ptp\+Evt\+Msg\+C\+B\+Register} (\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$p\+Gmacd, \mbox{\hyperlink{group__gmacd__types_gad3329dfe65f5877f50ee8a4fd8e63f08}{f\+Gmacd\+Tx\+Ptp\+Evt\+Call\+Back}} p\+Tx\+Ptp\+Evt\+Cb, gmac\+Que\+List\+\_\+t que\+Idx)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__gmacd__functions_ga782194c9b7163c22016beabc6101856c}\label{group__gmacd__functions_ga782194c9b7163c22016beabc6101856c}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_Handler@{GMACD\_Handler}}
\index{GMACD\_Handler@{GMACD\_Handler}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_Handler()}{GMACD\_Handler()}}
{\footnotesize\ttfamily void G\+M\+A\+C\+D\+\_\+\+Handler (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}



G\+M\+AC Interrupt handler. 


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__gmacd__functions_ga8706caf686e1d073851111db1ba2663c}\label{group__gmacd__functions_ga8706caf686e1d073851111db1ba2663c}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_Init@{GMACD\_Init}}
\index{GMACD\_Init@{GMACD\_Init}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_Init()}{GMACD\_Init()}}
{\footnotesize\ttfamily void G\+M\+A\+C\+D\+\_\+\+Init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{\mbox{\hyperlink{structGmac}{Gmac}} $\ast$}]{p\+Hw,  }\item[{uint8\+\_\+t}]{b\+ID,  }\item[{uint8\+\_\+t}]{enable\+C\+AF,  }\item[{uint8\+\_\+t}]{enable\+N\+BC }\end{DoxyParamCaption})}



Initialize the G\+M\+AC with the \mbox{\hyperlink{structGmac}{Gmac}} controller address. 


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em p\+Hw} & Pointer to HW address for registers. \\
\hline
{\em b\+ID} & HW ID for power management \\
\hline
{\em enable\+C\+AF} & Enable/\+Disable Copy\+All\+Frame. \\
\hline
{\em enable\+N\+BC} & Enable/\+Disable No\+Broad\+Cast. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__gmacd__functions_ga418589cbbef19de6084670d572b6ae27}\label{group__gmacd__functions_ga418589cbbef19de6084670d572b6ae27}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_InitTransfer@{GMACD\_InitTransfer}}
\index{GMACD\_InitTransfer@{GMACD\_InitTransfer}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_InitTransfer()}{GMACD\_InitTransfer()}}
{\footnotesize\ttfamily uint8\+\_\+t G\+M\+A\+C\+D\+\_\+\+Init\+Transfer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{const \mbox{\hyperlink{group__gmacd__types_ga5ab53aef1a598e4d862677f8f1928b20}{s\+Gmac\+Init}} $\ast$}]{p\+Init,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}

Initialize necessary allocated buffer lists for G\+M\+AC Driver to transfer data. Must be invoked after \mbox{\hyperlink{group__gmacd__defines_ga8706caf686e1d073851111db1ba2663c}{G\+M\+A\+C\+D\+\_\+\+Init()}} but before R\+X/\+TX start. Replace the deprecated \mbox{\hyperlink{group__gmacd__defines_ga418589cbbef19de6084670d572b6ae27}{G\+M\+A\+C\+D\+\_\+\+Init\+Transfer()}}. 
\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em p\+Init} & Pointer to s\+Gmac\+Init. \\
\hline
{\em p\+Init} & Pointer to gmac\+Que\+List\+\_\+t for different queue. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
G\+M\+A\+C\+D\+\_\+\+OK or G\+M\+A\+C\+D\+\_\+\+P\+A\+R\+AM. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If input address is not 8-\/byte aligned the address is automatically adjusted and the list size is reduced by one. 
\end{DoxyNote}
\mbox{\Hypertarget{group__gmacd__functions_gaa45b1118c5a1147bde4e3026194bc965}\label{group__gmacd__functions_gaa45b1118c5a1147bde4e3026194bc965}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_Poll@{GMACD\_Poll}}
\index{GMACD\_Poll@{GMACD\_Poll}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_Poll()}{GMACD\_Poll()}}
{\footnotesize\ttfamily uint8\+\_\+t G\+M\+A\+C\+D\+\_\+\+Poll (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{uint8\+\_\+t $\ast$}]{p\+Frame,  }\item[{uint32\+\_\+t}]{frame\+Size,  }\item[{uint32\+\_\+t $\ast$}]{p\+Rcv\+Size,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}



Receive a packet with G\+M\+AC. If not enough buffer for the packet, the remaining data is lost but right frame length is returned. 


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em p\+Frame} & Buffer to store the frame \\
\hline
{\em frame\+Size} & Size of the frame \\
\hline
{\em p\+Rcv\+Size} & Received size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
OK, no data, or frame too small 
\end{DoxyReturn}
\mbox{\Hypertarget{group__gmacd__functions_gaede5219eb9101a760ecb266722825318}\label{group__gmacd__functions_gaede5219eb9101a760ecb266722825318}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_Reset@{GMACD\_Reset}}
\index{GMACD\_Reset@{GMACD\_Reset}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_Reset()}{GMACD\_Reset()}}
{\footnotesize\ttfamily void G\+M\+A\+C\+D\+\_\+\+Reset (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd }\end{DoxyParamCaption})}

Reset TX \& RX queue \& statistics 
\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__gmacd__functions_ga2f3e029556b9627258a2eb1dc4919d95}\label{group__gmacd__functions_ga2f3e029556b9627258a2eb1dc4919d95}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_Send@{GMACD\_Send}}
\index{GMACD\_Send@{GMACD\_Send}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_Send()}{GMACD\_Send()}}
{\footnotesize\ttfamily uint8\+\_\+t G\+M\+A\+C\+D\+\_\+\+Send (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{void $\ast$}]{p\+Buffer,  }\item[{uint32\+\_\+t}]{size,  }\item[{\mbox{\hyperlink{group__gmacd__types_ga64979042bf43f697de166e864e3259de}{f\+Gmacd\+Transfer\+Callback}}}]{f\+Tx\+Cb,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}



Send a packet with G\+M\+AC. If the packet size is larger than transfer buffer size error returned. If packet transfer status is monitored, specify callback for each packet. 


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em p\+Buffer} & The buffer to be send \\
\hline
{\em size} & The size of buffer to be send \\
\hline
{\em f\+Tx\+Cb} & Threshold Wakeup callback \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
OK, Busy or invalid packet 
\end{DoxyReturn}
\mbox{\Hypertarget{group__gmacd__functions_ga4dade176be1ff02c5dfb6371d873b5ed}\label{group__gmacd__functions_ga4dade176be1ff02c5dfb6371d873b5ed}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_SendSG@{GMACD\_SendSG}}
\index{GMACD\_SendSG@{GMACD\_SendSG}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_SendSG()}{GMACD\_SendSG()}}
{\footnotesize\ttfamily uint8\+\_\+t G\+M\+A\+C\+D\+\_\+\+Send\+SG (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{const \mbox{\hyperlink{group__gmacd__types_ga97ea4785757f8d33d38ed0563d84bfa4}{s\+Gmac\+S\+G\+List}} $\ast$}]{sgl,  }\item[{\mbox{\hyperlink{group__gmacd__types_ga64979042bf43f697de166e864e3259de}{f\+Gmacd\+Transfer\+Callback}}}]{f\+Tx\+Cb,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}



Send a frame split into buffers. If the frame size is larger than transfer buffer size error returned. If frame transfer status is monitored, specify callback for each frame. 


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em sgl} & Pointer to a scatter-\/gather list describing the buffers of the ethernet frame. \\
\hline
{\em f\+Tx\+Cb} & Pointer to callback function. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__gmacd__functions_ga3ea0884def476f9698f1cdbae6b6f3e2}\label{group__gmacd__functions_ga3ea0884def476f9698f1cdbae6b6f3e2}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_SetRxCallback@{GMACD\_SetRxCallback}}
\index{GMACD\_SetRxCallback@{GMACD\_SetRxCallback}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_SetRxCallback()}{GMACD\_SetRxCallback()}}
{\footnotesize\ttfamily void G\+M\+A\+C\+D\+\_\+\+Set\+Rx\+Callback (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{\mbox{\hyperlink{group__gmacd__types_ga64979042bf43f697de166e864e3259de}{f\+Gmacd\+Transfer\+Callback}}}]{f\+Rx\+Cb,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}



Registers p\+Rx\+Cb callback. Callback will be invoked after the next received frame. When G\+M\+A\+C\+\_\+\+Poll() returns G\+M\+A\+C\+\_\+\+R\+X\+\_\+\+N\+O\+\_\+\+D\+A\+TA the application task call G\+M\+A\+C\+\_\+\+Set\+\_\+\+Rx\+Cb() to register p\+Rx\+Cb() callback and enters suspend state. The callback is in charge to resume the task once a new frame has been received. The next time G\+M\+A\+C\+\_\+\+Poll() is called, it will be successful. 


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em f\+Rx\+Cb} & Pointer to callback function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
OK, no data, or frame too small 
\end{DoxyReturn}
\mbox{\Hypertarget{group__gmacd__functions_ga0806a8a23ffb3180d3404ec6d7fbfa1d}\label{group__gmacd__functions_ga0806a8a23ffb3180d3404ec6d7fbfa1d}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_SetTxWakeupCallback@{GMACD\_SetTxWakeupCallback}}
\index{GMACD\_SetTxWakeupCallback@{GMACD\_SetTxWakeupCallback}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_SetTxWakeupCallback()}{GMACD\_SetTxWakeupCallback()}}
{\footnotesize\ttfamily uint8\+\_\+t G\+M\+A\+C\+D\+\_\+\+Set\+Tx\+Wakeup\+Callback (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{\mbox{\hyperlink{group__gmacd__types_ga44e6be4bb53db0660baf6cb50b20a684}{f\+Gmacd\+Wakeup\+Callback}}}]{f\+Wakeup,  }\item[{uint8\+\_\+t}]{b\+Threshold,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}

Register/\+Clear TX wakeup callback.

When \mbox{\hyperlink{group__gmacd__defines_ga2f3e029556b9627258a2eb1dc4919d95}{G\+M\+A\+C\+D\+\_\+\+Send()}} returns G\+M\+A\+C\+D\+\_\+\+T\+X\+\_\+\+B\+U\+SY (all TD busy) the application task calls \mbox{\hyperlink{group__gmacd__defines_ga0806a8a23ffb3180d3404ec6d7fbfa1d}{G\+M\+A\+C\+D\+\_\+\+Set\+Tx\+Wakeup\+Callback()}} to register f\+Wakeup() callback and enters suspend state. The callback is in charge to resume the task once several TD have been released. The next time \mbox{\hyperlink{group__gmacd__defines_ga2f3e029556b9627258a2eb1dc4919d95}{G\+M\+A\+C\+D\+\_\+\+Send()}} will be called, it shall be successful.

This function is usually invoked with N\+U\+LL callback from the TX wakeup callback itself, to unregister. Once the callback has resumed the application task, there is no need to invoke the callback again.


\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
{\em f\+Wakeup} & Wakeup callback. \\
\hline
{\em b\+Threshold} & Number of free TD before wakeup callback invoked. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
G\+M\+A\+C\+D\+\_\+\+OK, G\+M\+A\+C\+D\+\_\+\+P\+A\+R\+AM on parameter error. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__gmacd__functions_ga1bd3fe40e63537dce59dd4368dce4253}\label{group__gmacd__functions_ga1bd3fe40e63537dce59dd4368dce4253}} 
\index{GMAC Driver Functions@{GMAC Driver Functions}!GMACD\_TxLoad@{GMACD\_TxLoad}}
\index{GMACD\_TxLoad@{GMACD\_TxLoad}!GMAC Driver Functions@{GMAC Driver Functions}}
\subsubsection{\texorpdfstring{GMACD\_TxLoad()}{GMACD\_TxLoad()}}
{\footnotesize\ttfamily uint32\+\_\+t G\+M\+A\+C\+D\+\_\+\+Tx\+Load (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__gmacd__types_gaa8760917079000a5ee7fbc7fab992dd3}{s\+Gmacd}} $\ast$}]{p\+Gmacd,  }\item[{gmac\+Que\+List\+\_\+t}]{que\+Idx }\end{DoxyParamCaption})}

Return current load of TX. 
\begin{DoxyParams}{Parameters}
{\em p\+Gmacd} & Pointer to G\+M\+AC Driver instance. \\
\hline
\end{DoxyParams}
