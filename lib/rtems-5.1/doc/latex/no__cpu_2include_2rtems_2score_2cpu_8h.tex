\hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h}{}\section{cpukit/score/cpu/no\+\_\+cpu/include/rtems/score/cpu.h File Reference}
\label{no__cpu_2include_2rtems_2score_2cpu_8h}\index{cpukit/score/cpu/no\_cpu/include/rtems/score/cpu.h@{cpukit/score/cpu/no\_cpu/include/rtems/score/cpu.h}}


N\+O\+\_\+\+C\+PU Department Source.  


{\ttfamily \#include $<$rtems/score/basedefs.\+h$>$}\newline
{\ttfamily \#include $<$rtems/score/no\+\_\+cpu.\+h$>$}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}}
\begin{DoxyCompactList}\small\item\em Thread register context. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structContext__Control__fp}{Context\+\_\+\+Control\+\_\+fp}}
\begin{DoxyCompactList}\small\item\em S\+P\+A\+RC basic context. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structCPU__Interrupt__frame}{C\+P\+U\+\_\+\+Interrupt\+\_\+frame}}
\begin{DoxyCompactList}\small\item\em Interrupt stack frame (I\+SF). \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structCPU__Exception__frame}{C\+P\+U\+\_\+\+Exception\+\_\+frame}}
\begin{DoxyCompactList}\small\item\em The set of registers that specifies the complete processor state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a1eca01dbb1ef2873349cc4e222509f0a}{C\+P\+U\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+E\+C\+T\+O\+R\+E\+D\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+TS}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a30c4d320f85b1383c5059da5b19b164a}{C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+P\+A\+S\+S\+E\+S\+\_\+\+F\+R\+A\+M\+E\+\_\+\+P\+O\+I\+N\+T\+ER}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}{C\+P\+U\+\_\+\+H\+A\+R\+D\+W\+A\+R\+E\+\_\+\+FP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a304f78c61edce38bb88e909f90a326dc}{C\+P\+U\+\_\+\+S\+O\+F\+T\+W\+A\+R\+E\+\_\+\+FP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a225de03a8647bf307a73cf907969778d}{C\+P\+U\+\_\+\+A\+L\+L\+\_\+\+T\+A\+S\+K\+S\+\_\+\+A\+R\+E\+\_\+\+FP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_af1c906c8ee4c3d012dc456285e42d3ee}{C\+P\+U\+\_\+\+I\+D\+L\+E\+\_\+\+T\+A\+S\+K\+\_\+\+I\+S\+\_\+\+FP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a155bcf88149016c6c58f30eeab9f1598}{C\+P\+U\+\_\+\+U\+S\+E\+\_\+\+D\+E\+F\+E\+R\+R\+E\+D\+\_\+\+F\+P\+\_\+\+S\+W\+I\+T\+CH}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a0c634f4a6bc9236bcacafc9b6119e011}{C\+P\+U\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+R\+O\+B\+U\+S\+T\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+D\+I\+S\+P\+A\+T\+CH}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\begin{DoxyCompactList}\small\item\em Enables a robust thread dispatch if set to T\+R\+UE. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_ac40d98a563f63934a5775f1366ba1b67}{C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+G\+R\+O\+W\+S\+\_\+\+UP}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}}~32
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_acd43704c7821a2c042d212801156584e}{C\+P\+U\+\_\+\+S\+T\+R\+U\+C\+T\+U\+R\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~\mbox{\hyperlink{structRTEMS__ALIGNED}{R\+T\+E\+M\+S\+\_\+\+A\+L\+I\+G\+N\+ED}}( \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}} )
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_af8823e651e33b9683e0d89e5a8054ee6}\label{no__cpu_2include_2rtems_2score_2cpu_8h_af8823e651e33b9683e0d89e5a8054ee6}} 
\#define {\bfseries C\+P\+U\+\_\+\+M\+O\+D\+E\+S\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+M\+A\+SK}~0x00000001
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_adea68a7fa02909edcebee08748f94223}\label{no__cpu_2include_2rtems_2score_2cpu_8h_adea68a7fa02909edcebee08748f94223}} 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_adea68a7fa02909edcebee08748f94223}{C\+P\+U\+\_\+\+M\+A\+X\+I\+M\+U\+M\+\_\+\+P\+R\+O\+C\+E\+S\+S\+O\+RS}}~32
\begin{DoxyCompactList}\small\item\em Maximum number of processors of all systems supported by this C\+PU port. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a896055157b72692a6141f7c0039eabdf}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a896055157b72692a6141f7c0039eabdf}} 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Get\+\_\+\+SP}(\+\_\+context)~(\+\_\+context)-\/$>$stack\+\_\+pointer
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_af58e4ff1f7e1c85fc5c0b80cbd0672c5}\label{no__cpu_2include_2rtems_2score_2cpu_8h_af58e4ff1f7e1c85fc5c0b80cbd0672c5}} 
\#define {\bfseries C\+P\+U\+\_\+\+C\+O\+N\+T\+E\+X\+T\+\_\+\+F\+P\+\_\+\+S\+I\+ZE}~sizeof( \mbox{\hyperlink{structContext__Control__fp}{Context\+\_\+\+Control\+\_\+fp}} )
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_ab94869be93a41da88a10fa59771ce2c9}{C\+P\+U\+\_\+\+M\+P\+C\+I\+\_\+\+R\+E\+C\+E\+I\+V\+E\+\_\+\+S\+E\+R\+V\+E\+R\+\_\+\+E\+X\+T\+R\+A\+\_\+\+S\+T\+A\+CK}}~0
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a937007b12441849696a0462fee2b8d3e}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a937007b12441849696a0462fee2b8d3e}} 
\#define {\bfseries C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+V\+E\+C\+T\+O\+RS}~32
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a3c2363ae6ca6575fc9147b1b7585b3b4}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a3c2363ae6ca6575fc9147b1b7585b3b4}} 
\#define {\bfseries C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+M\+A\+X\+I\+M\+U\+M\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+N\+U\+M\+B\+ER}~(\mbox{\hyperlink{sparc_2include_2rtems_2score_2cpu_8h_a937007b12441849696a0462fee2b8d3e}{C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+N\+U\+M\+B\+E\+R\+\_\+\+O\+F\+\_\+\+V\+E\+C\+T\+O\+RS}} -\/ 1)
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a47f6e4d60c72b5f65fc775b0b5dd14ec}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a47f6e4d60c72b5f65fc775b0b5dd14ec}} 
\#define {\bfseries C\+P\+U\+\_\+\+P\+R\+O\+V\+I\+D\+E\+S\+\_\+\+I\+S\+R\+\_\+\+I\+S\+\_\+\+I\+N\+\_\+\+P\+R\+O\+G\+R\+E\+SS}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a4c92ceea7549cc7b21db2c466916b733}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a4c92ceea7549cc7b21db2c466916b733}} 
\#define {\bfseries C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+M\+I\+N\+I\+M\+U\+M\+\_\+\+S\+I\+ZE}~(1024$\ast$4)
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aea4bd2905092d69bc92fbff6103ced8b}{C\+P\+U\+\_\+\+S\+I\+Z\+E\+O\+F\+\_\+\+P\+O\+I\+N\+T\+ER}}~4
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~8
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}{C\+P\+U\+\_\+\+H\+E\+A\+P\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~\mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a8aed43eb1b3c346772c127482b4b5372}{C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~0
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a6a578627686e1020a28f5a295703ca74}{C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}~\mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}}
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ad1ef5062849284d81496e1e6d33fb7ff}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ad1ef5062849284d81496e1e6d33fb7ff}} 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Initialize\+\_\+vectors}()
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable}(\+\_\+isr\+\_\+cookie)
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable}(\+\_\+isr\+\_\+cookie)
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash}(\+\_\+isr\+\_\+cookie)
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level}(new\+\_\+level)
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Destroy}(\+\_\+the\+\_\+thread,  \+\_\+the\+\_\+context)
\item 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize}(\+\_\+the\+\_\+context,  \+\_\+stack\+\_\+base,  \+\_\+size,  \+\_\+isr,  \+\_\+entry\+\_\+point,  \+\_\+is\+\_\+fp,  \+\_\+tls\+\_\+area)
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a3fb67e174d7b61251322cd32126acd1a}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Restart\+\_\+self}}(\+\_\+the\+\_\+context)~\mbox{\hyperlink{group__RTEMSScoreCPUARM_ga80726ebfe00f31a88b086cc4474c472f}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore}}( (\+\_\+the\+\_\+context) );
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_ac34a28abe9b31559d4096b2c942860a6}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize\+\_\+fp}}(\+\_\+destination)
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a4c07c0150ec7894dd128993e931ceee5}{\+\_\+\+C\+P\+U\+\_\+\+Fatal\+\_\+halt}}(\+\_\+source,  \+\_\+error)
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUExampleBitfield_gab0aff7a561b9c030a4d88eff201f4688}{C\+P\+U\+\_\+\+U\+S\+E\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+B\+I\+T\+F\+I\+E\+L\+D\+\_\+\+C\+O\+DE}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUExampleBitfield_gabbc6ee0d13009243d4088dfde2fe5da9}{\+\_\+\+C\+P\+U\+\_\+\+Bitfield\+\_\+\+Find\+\_\+first\+\_\+bit}}(\+\_\+value,  \+\_\+output)
\item 
\#define \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_ab2b14ff6bbccff7e0a99f55c4c8b8e87}{\+\_\+\+C\+P\+U\+\_\+\+Priority\+\_\+\+Mask}}(\+\_\+bit\+\_\+number)~( 1 $<$$<$ (\+\_\+bit\+\_\+number) )
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a806e09db1107cf84732edffb7c7f96b2}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a806e09db1107cf84732edffb7c7f96b2}} 
\#define {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Priority\+\_\+bits\+\_\+index}(\+\_\+priority)~(\+\_\+priority)
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUExampleCPUEndian_ga1936ecb0107e5875a7b538374c1f621d}{C\+P\+U\+\_\+swap\+\_\+u16}}(value)~(((value\&0xff) $<$$<$ 8) $\vert$ ((value $>$$>$ 8)\&0xff))
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_addfaa82155a005077bfd1d41dc6e8cf5}\label{no__cpu_2include_2rtems_2score_2cpu_8h_addfaa82155a005077bfd1d41dc6e8cf5}} 
typedef void($\ast$ {\bfseries C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler}) (void)
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a6d0204fc99c704f9f7c1e7b4e8b3657a}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a6d0204fc99c704f9f7c1e7b4e8b3657a}} 
typedef void($\ast$ {\bfseries C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler}) (uint32\+\_\+t)
\item 
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}} 
typedef uint32\+\_\+t \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}{C\+P\+U\+\_\+\+Counter\+\_\+ticks}}
\begin{DoxyCompactList}\small\item\em Unsigned integer type for C\+PU counter values. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} bool \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga5254669b54a06e96ebb585fd50a02c4d}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Is\+\_\+enabled}} (uint32\+\_\+t level)
\begin{DoxyCompactList}\small\item\em Returns true if interrupts are enabled in the specified I\+SR level, otherwise returns false. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga1d9dcab9170d532b6634a5620385adbd}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level}} (void)
\begin{DoxyCompactList}\small\item\em Returns the interrupt level of the executing thread. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga869484e3d851b032fd826c69ff21fc72}{\+\_\+\+C\+P\+U\+\_\+\+Initialize}} (void)
\begin{DoxyCompactList}\small\item\em C\+PU initialization. \end{DoxyCompactList}\item 
void {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+raw\+\_\+handler} (uint32\+\_\+t vector, C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler new\+\_\+handler, C\+P\+U\+\_\+\+I\+S\+R\+\_\+raw\+\_\+handler $\ast$old\+\_\+handler)
\item 
void {\bfseries \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+install\+\_\+vector} (uint32\+\_\+t vector, C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler new\+\_\+handler, C\+P\+U\+\_\+\+I\+S\+R\+\_\+handler $\ast$old\+\_\+handler)
\item 
void $\ast$ \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga903a802003c95d6ef5206cb330424a1b}{\+\_\+\+C\+P\+U\+\_\+\+Thread\+\_\+\+Idle\+\_\+body}} (uintptr\+\_\+t ignored)
\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa9f8cc989454b28232e5375e30c90970}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+switch}} (\mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}} $\ast$run, \mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}} $\ast$heir)
\begin{DoxyCompactList}\small\item\em C\+PU switch context. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga80726ebfe00f31a88b086cc4474c472f}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore}} (\mbox{\hyperlink{structContext__Control}{Context\+\_\+\+Control}} $\ast$new\+\_\+context) \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa2f0ed67aa174f684bb31b7e8bdb386f}{R\+T\+E\+M\+S\+\_\+\+N\+O\+\_\+\+R\+E\+T\+U\+RN}}
\item 
void {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+save\+\_\+fp} (\mbox{\hyperlink{structContext__Control__fp}{Context\+\_\+\+Control\+\_\+fp}} $\ast$$\ast$fp\+\_\+context\+\_\+ptr)
\item 
void {\bfseries \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore\+\_\+fp} (\mbox{\hyperlink{structContext__Control__fp}{Context\+\_\+\+Control\+\_\+fp}} $\ast$$\ast$fp\+\_\+context\+\_\+ptr)
\item 
void \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa34a35de496258577c1454ba1ee07ce0}{\+\_\+\+C\+P\+U\+\_\+\+Exception\+\_\+frame\+\_\+print}} (const \mbox{\hyperlink{structCPU__Exception__frame}{C\+P\+U\+\_\+\+Exception\+\_\+frame}} $\ast$frame)
\begin{DoxyCompactList}\small\item\em Prints the exception frame via \mbox{\hyperlink{bspIo_8h_a380cfecc8035cec8a13b68c0cb90f32f}{printk()}}. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa675150e5d00169c99410a82011b6117}{\+\_\+\+C\+P\+U\+\_\+\+Counter\+\_\+frequency}} (void)
\begin{DoxyCompactList}\small\item\em Returns the current C\+PU counter frequency in Hz. \end{DoxyCompactList}\item 
\mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_a67f8550aad58bccb6fcb4589894444ad}{C\+P\+U\+\_\+\+Counter\+\_\+ticks}} \mbox{\hyperlink{group__RTEMSScoreCPUARM_gac016ae4ed92ed2607bd65408a36d908b}{\+\_\+\+C\+P\+U\+\_\+\+Counter\+\_\+read}} (void)
\begin{DoxyCompactList}\small\item\em Returns the current C\+PU counter value. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structContext__Control__fp}{Context\+\_\+\+Control\+\_\+fp}} \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_af07fa780651217bccbbd992ae527164c}{\+\_\+\+C\+P\+U\+\_\+\+Null\+\_\+fp\+\_\+context}}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
N\+O\+\_\+\+C\+PU Department Source. 

This include file contains information pertaining to the N\+O\+\_\+\+C\+PU processor. 

\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a0055a036f93e45d2e282eb108046c687}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a0055a036f93e45d2e282eb108046c687}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Destroy@{\_CPU\_Context\_Destroy}}
\index{\_CPU\_Context\_Destroy@{\_CPU\_Context\_Destroy}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Destroy}{\_CPU\_Context\_Destroy}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Destroy(\begin{DoxyParamCaption}\item[{}]{\+\_\+the\+\_\+thread,  }\item[{}]{\+\_\+the\+\_\+context }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a0eb108f0a842cd0659e42289f5757bb3}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a0eb108f0a842cd0659e42289f5757bb3}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Initialize@{\_CPU\_Context\_Initialize}}
\index{\_CPU\_Context\_Initialize@{\_CPU\_Context\_Initialize}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Initialize}{\_CPU\_Context\_Initialize}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize(\begin{DoxyParamCaption}\item[{}]{\+\_\+the\+\_\+context,  }\item[{}]{\+\_\+stack\+\_\+base,  }\item[{}]{\+\_\+size,  }\item[{}]{\+\_\+isr,  }\item[{}]{\+\_\+entry\+\_\+point,  }\item[{}]{\+\_\+is\+\_\+fp,  }\item[{}]{\+\_\+tls\+\_\+area }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ac34a28abe9b31559d4096b2c942860a6}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ac34a28abe9b31559d4096b2c942860a6}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Initialize\_fp@{\_CPU\_Context\_Initialize\_fp}}
\index{\_CPU\_Context\_Initialize\_fp@{\_CPU\_Context\_Initialize\_fp}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Initialize\_fp}{\_CPU\_Context\_Initialize\_fp}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize\+\_\+fp(\begin{DoxyParamCaption}\item[{}]{\+\_\+destination }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{   *(*(\_destination)) = \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_af07fa780651217bccbbd992ae527164c}{\_CPU\_Null\_fp\_context}}; \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
This routine initializes the FP context area passed to it to. There are a few standard ways in which to initialize the floating point context. The code included for this macro assumes that this is a C\+PU in which a \char`\"{}initial\char`\"{} FP context was saved into {\itshape \+\_\+\+C\+P\+U\+\_\+\+Null\+\_\+fp\+\_\+context} and it simply copies it to the destination context passed to it.

Other floating point context save/restore models include\+:
\begin{DoxyEnumerate}
\item not doing anything, and
\item putting a \char`\"{}null F\+P status word\char`\"{} in the correct place in the FP context.
\end{DoxyEnumerate}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \+\_\+destination} & is the floating point context area\\
\hline
\end{DoxyParams}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a3fb67e174d7b61251322cd32126acd1a}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a3fb67e174d7b61251322cd32126acd1a}} 
\index{cpu.h@{cpu.h}!\_CPU\_Context\_Restart\_self@{\_CPU\_Context\_Restart\_self}}
\index{\_CPU\_Context\_Restart\_self@{\_CPU\_Context\_Restart\_self}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Context\_Restart\_self}{\_CPU\_Context\_Restart\_self}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Restart\+\_\+self(\begin{DoxyParamCaption}\item[{}]{\+\_\+the\+\_\+context }\end{DoxyParamCaption})~\mbox{\hyperlink{group__RTEMSScoreCPUARM_ga80726ebfe00f31a88b086cc4474c472f}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+restore}}( (\+\_\+the\+\_\+context) );}

This routine is responsible for somehow restarting the currently executing task. If you are lucky, then all that is necessary is restoring the context. Otherwise, there will need to be a special assembly routine which does something special in this case. For many ports, simply adding a label to the restore path of \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa9f8cc989454b28232e5375e30c90970}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+switch}} will work. On other ports, it may be possibly to load a few arguments and jump to the restore path. It will not work if restarting self conflicts with the stack frame assumptions of restoring a context.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a4c07c0150ec7894dd128993e931ceee5}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a4c07c0150ec7894dd128993e931ceee5}} 
\index{cpu.h@{cpu.h}!\_CPU\_Fatal\_halt@{\_CPU\_Fatal\_halt}}
\index{\_CPU\_Fatal\_halt@{\_CPU\_Fatal\_halt}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Fatal\_halt}{\_CPU\_Fatal\_halt}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Fatal\+\_\+halt(\begin{DoxyParamCaption}\item[{}]{\+\_\+source,  }\item[{}]{\+\_\+error }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
This routine copies \+\_\+error into a known place -- typically a stack location or a register, optionally disables interrupts, and halts/stops the C\+PU.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_aca3fde6f372ee51fdd893c260e7d7146}\label{no__cpu_2include_2rtems_2score_2cpu_8h_aca3fde6f372ee51fdd893c260e7d7146}} 
\index{cpu.h@{cpu.h}!\_CPU\_ISR\_Disable@{\_CPU\_ISR\_Disable}}
\index{\_CPU\_ISR\_Disable@{\_CPU\_ISR\_Disable}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Disable}{\_CPU\_ISR\_Disable}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{    (\_isr\_cookie) = 0;   \textcolor{comment}{/* do something to prevent warnings */} \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ae3b1e2cd1ea4020d229e759569459664}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ae3b1e2cd1ea4020d229e759569459664}} 
\index{cpu.h@{cpu.h}!\_CPU\_ISR\_Enable@{\_CPU\_ISR\_Enable}}
\index{\_CPU\_ISR\_Enable@{\_CPU\_ISR\_Enable}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Enable}{\_CPU\_ISR\_Enable}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ac7e58e16c6b558daf31fe8f9dbec5a69}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ac7e58e16c6b558daf31fe8f9dbec5a69}} 
\index{cpu.h@{cpu.h}!\_CPU\_ISR\_Flash@{\_CPU\_ISR\_Flash}}
\index{\_CPU\_ISR\_Flash@{\_CPU\_ISR\_Flash}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Flash}{\_CPU\_ISR\_Flash}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_aed8717a2f15938d954c7124cd11e899f}\label{no__cpu_2include_2rtems_2score_2cpu_8h_aed8717a2f15938d954c7124cd11e899f}} 
\index{cpu.h@{cpu.h}!\_CPU\_ISR\_Set\_level@{\_CPU\_ISR\_Set\_level}}
\index{\_CPU\_ISR\_Set\_level@{\_CPU\_ISR\_Set\_level}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Set\_level}{\_CPU\_ISR\_Set\_level}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level(\begin{DoxyParamCaption}\item[{}]{new\+\_\+level }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{ \(\backslash\)}
\DoxyCodeLine{  \}}

\end{DoxyCode}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ab2b14ff6bbccff7e0a99f55c4c8b8e87}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ab2b14ff6bbccff7e0a99f55c4c8b8e87}} 
\index{cpu.h@{cpu.h}!\_CPU\_Priority\_Mask@{\_CPU\_Priority\_Mask}}
\index{\_CPU\_Priority\_Mask@{\_CPU\_Priority\_Mask}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Priority\_Mask}{\_CPU\_Priority\_Mask}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+Priority\+\_\+\+Mask(\begin{DoxyParamCaption}\item[{}]{\+\_\+bit\+\_\+number }\end{DoxyParamCaption})~( 1 $<$$<$ (\+\_\+bit\+\_\+number) )}

This routine builds the mask which corresponds to the bit fields as searched by \mbox{\hyperlink{group__RTEMSScoreCPUExampleBitfield_gabbc6ee0d13009243d4088dfde2fe5da9}{\+\_\+\+C\+P\+U\+\_\+\+Bitfield\+\_\+\+Find\+\_\+first\+\_\+bit}}. See the discussion for that routine.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}} 
\index{cpu.h@{cpu.h}!CPU\_ALIGNMENT@{CPU\_ALIGNMENT}}
\index{CPU\_ALIGNMENT@{CPU\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ALIGNMENT}{CPU\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~8}

C\+PU\textquotesingle{}s worst alignment requirement for data types on a byte boundary. This alignment does not take into account the requirements for the stack. It must be a power of two greater than or equal to two. The power of two requirement makes it possible to align values easily using simple bit operations.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a225de03a8647bf307a73cf907969778d}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a225de03a8647bf307a73cf907969778d}} 
\index{cpu.h@{cpu.h}!CPU\_ALL\_TASKS\_ARE\_FP@{CPU\_ALL\_TASKS\_ARE\_FP}}
\index{CPU\_ALL\_TASKS\_ARE\_FP@{CPU\_ALL\_TASKS\_ARE\_FP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ALL\_TASKS\_ARE\_FP}{CPU\_ALL\_TASKS\_ARE\_FP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+A\+L\+L\+\_\+\+T\+A\+S\+K\+S\+\_\+\+A\+R\+E\+\_\+\+FP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Are all tasks R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT tasks implicitly?

If T\+R\+UE, then the R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task attribute is assumed. If F\+A\+L\+SE, then the R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task attribute is followed.

So far, the only C\+P\+Us in which this option has been used are the HP P\+A-\/\+R\+I\+SC and Power\+PC. On the P\+A-\/\+R\+I\+SC, The HP C compiler and gcc both implicitly used the floating point registers to perform integer multiplies. Similarly, the Power\+PC port of gcc has been seen to allocate floating point local variables and touch the F\+PU even when the flow through a subroutine (like vfprintf()) might not use floating point formats.

If a function which you would not think utilize the FP unit D\+O\+ES, then one can not easily predict which tasks will use the FP hardware. In this case, this option should be T\+R\+UE.

If \mbox{\hyperlink{sparc_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}{C\+P\+U\+\_\+\+H\+A\+R\+D\+W\+A\+R\+E\+\_\+\+FP}} is F\+A\+L\+SE, then this should be F\+A\+L\+SE as well.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}\label{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}} 
\index{cpu.h@{cpu.h}!CPU\_CACHE\_LINE\_BYTES@{CPU\_CACHE\_LINE\_BYTES}}
\index{CPU\_CACHE\_LINE\_BYTES@{CPU\_CACHE\_LINE\_BYTES}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_CACHE\_LINE\_BYTES}{CPU\_CACHE\_LINE\_BYTES}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES~32}

The maximum cache line size in bytes.

The actual processor may use no cache or a smaller cache line size. \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a0c634f4a6bc9236bcacafc9b6119e011}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a0c634f4a6bc9236bcacafc9b6119e011}} 
\index{cpu.h@{cpu.h}!CPU\_ENABLE\_ROBUST\_THREAD\_DISPATCH@{CPU\_ENABLE\_ROBUST\_THREAD\_DISPATCH}}
\index{CPU\_ENABLE\_ROBUST\_THREAD\_DISPATCH@{CPU\_ENABLE\_ROBUST\_THREAD\_DISPATCH}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ENABLE\_ROBUST\_THREAD\_DISPATCH}{CPU\_ENABLE\_ROBUST\_THREAD\_DISPATCH}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+R\+O\+B\+U\+S\+T\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+D\+I\+S\+P\+A\+T\+CH~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}



Enables a robust thread dispatch if set to T\+R\+UE. 

In general, it is an application bug to call blocking operating system services with interrupts disabled. In most situations this only increases the interrupt latency. However, on S\+MP configurations or on some C\+PU port like A\+RM Cortex-\/M it leads to undefined system behaviour. It order to ease the application development, this error condition is checked at run-\/time in case this C\+PU port option is defined to T\+R\+UE. \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a112f88f13afe8bb8f1b13f1ca7e09b8d}} 
\index{cpu.h@{cpu.h}!CPU\_HARDWARE\_FP@{CPU\_HARDWARE\_FP}}
\index{CPU\_HARDWARE\_FP@{CPU\_HARDWARE\_FP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_HARDWARE\_FP}{CPU\_HARDWARE\_FP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+H\+A\+R\+D\+W\+A\+R\+E\+\_\+\+FP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Does the C\+PU have hardware floating point?

If T\+R\+UE, then the R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task attribute is supported. If F\+A\+L\+SE, then the R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task attribute is ignored.

If there is a FP coprocessor such as the i387 or mc68881, then the answer is T\+R\+UE.

The macro name \char`\"{}\+N\+O\+\_\+\+C\+P\+U\+\_\+\+H\+A\+S\+\_\+\+F\+P\+U\char`\"{} should be made C\+PU specific. It indicates whether or not this C\+PU model has FP support. For example, it would be possible to have an i386\+\_\+nofp C\+PU model which set this to false to indicate that you have an i386 without an i387 and wish to leave floating point support out of R\+T\+E\+MS. \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}} 
\index{cpu.h@{cpu.h}!CPU\_HEAP\_ALIGNMENT@{CPU\_HEAP\_ALIGNMENT}}
\index{CPU\_HEAP\_ALIGNMENT@{CPU\_HEAP\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_HEAP\_ALIGNMENT}{CPU\_HEAP\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+H\+E\+A\+P\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~\mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}}

This number corresponds to the byte alignment requirement for the heap handler. This alignment requirement may be stricter than that for the data types alignment specified by \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}. It is common for the heap to follow the same alignment requirement as \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}. If the \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} is strict enough for the heap, then this should be set to \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}.

N\+O\+TE\+: It must be a power of two greater than or equal to two. The requirement to be a multiple of two is because the heap uses the least significant field of the front and back flags to indicate that a block is in use or free. So you do not want any odd length blocks really putting length data in that bit.

On byte oriented architectures, \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ac71c1e0159c32144a04f18646ede252b}{C\+P\+U\+\_\+\+H\+E\+A\+P\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} normally will have to be greater or equal to than \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} to ensure that elements allocated from the heap meet all restrictions.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_af1c906c8ee4c3d012dc456285e42d3ee}\label{no__cpu_2include_2rtems_2score_2cpu_8h_af1c906c8ee4c3d012dc456285e42d3ee}} 
\index{cpu.h@{cpu.h}!CPU\_IDLE\_TASK\_IS\_FP@{CPU\_IDLE\_TASK\_IS\_FP}}
\index{CPU\_IDLE\_TASK\_IS\_FP@{CPU\_IDLE\_TASK\_IS\_FP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_IDLE\_TASK\_IS\_FP}{CPU\_IDLE\_TASK\_IS\_FP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+I\+D\+L\+E\+\_\+\+T\+A\+S\+K\+\_\+\+I\+S\+\_\+\+FP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Should the I\+D\+LE task have a floating point context?

If T\+R\+UE, then the I\+D\+LE task is created as a R\+T\+E\+M\+S\+\_\+\+F\+L\+O\+A\+T\+I\+N\+G\+\_\+\+P\+O\+I\+NT task and it has a floating point context which is switched in and out. If F\+A\+L\+SE, then the I\+D\+LE task does not have a floating point context.

Setting this to T\+R\+UE negatively impacts the time required to preempt the I\+D\+LE task from an interrupt because the floating point context must be saved as part of the preemption.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a6a578627686e1020a28f5a295703ca74}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a6a578627686e1020a28f5a295703ca74}} 
\index{cpu.h@{cpu.h}!CPU\_INTERRUPT\_STACK\_ALIGNMENT@{CPU\_INTERRUPT\_STACK\_ALIGNMENT}}
\index{CPU\_INTERRUPT\_STACK\_ALIGNMENT@{CPU\_INTERRUPT\_STACK\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_INTERRUPT\_STACK\_ALIGNMENT}{CPU\_INTERRUPT\_STACK\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~\mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}}}

The alignment of the interrupt stack in bytes.

The alignment should take the stack A\+BI and the cache line size into account. \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a30c4d320f85b1383c5059da5b19b164a}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a30c4d320f85b1383c5059da5b19b164a}} 
\index{cpu.h@{cpu.h}!CPU\_ISR\_PASSES\_FRAME\_POINTER@{CPU\_ISR\_PASSES\_FRAME\_POINTER}}
\index{CPU\_ISR\_PASSES\_FRAME\_POINTER@{CPU\_ISR\_PASSES\_FRAME\_POINTER}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_ISR\_PASSES\_FRAME\_POINTER}{CPU\_ISR\_PASSES\_FRAME\_POINTER}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+P\+A\+S\+S\+E\+S\+\_\+\+F\+R\+A\+M\+E\+\_\+\+P\+O\+I\+N\+T\+ER~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Does the R\+T\+E\+MS invoke the user\textquotesingle{}s I\+SR with the vector number and a pointer to the saved interrupt frame (1) or just the vector number (0)?

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ab94869be93a41da88a10fa59771ce2c9}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ab94869be93a41da88a10fa59771ce2c9}} 
\index{cpu.h@{cpu.h}!CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK@{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}}
\index{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK@{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+M\+P\+C\+I\+\_\+\+R\+E\+C\+E\+I\+V\+E\+\_\+\+S\+E\+R\+V\+E\+R\+\_\+\+E\+X\+T\+R\+A\+\_\+\+S\+T\+A\+CK~0}

Amount of extra stack (above minimum stack size) required by M\+P\+CI receive server thread. Remember that in a multiprocessor system this thread must exist and be able to process all directives.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a1eca01dbb1ef2873349cc4e222509f0a}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a1eca01dbb1ef2873349cc4e222509f0a}} 
\index{cpu.h@{cpu.h}!CPU\_SIMPLE\_VECTORED\_INTERRUPTS@{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}}
\index{CPU\_SIMPLE\_VECTORED\_INTERRUPTS@{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}{CPU\_SIMPLE\_VECTORED\_INTERRUPTS}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+E\+C\+T\+O\+R\+E\+D\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+TS~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Does the C\+PU follow the simple vectored interrupt model?

If T\+R\+UE, then R\+T\+E\+MS allocates the vector table it internally manages. If F\+A\+L\+SE, then the B\+SP is assumed to allocate and manage the vector table

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_aea4bd2905092d69bc92fbff6103ced8b}\label{no__cpu_2include_2rtems_2score_2cpu_8h_aea4bd2905092d69bc92fbff6103ced8b}} 
\index{cpu.h@{cpu.h}!CPU\_SIZEOF\_POINTER@{CPU\_SIZEOF\_POINTER}}
\index{CPU\_SIZEOF\_POINTER@{CPU\_SIZEOF\_POINTER}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_SIZEOF\_POINTER}{CPU\_SIZEOF\_POINTER}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+I\+Z\+E\+O\+F\+\_\+\+P\+O\+I\+N\+T\+ER~4}

Size of a pointer.

This must be an integer literal that can be used by the assembler. This value will be used to calculate offsets of structure members. These offsets will be used in assembler code. \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a304f78c61edce38bb88e909f90a326dc}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a304f78c61edce38bb88e909f90a326dc}} 
\index{cpu.h@{cpu.h}!CPU\_SOFTWARE\_FP@{CPU\_SOFTWARE\_FP}}
\index{CPU\_SOFTWARE\_FP@{CPU\_SOFTWARE\_FP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_SOFTWARE\_FP}{CPU\_SOFTWARE\_FP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+O\+F\+T\+W\+A\+R\+E\+\_\+\+FP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

Does the C\+PU have no hardware floating point and G\+CC provides a software floating point implementation which must be context switched?

This feature conditional is used to indicate whether or not there is software implemented floating point that must be context switched. The determination of whether or not this applies is very tool specific and the state saved/restored is also compiler specific.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a8aed43eb1b3c346772c127482b4b5372}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a8aed43eb1b3c346772c127482b4b5372}} 
\index{cpu.h@{cpu.h}!CPU\_STACK\_ALIGNMENT@{CPU\_STACK\_ALIGNMENT}}
\index{CPU\_STACK\_ALIGNMENT@{CPU\_STACK\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_STACK\_ALIGNMENT}{CPU\_STACK\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~0}

This number corresponds to the byte alignment requirement for the stack. This alignment requirement may be stricter than that for the data types alignment specified by \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}. If the \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}} is strict enough for the stack, then this should be set to 0.

N\+O\+TE\+: This must be a power of 2 either 0 or greater than \mbox{\hyperlink{v850_2include_2rtems_2score_2cpu_8h_ae526a309e32001688261048b19cdb7d8}{C\+P\+U\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_ac40d98a563f63934a5775f1366ba1b67}\label{no__cpu_2include_2rtems_2score_2cpu_8h_ac40d98a563f63934a5775f1366ba1b67}} 
\index{cpu.h@{cpu.h}!CPU\_STACK\_GROWS\_UP@{CPU\_STACK\_GROWS\_UP}}
\index{CPU\_STACK\_GROWS\_UP@{CPU\_STACK\_GROWS\_UP}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_STACK\_GROWS\_UP}{CPU\_STACK\_GROWS\_UP}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+T\+A\+C\+K\+\_\+\+G\+R\+O\+W\+S\+\_\+\+UP~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Does the stack grow up (toward higher addresses) or down (toward lower addresses)?

If T\+R\+UE, then the grows upward. If F\+A\+L\+SE, then the grows toward smaller addresses.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_acd43704c7821a2c042d212801156584e}\label{no__cpu_2include_2rtems_2score_2cpu_8h_acd43704c7821a2c042d212801156584e}} 
\index{cpu.h@{cpu.h}!CPU\_STRUCTURE\_ALIGNMENT@{CPU\_STRUCTURE\_ALIGNMENT}}
\index{CPU\_STRUCTURE\_ALIGNMENT@{CPU\_STRUCTURE\_ALIGNMENT}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_STRUCTURE\_ALIGNMENT}{CPU\_STRUCTURE\_ALIGNMENT}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+S\+T\+R\+U\+C\+T\+U\+R\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT~\mbox{\hyperlink{structRTEMS__ALIGNED}{R\+T\+E\+M\+S\+\_\+\+A\+L\+I\+G\+N\+ED}}( \mbox{\hyperlink{no__cpu_2include_2rtems_2score_2cpu_8h_aafa1399e268a9ae6adf6d6aad4371688}{C\+P\+U\+\_\+\+C\+A\+C\+H\+E\+\_\+\+L\+I\+N\+E\+\_\+\+B\+Y\+T\+ES}} )}

The following is the variable attribute used to force alignment of critical R\+T\+E\+MS structures. On some processors it may make sense to have these aligned on tighter boundaries than the minimum requirements of the compiler in order to have as much of the critical data area as possible in a cache line.

Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_a155bcf88149016c6c58f30eeab9f1598}\label{no__cpu_2include_2rtems_2score_2cpu_8h_a155bcf88149016c6c58f30eeab9f1598}} 
\index{cpu.h@{cpu.h}!CPU\_USE\_DEFERRED\_FP\_SWITCH@{CPU\_USE\_DEFERRED\_FP\_SWITCH}}
\index{CPU\_USE\_DEFERRED\_FP\_SWITCH@{CPU\_USE\_DEFERRED\_FP\_SWITCH}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{CPU\_USE\_DEFERRED\_FP\_SWITCH}{CPU\_USE\_DEFERRED\_FP\_SWITCH}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+U\+S\+E\+\_\+\+D\+E\+F\+E\+R\+R\+E\+D\+\_\+\+F\+P\+\_\+\+S\+W\+I\+T\+CH~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa8cecfc5c5c054d2875c03e77b7be15d}{T\+R\+UE}}}

Should the saving of the floating point registers be deferred until a context switch is made to another different floating point task?

If T\+R\+UE, then the floating point context will not be stored until necessary. It will remain in the floating point registers and not disturned until another floating point task is switched to.

If F\+A\+L\+SE, then the floating point context is saved when a floating point task is switched out and restored when the next floating point task is restored. The state of the floating point registers between those two operations is not specified.

If the floating point context does N\+OT have to be saved as part of interrupt dispatching, then it should be safe to set this to T\+R\+UE.

Setting this flag to T\+R\+UE results in using a different algorithm for deciding when to save and restore the floating point context. The deferred FP switch algorithm minimizes the number of times the FP context is saved and restored. The FP context is not saved until a context switch is made to another, different FP task. Thus in a system with only one FP task, the FP context will never be saved or restored.

Port Specific Information\+:

X\+XX document implementation including references if appropriate 

\subsection{Variable Documentation}
\mbox{\Hypertarget{no__cpu_2include_2rtems_2score_2cpu_8h_af07fa780651217bccbbd992ae527164c}\label{no__cpu_2include_2rtems_2score_2cpu_8h_af07fa780651217bccbbd992ae527164c}} 
\index{cpu.h@{cpu.h}!\_CPU\_Null\_fp\_context@{\_CPU\_Null\_fp\_context}}
\index{\_CPU\_Null\_fp\_context@{\_CPU\_Null\_fp\_context}!cpu.h@{cpu.h}}
\subsubsection{\texorpdfstring{\_CPU\_Null\_fp\_context}{\_CPU\_Null\_fp\_context}}
{\footnotesize\ttfamily \mbox{\hyperlink{structContext__Control__fp}{Context\+\_\+\+Control\+\_\+fp}} \+\_\+\+C\+P\+U\+\_\+\+Null\+\_\+fp\+\_\+context}

This variable is optional. It is used on C\+P\+Us on which it is difficult to generate an \char`\"{}uninitialized\char`\"{} FP context. It is filled in by \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga869484e3d851b032fd826c69ff21fc72}{\+\_\+\+C\+P\+U\+\_\+\+Initialize}} and copied into the task\textquotesingle{}s FP context area during \mbox{\hyperlink{group__RTEMSScoreCPUARM_gaa92701994ad8e3b646667a3e92935ddf}{\+\_\+\+C\+P\+U\+\_\+\+Context\+\_\+\+Initialize}}.

Port Specific Information\+:

X\+XX document implementation including references if appropriate 