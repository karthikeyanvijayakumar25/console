\hypertarget{group__RTEMSScoreCPUV850CPUInterrupt}{}\section{Processor Dependent Interrupt Management}
\label{group__RTEMSScoreCPUV850CPUInterrupt}\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_gab94869be93a41da88a10fa59771ce2c9}{C\+P\+U\+\_\+\+M\+P\+C\+I\+\_\+\+R\+E\+C\+E\+I\+V\+E\+\_\+\+S\+E\+R\+V\+E\+R\+\_\+\+E\+X\+T\+R\+A\+\_\+\+S\+T\+A\+CK}}~0
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_ga47f6e4d60c72b5f65fc775b0b5dd14ec}{C\+P\+U\+\_\+\+P\+R\+O\+V\+I\+D\+E\+S\+\_\+\+I\+S\+R\+\_\+\+I\+S\+\_\+\+I\+N\+\_\+\+P\+R\+O\+G\+R\+E\+SS}}~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_gaca3fde6f372ee51fdd893c260e7d7146}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable}}(\+\_\+isr\+\_\+cookie)
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_gae3b1e2cd1ea4020d229e759569459664}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable}}(\+\_\+isr\+\_\+cookie)
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash}}(\+\_\+isr\+\_\+cookie)
\item 
\#define \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_gaed8717a2f15938d954c7124cd11e899f}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level}}(new\+\_\+level)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} bool \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_ga5254669b54a06e96ebb585fd50a02c4d}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Is\+\_\+enabled}} (uint32\+\_\+t level)
\begin{DoxyCompactList}\small\item\em Returns true if interrupts are enabled in the specified I\+SR level, otherwise returns false. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{group__RTEMSScoreCPUV850CPUInterrupt_ga1d9dcab9170d532b6634a5620385adbd}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level}} (void)
\begin{DoxyCompactList}\small\item\em Returns the interrupt level of the executing thread. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The following defines the number of bits actually used in the interrupt field of the task mode. How those bits map to the C\+PU interrupt levels is defined by the routine \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga43820ba3d51d7a699c22fce8cac93ef1}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level}}.

Port Specific Information\+:

The v850 only has a single bit in the C\+PU for interrupt disable/enable. 

\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_gaca3fde6f372ee51fdd893c260e7d7146}\label{group__RTEMSScoreCPUV850CPUInterrupt_gaca3fde6f372ee51fdd893c260e7d7146}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Disable@{\_CPU\_ISR\_Disable}}
\index{\_CPU\_ISR\_Disable@{\_CPU\_ISR\_Disable}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Disable}{\_CPU\_ISR\_Disable}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{do} \{ \(\backslash\)}
\DoxyCodeLine{    unsigned \textcolor{keywordtype}{int} \_psw; \(\backslash\)}
\DoxyCodeLine{    \(\backslash\)}
\DoxyCodeLine{    v850\_get\_psw( \_psw ); \(\backslash\)}
\DoxyCodeLine{    \_\_asm\_\_ \_\_volatile\_\_( \textcolor{stringliteral}{"di"} ); \(\backslash\)}
\DoxyCodeLine{    \_isr\_cookie = \_psw; \(\backslash\)}
\DoxyCodeLine{  \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}
Disable all interrupts for an R\+T\+E\+MS critical section. The previous level is returned in {\itshape \+\_\+isr\+\_\+cookie}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em \+\_\+isr\+\_\+cookie} & will contain the previous level cookie\\
\hline
\end{DoxyParams}
Port Specific Information\+:

On the v850, we need to save the P\+SW and use \char`\"{}di\char`\"{} to disable interrupts. \mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_gae3b1e2cd1ea4020d229e759569459664}\label{group__RTEMSScoreCPUV850CPUInterrupt_gae3b1e2cd1ea4020d229e759569459664}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Enable@{\_CPU\_ISR\_Enable}}
\index{\_CPU\_ISR\_Enable@{\_CPU\_ISR\_Enable}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Enable}{\_CPU\_ISR\_Enable}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Enable(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{do} \{ \(\backslash\)}
\DoxyCodeLine{    unsigned \textcolor{keywordtype}{int} \_psw = (\_isr\_cookie); \(\backslash\)}
\DoxyCodeLine{    \(\backslash\)}
\DoxyCodeLine{    v850\_set\_psw( \_psw ); \(\backslash\)}
\DoxyCodeLine{  \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}
Enable interrupts to the previous level (returned by \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Disable). This indicates the end of an R\+T\+E\+MS critical section. The parameter {\itshape \+\_\+isr\+\_\+cookie} is not modified.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \+\_\+isr\+\_\+cookie} & contain the previous level cookie\\
\hline
\end{DoxyParams}
Port Specific Information\+:

On the v850, we simply need to restore the P\+SW. \mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}\label{group__RTEMSScoreCPUV850CPUInterrupt_gac7e58e16c6b558daf31fe8f9dbec5a69}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Flash@{\_CPU\_ISR\_Flash}}
\index{\_CPU\_ISR\_Flash@{\_CPU\_ISR\_Flash}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Flash}{\_CPU\_ISR\_Flash}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Flash(\begin{DoxyParamCaption}\item[{}]{\+\_\+isr\+\_\+cookie }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{do} \{ \(\backslash\)}
\DoxyCodeLine{    unsigned \textcolor{keywordtype}{int} \_psw = (\_isr\_cookie); \(\backslash\)}
\DoxyCodeLine{    v850\_set\_psw( \_psw ); \(\backslash\)}
\DoxyCodeLine{    \_\_asm\_\_ \_\_volatile\_\_( \textcolor{stringliteral}{"di"} ); \(\backslash\)}
\DoxyCodeLine{  \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}
This temporarily restores the interrupt to {\itshape \+\_\+isr\+\_\+cookie} before immediately disabling them again. This is used to divide long R\+T\+E\+MS critical sections into two or more parts. The parameter {\itshape \+\_\+isr\+\_\+cookie} is not modified.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \+\_\+isr\+\_\+cookie} & contain the previous level cookie\\
\hline
\end{DoxyParams}
Port Specific Information\+:

This saves at least one instruction over using enable/disable back to back. \mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_gaed8717a2f15938d954c7124cd11e899f}\label{group__RTEMSScoreCPUV850CPUInterrupt_gaed8717a2f15938d954c7124cd11e899f}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Set\_level@{\_CPU\_ISR\_Set\_level}}
\index{\_CPU\_ISR\_Set\_level@{\_CPU\_ISR\_Set\_level}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Set\_level}{\_CPU\_ISR\_Set\_level}}
{\footnotesize\ttfamily \#define \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Set\+\_\+level(\begin{DoxyParamCaption}\item[{}]{new\+\_\+level }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{do} \{ \(\backslash\)}
\DoxyCodeLine{    if ( new\_level ) \(\backslash\)}
\DoxyCodeLine{      \_\_asm\_\_ \_\_volatile\_\_( \textcolor{stringliteral}{"di"} ); \(\backslash\)}
\DoxyCodeLine{    else \(\backslash\)}
\DoxyCodeLine{      \_\_asm\_\_ \_\_volatile\_\_( \textcolor{stringliteral}{"ei"} ); \(\backslash\)}
\DoxyCodeLine{  \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}
This routine and \mbox{\hyperlink{group__RTEMSScoreCPUARM_ga1d9dcab9170d532b6634a5620385adbd}{\+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level}} Map the interrupt level in task mode onto the hardware that the C\+PU actually provides. Currently, interrupt levels which do not map onto the C\+PU in a generic fashion are undefined. Someday, it would be nice if these were \char`\"{}mapped\char`\"{} by the application via a callout. For example, m68k has 8 levels 0 -\/ 7, levels 8 -\/ 255 would be available for bsp/application specific meaning. This could be used to manage a programmable interrupt controller via the rtems\+\_\+task\+\_\+mode directive.

Port Specific Information\+:

On the v850, level 0 is enabled. Non-\/zero is disabled. \mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_gab94869be93a41da88a10fa59771ce2c9}\label{group__RTEMSScoreCPUV850CPUInterrupt_gab94869be93a41da88a10fa59771ce2c9}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK@{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}}
\index{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK@{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}{CPU\_MPCI\_RECEIVE\_SERVER\_EXTRA\_STACK}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+M\+P\+C\+I\+\_\+\+R\+E\+C\+E\+I\+V\+E\+\_\+\+S\+E\+R\+V\+E\+R\+\_\+\+E\+X\+T\+R\+A\+\_\+\+S\+T\+A\+CK~0}

Amount of extra stack (above minimum stack size) required by M\+P\+CI receive server thread. Remember that in a multiprocessor system this thread must exist and be able to process all directives.

Port Specific Information\+:

There is no reason to think the v850 needs extra M\+P\+CI receive server stack. \mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_ga47f6e4d60c72b5f65fc775b0b5dd14ec}\label{group__RTEMSScoreCPUV850CPUInterrupt_ga47f6e4d60c72b5f65fc775b0b5dd14ec}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!CPU\_PROVIDES\_ISR\_IS\_IN\_PROGRESS@{CPU\_PROVIDES\_ISR\_IS\_IN\_PROGRESS}}
\index{CPU\_PROVIDES\_ISR\_IS\_IN\_PROGRESS@{CPU\_PROVIDES\_ISR\_IS\_IN\_PROGRESS}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{CPU\_PROVIDES\_ISR\_IS\_IN\_PROGRESS}{CPU\_PROVIDES\_ISR\_IS\_IN\_PROGRESS}}
{\footnotesize\ttfamily \#define C\+P\+U\+\_\+\+P\+R\+O\+V\+I\+D\+E\+S\+\_\+\+I\+S\+R\+\_\+\+I\+S\+\_\+\+I\+N\+\_\+\+P\+R\+O\+G\+R\+E\+SS~\mbox{\hyperlink{group__RTEMSScoreBaseDefs_gaa93f0eb578d23995850d61f7d61c55c1}{F\+A\+L\+SE}}}

This is defined if the port has a special way to report the I\+SR nesting level. Most ports maintain the variable {\itshape \+\_\+\+I\+S\+R\+\_\+\+Nest\+\_\+level}. 

\subsection{Function Documentation}
\mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_ga1d9dcab9170d532b6634a5620385adbd}\label{group__RTEMSScoreCPUV850CPUInterrupt_ga1d9dcab9170d532b6634a5620385adbd}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Get\_level@{\_CPU\_ISR\_Get\_level}}
\index{\_CPU\_ISR\_Get\_level@{\_CPU\_ISR\_Get\_level}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Get\_level()}{\_CPU\_ISR\_Get\_level()}}
{\footnotesize\ttfamily uint32\+\_\+t \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Get\+\_\+level (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Returns the interrupt level of the executing thread. 

Return the current interrupt disable level for this task in the format used by the interrupt level portion of the task mode.

\begin{DoxyNote}{Note}
This routine usually must be implemented as a subroutine.
\end{DoxyNote}
Port Specific Information\+:

This method is implemented in C on the v850.

Obtain the current interrupt disable level.

Return the current interrupt disable level for this task in the format used by the interrupt level portion of the task mode.

\begin{DoxyNote}{Note}
This routine usually must be implemented as a subroutine.
\end{DoxyNote}
Port Specific Information\+:

X\+XX document implementation including references if appropriate \mbox{\Hypertarget{group__RTEMSScoreCPUV850CPUInterrupt_ga5254669b54a06e96ebb585fd50a02c4d}\label{group__RTEMSScoreCPUV850CPUInterrupt_ga5254669b54a06e96ebb585fd50a02c4d}} 
\index{Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}!\_CPU\_ISR\_Is\_enabled@{\_CPU\_ISR\_Is\_enabled}}
\index{\_CPU\_ISR\_Is\_enabled@{\_CPU\_ISR\_Is\_enabled}!Processor Dependent Interrupt Management@{Processor Dependent Interrupt Management}}
\subsubsection{\texorpdfstring{\_CPU\_ISR\_Is\_enabled()}{\_CPU\_ISR\_Is\_enabled()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__RTEMSScoreBaseDefs_gac216239df231d5dbd15e3520b0b9313f}{R\+T\+E\+M\+S\+\_\+\+I\+N\+L\+I\+N\+E\+\_\+\+R\+O\+U\+T\+I\+NE}} bool \+\_\+\+C\+P\+U\+\_\+\+I\+S\+R\+\_\+\+Is\+\_\+enabled (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{level }\end{DoxyParamCaption})}



Returns true if interrupts are enabled in the specified I\+SR level, otherwise returns false. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em level} & The I\+SR level.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & Interrupts are enabled in the I\+SR level. \\
\hline
{\em false} & Otherwise. \\
\hline
\end{DoxyRetVals}
