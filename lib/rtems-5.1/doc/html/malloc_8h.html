<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTEMS: cpukit/include/rtems/malloc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtemslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTEMS
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cd198e36225ba3f41de97552050ac017.html">cpukit</a></li><li class="navelem"><a class="el" href="dir_4f6a7e6de63bf7faab77653961b179a0.html">include</a></li><li class="navelem"><a class="el" href="dir_be382d098cd1aaaaf11a7ebea3d850c0.html">rtems</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">malloc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rtems_8h_source.html">rtems.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bspIo_8h_source.html">rtems/bspIo.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="libcsupport_8h_source.html">rtems/libcsupport.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rtems_2score_2memory_8h_source.html">rtems/score/memory.h</a>&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="malloc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4125d11b86f566f8f1a671fffc6a58e8"><td class="memItemLeft" align="right" valign="top"><a id="a4125d11b86f566f8f1a671fffc6a58e8"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_heap_extend_handler</b>) (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, size_t alloc_size)</td></tr>
<tr class="separator:a4125d11b86f566f8f1a671fffc6a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d890590fd8a1c33433cac66b16d0d4"><td class="memItemLeft" align="right" valign="top"><a id="a38d890590fd8a1c33433cac66b16d0d4"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_malloc_dirtier_t</b>) (void *, size_t)</td></tr>
<tr class="separator:a38d890590fd8a1c33433cac66b16d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a558026e3ed850bab36c6d68ee3727882"><td class="memItemLeft" align="right" valign="top"><a id="a558026e3ed850bab36c6d68ee3727882"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_Malloc_Initialize</b> (const <a class="el" href="structMemory__Information.html">Memory_Information</a> *mem, <a class="el" href="group__RTEMSScoreHeap.html#ga8953b692d39ca1c8a2780e9e8e2d9b1f">Heap_Initialization_or_extend_handler</a> extend)</td></tr>
<tr class="separator:a558026e3ed850bab36c6d68ee3727882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab427c995cc0c8e362e991a7877b261"><td class="memItemLeft" align="right" valign="top"><a id="aaab427c995cc0c8e362e991a7877b261"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#aaab427c995cc0c8e362e991a7877b261">rtems_heap_extend_via_sbrk</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, size_t alloc_size)</td></tr>
<tr class="memdesc:aaab427c995cc0c8e362e991a7877b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTEMS Extend Heap via Sbrk. <br /></td></tr>
<tr class="separator:aaab427c995cc0c8e362e991a7877b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3270d808f93f8a5a2894f5f862ea78"><td class="memItemLeft" align="right" valign="top"><a id="a6a3270d808f93f8a5a2894f5f862ea78"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_heap_null_extend</b> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, size_t alloc_size)</td></tr>
<tr class="separator:a6a3270d808f93f8a5a2894f5f862ea78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2321d5a9197d3cfa63b7d60498222761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#a2321d5a9197d3cfa63b7d60498222761">rtems_malloc_dirty_memory</a> (void *start, size_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="memdesc:a2321d5a9197d3cfa63b7d60498222761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dirty Memory Function.  <a href="#a2321d5a9197d3cfa63b7d60498222761">More...</a><br /></td></tr>
<tr class="separator:a2321d5a9197d3cfa63b7d60498222761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00f1bef8a663ce74ee289b46d9c7ced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#aa00f1bef8a663ce74ee289b46d9c7ced">rtems_memalign</a> (void **pointer, size_t alignment, size_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="memdesc:aa00f1bef8a663ce74ee289b46d9c7ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTEMS Variation on Aligned Memory Allocation.  <a href="#aa00f1bef8a663ce74ee289b46d9c7ced">More...</a><br /></td></tr>
<tr class="separator:aa00f1bef8a663ce74ee289b46d9c7ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addefe365b83b02b5b035ffcfba2a9447"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#addefe365b83b02b5b035ffcfba2a9447">rtems_heap_allocate_aligned_with_boundary</a> (size_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>, uintptr_t alignment, uintptr_t boundary) <a class="el" href="group__RTEMSScoreBaseDefs.html#gae7c9d466d27577cf40868ba00aaf701e">RTEMS_MALLOCLIKE</a> <a class="el" href="group__RTEMSScoreBaseDefs.html#ga482bcf1248a09afc679fc1d56c16343d">RTEMS_ALLOC_SIZE</a>(1) <a class="el" href="group__RTEMSScoreBaseDefs.html#ga444c15811193d14238084ae4aecd2773">RTEMS_ALLOC_ALIGN</a>(2) <a class="el" href="group__RTEMSScoreBaseDefs.html#gacd46c37056a29fdf53c3e8af6e8a4296">RTEMS_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:addefe365b83b02b5b035ffcfba2a9447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory area of size <em>size</em> bytes from the heap.  <a href="#addefe365b83b02b5b035ffcfba2a9447">More...</a><br /></td></tr>
<tr class="separator:addefe365b83b02b5b035ffcfba2a9447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac020a8ae24e753d1da4c838d80c50e91"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#ac020a8ae24e753d1da4c838d80c50e91">rtems_malloc</a> (size_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>) <a class="el" href="group__RTEMSScoreBaseDefs.html#gae7c9d466d27577cf40868ba00aaf701e">RTEMS_MALLOCLIKE</a> <a class="el" href="group__RTEMSScoreBaseDefs.html#ga482bcf1248a09afc679fc1d56c16343d">RTEMS_ALLOC_SIZE</a>(1) <a class="el" href="group__RTEMSScoreBaseDefs.html#gacd46c37056a29fdf53c3e8af6e8a4296">RTEMS_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac020a8ae24e753d1da4c838d80c50e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory area of the specified size from the heap.  <a href="#ac020a8ae24e753d1da4c838d80c50e91">More...</a><br /></td></tr>
<tr class="separator:ac020a8ae24e753d1da4c838d80c50e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71425b0f0952315d27e06eb5e85e77e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#a71425b0f0952315d27e06eb5e85e77e4">rtems_calloc</a> (size_t nelem, size_t elsize) <a class="el" href="group__RTEMSScoreBaseDefs.html#gae7c9d466d27577cf40868ba00aaf701e">RTEMS_MALLOCLIKE</a> <a class="el" href="group__RTEMSScoreBaseDefs.html#ga9988f4196c26c826ca5a715240a463b8">RTEMS_ALLOC_SIZE_2</a>(1</td></tr>
<tr class="memdesc:a71425b0f0952315d27e06eb5e85e77e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory area for the specified count of elements from the heap.  <a href="#a71425b0f0952315d27e06eb5e85e77e4">More...</a><br /></td></tr>
<tr class="separator:a71425b0f0952315d27e06eb5e85e77e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af136cb77bfa16962a04bf148db5fe2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#af136cb77bfa16962a04bf148db5fe2db">rtems_heap_extend</a> (void *area_begin, uintptr_t area_size)</td></tr>
<tr class="memdesc:af136cb77bfa16962a04bf148db5fe2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the memory available for the heap using the memory area starting at <em>area_begin</em> of size <em>area_size</em> bytes.  <a href="#af136cb77bfa16962a04bf148db5fe2db">More...</a><br /></td></tr>
<tr class="separator:af136cb77bfa16962a04bf148db5fe2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebc04cbb90e1ecc6ed7b7ba6780493b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#a8ebc04cbb90e1ecc6ed7b7ba6780493b">rtems_heap_greedy_allocate</a> (const uintptr_t *block_sizes, size_t block_count)</td></tr>
<tr class="memdesc:a8ebc04cbb90e1ecc6ed7b7ba6780493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedy allocate that empties the heap.  <a href="#a8ebc04cbb90e1ecc6ed7b7ba6780493b">More...</a><br /></td></tr>
<tr class="separator:a8ebc04cbb90e1ecc6ed7b7ba6780493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5ba5020cadde776ad76aff68db5563"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#aba5ba5020cadde776ad76aff68db5563">rtems_heap_greedy_allocate_all_except_largest</a> (uintptr_t *allocatable_size)</td></tr>
<tr class="memdesc:aba5ba5020cadde776ad76aff68db5563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedy allocate all blocks except the largest free block.  <a href="#aba5ba5020cadde776ad76aff68db5563">More...</a><br /></td></tr>
<tr class="separator:aba5ba5020cadde776ad76aff68db5563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd363b410e8f0c2f8fce2e220079f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#abcd363b410e8f0c2f8fce2e220079f8a">rtems_heap_greedy_free</a> (void *<a class="el" href="structopaque.html">opaque</a>)</td></tr>
<tr class="memdesc:abcd363b410e8f0c2f8fce2e220079f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees space of a greedy allocation.  <a href="#abcd363b410e8f0c2f8fce2e220079f8a">More...</a><br /></td></tr>
<tr class="separator:abcd363b410e8f0c2f8fce2e220079f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aafa8e14e70015e219e785a6aacb7c58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8h.html#aafa8e14e70015e219e785a6aacb7c58e">RTEMS_Malloc_Heap</a></td></tr>
<tr class="memdesc:aafa8e14e70015e219e785a6aacb7c58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">C program heap control.  <a href="#aafa8e14e70015e219e785a6aacb7c58e">More...</a><br /></td></tr>
<tr class="separator:aafa8e14e70015e219e785a6aacb7c58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37181f4472a8b4dc427a2b441068bf0"><td class="memItemLeft" align="right" valign="top"><a id="ac37181f4472a8b4dc427a2b441068bf0"></a>
ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_Malloc_Sbrk_amount</b></td></tr>
<tr class="separator:ac37181f4472a8b4dc427a2b441068bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdd9a4a2bd66f9a83b6dc4e5b4c78d7"><td class="memItemLeft" align="right" valign="top"><a id="a8bdd9a4a2bd66f9a83b6dc4e5b4c78d7"></a>
const rtems_heap_extend_handler&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_malloc_extend_handler</b></td></tr>
<tr class="separator:a8bdd9a4a2bd66f9a83b6dc4e5b4c78d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e26e0e471d26d38675aae69d6954d3"><td class="memItemLeft" align="right" valign="top"><a id="af6e26e0e471d26d38675aae69d6954d3"></a>
rtems_malloc_dirtier_t&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_malloc_dirty_helper</b></td></tr>
<tr class="separator:af6e26e0e471d26d38675aae69d6954d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfaad752ec7b4279cda178526dcd96d"><td class="memItemLeft" align="right" valign="top"><a id="a6cfaad752ec7b4279cda178526dcd96d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_WARN_UNUSED_RESULT</b></td></tr>
<tr class="separator:a6cfaad752ec7b4279cda178526dcd96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the interface to RTEMS extensions to the Malloc Family. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a71425b0f0952315d27e06eb5e85e77e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71425b0f0952315d27e06eb5e85e77e4">&#9670;&nbsp;</a></span>rtems_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtems_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory area for the specified count of elements from the heap. </p>
<p>The allocated memory area is fully filled with zero bits.</p>
<p>This function is almost identical to calloc(). The only exception is that errno is not set in case of a memory allocation failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nelem</td><td>The count of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elsize</td><td>The size of each elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>The memory allocation failed or <em>nelem</em> is zero or <em>elsize</em> is zero. </td></tr>
    <tr><td class="paramname">otherwise</td><td>The begin address of the allocated memory area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addefe365b83b02b5b035ffcfba2a9447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addefe365b83b02b5b035ffcfba2a9447">&#9670;&nbsp;</a></span>rtems_heap_allocate_aligned_with_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtems_heap_allocate_aligned_with_boundary </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory area of size <em>size</em> bytes from the heap. </p>
<p>If the alignment parameter <em>alignment</em> is not equal to zero, the allocated memory area will begin at an address aligned by this value.</p>
<p>If the boundary parameter <em>boundary</em> is not equal to zero, the allocated memory area will comply with a boundary constraint. The boundary value specifies the set of addresses which are aligned by the boundary value. The interior of the allocated memory area will not contain an element of this set. The begin or end address of the area may be a member of the set.</p>
<p>A size value of zero will return a unique address which may be freed with free().</p>
<p>The memory allocated by this function can be released with a call to free().</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the begin of the allocated memory area, or <code>NULL</code> if no memory is available or the parameters are inconsistent. </dd></dl>

</div>
</div>
<a id="af136cb77bfa16962a04bf148db5fe2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af136cb77bfa16962a04bf148db5fe2db">&#9670;&nbsp;</a></span>rtems_heap_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_heap_extend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>area_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>area_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the memory available for the heap using the memory area starting at <em>area_begin</em> of size <em>area_size</em> bytes. </p>
<p>There are no alignment requirements. The memory area must be big enough to contain some maintenance blocks. It must not overlap parts of the current heap areas. Disconnected subordinate heap areas will lead to used blocks which cover the gaps. Extending with an inappropriate memory area will corrupt the heap.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_ADDRESS</td><td>Invalid memory area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ebc04cbb90e1ecc6ed7b7ba6780493b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebc04cbb90e1ecc6ed7b7ba6780493b">&#9670;&nbsp;</a></span>rtems_heap_greedy_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtems_heap_greedy_allocate </td>
          <td>(</td>
          <td class="paramtype">const uintptr_t *&#160;</td>
          <td class="paramname"><em>block_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedy allocate that empties the heap. </p>
<p>Afterwards the heap has at most <em>block_count</em> allocatable blocks of sizes specified by <em>block_sizes</em>. The <em>block_sizes</em> must point to an array with <em>block_count</em> members. All other blocks are used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="malloc_8h.html#abcd363b410e8f0c2f8fce2e220079f8a" title="Frees space of a greedy allocation.">rtems_heap_greedy_free()</a>. </dd></dl>

</div>
</div>
<a id="aba5ba5020cadde776ad76aff68db5563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5ba5020cadde776ad76aff68db5563">&#9670;&nbsp;</a></span>rtems_heap_greedy_allocate_all_except_largest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtems_heap_greedy_allocate_all_except_largest </td>
          <td>(</td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>allocatable_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedy allocate all blocks except the largest free block. </p>
<p>Afterwards the heap has at most one allocatable block. This block is the largest free block if it exists. The allocatable size of this block is stored in <em>allocatable_size</em>. All other blocks are used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="malloc_8h.html#abcd363b410e8f0c2f8fce2e220079f8a" title="Frees space of a greedy allocation.">rtems_heap_greedy_free()</a>. </dd></dl>

</div>
</div>
<a id="abcd363b410e8f0c2f8fce2e220079f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd363b410e8f0c2f8fce2e220079f8a">&#9670;&nbsp;</a></span>rtems_heap_greedy_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_heap_greedy_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees space of a greedy allocation. </p>
<p>The <em>opaque</em> argument must be the return value of <a class="el" href="malloc_8h.html#a8ebc04cbb90e1ecc6ed7b7ba6780493b" title="Greedy allocate that empties the heap.">rtems_heap_greedy_allocate()</a> or <a class="el" href="malloc_8h.html#aba5ba5020cadde776ad76aff68db5563" title="Greedy allocate all blocks except the largest free block.">rtems_heap_greedy_allocate_all_except_largest()</a>. </p>

</div>
</div>
<a id="ac020a8ae24e753d1da4c838d80c50e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac020a8ae24e753d1da4c838d80c50e91">&#9670;&nbsp;</a></span>rtems_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtems_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory area of the specified size from the heap. </p>
<p>This function is almost identical to malloc(). The only exception is that errno is not set in case of a memory allocation failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The memory area size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>The memory allocation failed or <em>size</em> is zero. </td></tr>
    <tr><td class="paramname">otherwise</td><td>The begin address of the allocated memory area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2321d5a9197d3cfa63b7d60498222761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2321d5a9197d3cfa63b7d60498222761">&#9670;&nbsp;</a></span>rtems_malloc_dirty_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_malloc_dirty_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dirty Memory Function. </p>
<p>This method fills the specified area with a non-zero pattern to aid in debugging programs which do not initialize their memory allocated from the heap. </p>

</div>
</div>
<a id="aa00f1bef8a663ce74ee289b46d9c7ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00f1bef8a663ce74ee289b46d9c7ced">&#9670;&nbsp;</a></span>rtems_memalign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_memalign </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RTEMS Variation on Aligned Memory Allocation. </p>
<p>This method is a help memalign implementation which does all error checking done by posix_memalign() EXCEPT it does NOT place numeric restrictions on the alignment value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>points to the user pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alignment</td><td>is the desired alignment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>is the allocation request size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This methods returns zero on success and a POSIX errno value to indicate the failure condition. On success *pointer will contain the address of the allocated memory. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aafa8e14e70015e219e785a6aacb7c58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa8e14e70015e219e785a6aacb7c58e">&#9670;&nbsp;</a></span>RTEMS_Malloc_Heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHeap__Control.html">Heap_Control</a>* RTEMS_Malloc_Heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C program heap control. </p>
<p>This is the pointer to the heap control structure used to manage the C program heap. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
