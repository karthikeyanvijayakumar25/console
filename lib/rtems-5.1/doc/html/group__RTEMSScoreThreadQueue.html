<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTEMS: Thread Queue Handler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtemslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTEMS
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Thread Queue Handler<div class="ingroups"><a class="el" href="group__RTEMSInternal.html">Internal</a> &raquo; <a class="el" href="group__RTEMSScore.html">SuperCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread Queue Handler.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:threadq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadq_8h.html">threadq.h</a></td></tr>
<tr class="memdesc:threadq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants and Structures Needed to Declare a Thread Queue. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadqimpl_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadqimpl_8h.html">threadqimpl.h</a></td></tr>
<tr class="memdesc:threadqimpl_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants and Structures Associated with the Manipulation of Objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Lock__context.html">Thread_queue_Lock_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue context for the thread queue methods.  <a href="structThread__queue__Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Priority__queue.html">Thread_queue_Priority_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread priority queue.  <a href="structThread__queue__Priority__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Thread__queue__Heads.html">_Thread_queue_Heads</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue heads.  <a href="struct__Thread__queue__Heads.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue operations.  <a href="structThread__queue__Operations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Syslock__queue.html">Thread_queue_Syslock_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue with a layout compatible to struct _Thread_queue_Queue defined in Newlib &lt;sys/lock.h&gt;.  <a href="structThread__queue__Syslock__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__queue__Object.html">Thread_queue_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing.  <a href="structThread__queue__Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga754cc407a9c97408595f94d5577a5996"><td class="memItemLeft" align="right" valign="top"><a id="ga754cc407a9c97408595f94d5577a5996"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_QUEUE_LINK_OF_PATH_NODE</b>(node)&#160;&#160;&#160;<a class="el" href="group__RTEMSScoreBaseDefs.html#gab2e7a0141fd898ae358fa9b134aa2610">RTEMS_CONTAINER_OF</a>( node, Thread_queue_Link, Path_node );</td></tr>
<tr class="separator:ga754cc407a9c97408595f94d5577a5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcdeab82abf0b3ebf08a40c39a32ee6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>_Thread_queue_Context_ISR_disable</b>(queue_context,  level)</td></tr>
<tr class="separator:gaafcdeab82abf0b3ebf08a40c39a32ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18b0ec8fb4243c787a3c5de92fa5d87a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga18b0ec8fb4243c787a3c5de92fa5d87a">_Thread_queue_Context_set_MP_callout</a>(queue_context,  mp_callout)</td></tr>
<tr class="memdesc:ga18b0ec8fb4243c787a3c5de92fa5d87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MP callout in the thread queue context.  <a href="#ga18b0ec8fb4243c787a3c5de92fa5d87a">More...</a><br /></td></tr>
<tr class="separator:ga18b0ec8fb4243c787a3c5de92fa5d87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7efaa6e5152ffe2478cdc74018c759af"><td class="memItemLeft" align="right" valign="top"><a id="ga7efaa6e5152ffe2478cdc74018c759af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_Thread_queue_Queue_acquire_critical</b>(queue,  lock_stats,  lock_context)&#160;&#160;&#160;<a class="el" href="group__RTEMSScoreThreadQueue.html#gaca9472b4bf5091cab34d1a4099e4cfa6">_Thread_queue_Queue_do_acquire_critical</a>( queue, lock_context )</td></tr>
<tr class="separator:ga7efaa6e5152ffe2478cdc74018c759af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e17044b2e16d3d927c52a4d4ecb0ec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4e17044b2e16d3d927c52a4d4ecb0ec9">_Thread_queue_Dequeue</a>(the_thread_queue,  operations,  mp_callout)</td></tr>
<tr class="memdesc:ga4e17044b2e16d3d927c52a4d4ecb0ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a thread waiting on the_thread_queue.  <a href="#ga4e17044b2e16d3d927c52a4d4ecb0ec9">More...</a><br /></td></tr>
<tr class="separator:ga4e17044b2e16d3d927c52a4d4ecb0ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd2316f8881e16a62f263e4114ae3cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_QUEUE_INITIALIZER</b>(_name)</td></tr>
<tr class="separator:ga4fd2316f8881e16a62f263e4114ae3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4954a62452db5b9437608875b84138f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_QUEUE_OBJECT_ASSERT</b>(object_type,  wait_queue_member,  <a class="el" href="structmsg.html">msg</a>)</td></tr>
<tr class="separator:gad4954a62452db5b9437608875b84138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7336809162ffc7b964f9ee223e0d7045"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_QUEUE_QUEUE_TO_OBJECT</b>(queue)</td></tr>
<tr class="separator:ga7336809162ffc7b964f9ee223e0d7045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga42c67428d17dc0b977ffee7463d1cd76"><td class="memItemLeft" align="right" valign="top"><a id="ga42c67428d17dc0b977ffee7463d1cd76"></a>
typedef struct <a class="el" href="struct__Thread__Control.html">_Thread_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_Control</b></td></tr>
<tr class="separator:ga42c67428d17dc0b977ffee7463d1cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2958d2fbd0e3f5a34ded9e43f4579993"><td class="memItemLeft" align="right" valign="top"><a id="ga2958d2fbd0e3f5a34ded9e43f4579993"></a>
typedef struct <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_queue_Context</b></td></tr>
<tr class="separator:ga2958d2fbd0e3f5a34ded9e43f4579993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474795b5f7cfc1e2c9e6f5411667eb92"><td class="memItemLeft" align="right" valign="top"><a id="ga474795b5f7cfc1e2c9e6f5411667eb92"></a>
typedef struct <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_queue_Queue</b></td></tr>
<tr class="separator:ga474795b5f7cfc1e2c9e6f5411667eb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4251ab019ecbfdfea77fd1363282775"><td class="memItemLeft" align="right" valign="top"><a id="gaf4251ab019ecbfdfea77fd1363282775"></a>
typedef struct <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_queue_Operations</b></td></tr>
<tr class="separator:gaf4251ab019ecbfdfea77fd1363282775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd59055cd68c42978de9cd8e007ce1d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga3dd59055cd68c42978de9cd8e007ce1d">Thread_queue_Enqueue_callout</a>) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, struct <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga3dd59055cd68c42978de9cd8e007ce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue enqueue callout.  <a href="#ga3dd59055cd68c42978de9cd8e007ce1d">More...</a><br /></td></tr>
<tr class="separator:ga3dd59055cd68c42978de9cd8e007ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2878c08655ad0911fe6540a1adaf3a3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gab2878c08655ad0911fe6540a1adaf3a3">Thread_queue_Deadlock_callout</a>) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gab2878c08655ad0911fe6540a1adaf3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue deadlock callout.  <a href="#gab2878c08655ad0911fe6540a1adaf3a3">More...</a><br /></td></tr>
<tr class="separator:gab2878c08655ad0911fe6540a1adaf3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebac32033b009cc8f606a90bd389f8e9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__Thread__queue__Heads.html">_Thread_queue_Heads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a></td></tr>
<tr class="memdesc:gaebac32033b009cc8f606a90bd389f8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue heads.  <a href="#gaebac32033b009cc8f606a90bd389f8e9">More...</a><br /></td></tr>
<tr class="separator:gaebac32033b009cc8f606a90bd389f8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdacb1750c6bbc43f99e9c60bd1beba9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gacdacb1750c6bbc43f99e9c60bd1beba9">Thread_queue_Priority_actions_operation</a>) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structPriority__Actions.html">Priority_Actions</a> *priority_actions)</td></tr>
<tr class="memdesc:gacdacb1750c6bbc43f99e9c60bd1beba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue action operation.  <a href="#gacdacb1750c6bbc43f99e9c60bd1beba9">More...</a><br /></td></tr>
<tr class="separator:gacdacb1750c6bbc43f99e9c60bd1beba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d111ef0f5c9457f7e17a217fc7558cd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga1d111ef0f5c9457f7e17a217fc7558cd">Thread_queue_Enqueue_operation</a>) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga1d111ef0f5c9457f7e17a217fc7558cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue enqueue operation.  <a href="#ga1d111ef0f5c9457f7e17a217fc7558cd">More...</a><br /></td></tr>
<tr class="separator:ga1d111ef0f5c9457f7e17a217fc7558cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdee2ebb4fe9f9dae612be0ecce85db"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga7fdee2ebb4fe9f9dae612be0ecce85db">Thread_queue_Extract_operation</a>) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga7fdee2ebb4fe9f9dae612be0ecce85db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue extract operation.  <a href="#ga7fdee2ebb4fe9f9dae612be0ecce85db">More...</a><br /></td></tr>
<tr class="separator:ga7fdee2ebb4fe9f9dae612be0ecce85db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e805a4c313faaddf8dc08592696574"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga42e805a4c313faaddf8dc08592696574">Thread_queue_Surrender_operation</a>) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *heads, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *previous_owner, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga42e805a4c313faaddf8dc08592696574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue surrender operation.  <a href="#ga42e805a4c313faaddf8dc08592696574">More...</a><br /></td></tr>
<tr class="separator:ga42e805a4c313faaddf8dc08592696574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3bee122e35cf14e0ed8680256db439"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gacd3bee122e35cf14e0ed8680256db439">Thread_queue_First_operation</a>) (<a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *heads)</td></tr>
<tr class="memdesc:gacd3bee122e35cf14e0ed8680256db439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue first operation.  <a href="#gacd3bee122e35cf14e0ed8680256db439">More...</a><br /></td></tr>
<tr class="separator:gacd3bee122e35cf14e0ed8680256db439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66aee78bfdca4bd829cdedf18e7c2451"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga66aee78bfdca4bd829cdedf18e7c2451">Thread_queue_Flush_filter</a>) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga66aee78bfdca4bd829cdedf18e7c2451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread queue flush filter function.  <a href="#ga66aee78bfdca4bd829cdedf18e7c2451">More...</a><br /></td></tr>
<tr class="separator:ga66aee78bfdca4bd829cdedf18e7c2451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6a087492df4bba9c56d8e8018339a84e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga6a087492df4bba9c56d8e8018339a84e">_Thread_queue_Enqueue_do_nothing_extra</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga6a087492df4bba9c56d8e8018339a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing.  <a href="#ga6a087492df4bba9c56d8e8018339a84e">More...</a><br /></td></tr>
<tr class="separator:ga6a087492df4bba9c56d8e8018339a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6191fb5cd1e33990f9b505f12c39734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gae6191fb5cd1e33990f9b505f12c39734">_Thread_queue_Add_timeout_ticks</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gae6191fb5cd1e33990f9b505f12c39734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds timeout ticks of the queue to the thread.  <a href="#gae6191fb5cd1e33990f9b505f12c39734">More...</a><br /></td></tr>
<tr class="separator:gae6191fb5cd1e33990f9b505f12c39734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec75c62ea3aad333b84e577a2bb09a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4ec75c62ea3aad333b84e577a2bb09a4">_Thread_queue_Add_timeout_monotonic_timespec</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga4ec75c62ea3aad333b84e577a2bb09a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a monotonic timespec to the thread and sets the watchdog header to monotonic.  <a href="#ga4ec75c62ea3aad333b84e577a2bb09a4">More...</a><br /></td></tr>
<tr class="separator:ga4ec75c62ea3aad333b84e577a2bb09a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14552dcef85b4627e1b2d150f7245f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga14552dcef85b4627e1b2d150f7245f81">_Thread_queue_Add_timeout_realtime_timespec</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga14552dcef85b4627e1b2d150f7245f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a monotonic timespec to the thread and sets the watchdog header to realtime.  <a href="#ga14552dcef85b4627e1b2d150f7245f81">More...</a><br /></td></tr>
<tr class="separator:ga14552dcef85b4627e1b2d150f7245f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca11db0fbad98d6b0ee9a41139aa7d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaca11db0fbad98d6b0ee9a41139aa7d54">_Thread_queue_Deadlock_status</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gaca11db0fbad98d6b0ee9a41139aa7d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread wait return code to STATUS_DEADLOCK.  <a href="#gaca11db0fbad98d6b0ee9a41139aa7d54">More...</a><br /></td></tr>
<tr class="separator:gaca11db0fbad98d6b0ee9a41139aa7d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673681292c0f047b02c6dbb6819e0ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga673681292c0f047b02c6dbb6819e0ad7">_Thread_queue_Deadlock_fatal</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga673681292c0f047b02c6dbb6819e0ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results in an INTERNAL_ERROR_THREAD_QUEUE_DEADLOCK fatal error.  <a href="#ga673681292c0f047b02c6dbb6819e0ad7">More...</a><br /></td></tr>
<tr class="separator:ga673681292c0f047b02c6dbb6819e0ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18ee06777084a67d286d743355d47ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gae18ee06777084a67d286d743355d47ac">_Thread_queue_Context_initialize</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gae18ee06777084a67d286d743355d47ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a thread queue context.  <a href="#gae18ee06777084a67d286d743355d47ac">More...</a><br /></td></tr>
<tr class="separator:gae18ee06777084a67d286d743355d47ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31678d367077d484797bc9c4d97574e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gab31678d367077d484797bc9c4d97574e">_Thread_queue_Context_set_thread_state</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> thread_state)</td></tr>
<tr class="memdesc:gab31678d367077d484797bc9c4d97574e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread state for the thread to enqueue in the thread queue context.  <a href="#gab31678d367077d484797bc9c4d97574e">More...</a><br /></td></tr>
<tr class="separator:gab31678d367077d484797bc9c4d97574e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c130c25dcaf90625f3787a31821c935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga3c130c25dcaf90625f3787a31821c935">_Thread_queue_Context_set_timeout_ticks</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="group__RTEMSScoreWatchdog.html#gaa1834fd7531ca9bb5c4ca6fd990388d5">Watchdog_Interval</a> ticks)</td></tr>
<tr class="memdesc:ga3c130c25dcaf90625f3787a31821c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout ticks in the thread queue context.  <a href="#ga3c130c25dcaf90625f3787a31821c935">More...</a><br /></td></tr>
<tr class="separator:ga3c130c25dcaf90625f3787a31821c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc8878446de7eef0f3c3f309fafe88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaacc8878446de7eef0f3c3f309fafe88c">_Thread_queue_Context_set_timeout_argument</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, const void *arg)</td></tr>
<tr class="memdesc:gaacc8878446de7eef0f3c3f309fafe88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout argument in the thread queue context.  <a href="#gaacc8878446de7eef0f3c3f309fafe88c">More...</a><br /></td></tr>
<tr class="separator:gaacc8878446de7eef0f3c3f309fafe88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3eded5964733b953ab0a461a9d82f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gae3eded5964733b953ab0a461a9d82f5d">_Thread_queue_Context_set_enqueue_callout</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="group__RTEMSScoreThreadQueue.html#ga3dd59055cd68c42978de9cd8e007ce1d">Thread_queue_Enqueue_callout</a> enqueue_callout)</td></tr>
<tr class="memdesc:gae3eded5964733b953ab0a461a9d82f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the enqueue callout in the thread queue context.  <a href="#gae3eded5964733b953ab0a461a9d82f5d">More...</a><br /></td></tr>
<tr class="separator:gae3eded5964733b953ab0a461a9d82f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7142c86d5677c5c5b0f993beecdc712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaa7142c86d5677c5c5b0f993beecdc712">_Thread_queue_Context_set_enqueue_do_nothing_extra</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gaa7142c86d5677c5c5b0f993beecdc712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the do nothing enqueue callout in the thread queue context.  <a href="#gaa7142c86d5677c5c5b0f993beecdc712">More...</a><br /></td></tr>
<tr class="separator:gaa7142c86d5677c5c5b0f993beecdc712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539935c21bc9e51bd27d64eb8f2ea26c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga539935c21bc9e51bd27d64eb8f2ea26c">_Thread_queue_Context_set_enqueue_timeout_ticks</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="group__RTEMSScoreWatchdog.html#gaa1834fd7531ca9bb5c4ca6fd990388d5">Watchdog_Interval</a> ticks)</td></tr>
<tr class="memdesc:ga539935c21bc9e51bd27d64eb8f2ea26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the enqueue callout to add a relative monotonic timeout in ticks.  <a href="#ga539935c21bc9e51bd27d64eb8f2ea26c">More...</a><br /></td></tr>
<tr class="separator:ga539935c21bc9e51bd27d64eb8f2ea26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3094c6721a6db2468884cfb502263d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga3094c6721a6db2468884cfb502263d36">_Thread_queue_Context_set_enqueue_timeout_monotonic_timespec</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, const struct timespec *abstime)</td></tr>
<tr class="memdesc:ga3094c6721a6db2468884cfb502263d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the enqueue callout to add an absolute monotonic timeout in timespec format.  <a href="#ga3094c6721a6db2468884cfb502263d36">More...</a><br /></td></tr>
<tr class="separator:ga3094c6721a6db2468884cfb502263d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab148af32965cdef1887db52409f7ee86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gab148af32965cdef1887db52409f7ee86">_Thread_queue_Context_set_enqueue_timeout_realtime_timespec</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, const struct timespec *abstime)</td></tr>
<tr class="memdesc:gab148af32965cdef1887db52409f7ee86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the enqueue callout to add an absolute realtime timeout in timespec format.  <a href="#gab148af32965cdef1887db52409f7ee86">More...</a><br /></td></tr>
<tr class="separator:gab148af32965cdef1887db52409f7ee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab024e7369bc091e53e7bb04ed8ebfb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gab024e7369bc091e53e7bb04ed8ebfb61">_Thread_queue_Context_set_deadlock_callout</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="group__RTEMSScoreThreadQueue.html#gab2878c08655ad0911fe6540a1adaf3a3">Thread_queue_Deadlock_callout</a> deadlock_callout)</td></tr>
<tr class="memdesc:gab024e7369bc091e53e7bb04ed8ebfb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the deadlock callout in the thread queue context.  <a href="#gab024e7369bc091e53e7bb04ed8ebfb61">More...</a><br /></td></tr>
<tr class="separator:gab024e7369bc091e53e7bb04ed8ebfb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab84f558bc470437d43ce863f8024534e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gab84f558bc470437d43ce863f8024534e">_Thread_queue_Context_clear_priority_updates</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gab84f558bc470437d43ce863f8024534e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the priority update count of the thread queue context.  <a href="#gab84f558bc470437d43ce863f8024534e">More...</a><br /></td></tr>
<tr class="separator:gab84f558bc470437d43ce863f8024534e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87ba650367cd3744e08ce9a0a23c8a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gae87ba650367cd3744e08ce9a0a23c8a0">_Thread_queue_Context_save_priority_updates</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gae87ba650367cd3744e08ce9a0a23c8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the priority update count of the thread queue context.  <a href="#gae87ba650367cd3744e08ce9a0a23c8a0">More...</a><br /></td></tr>
<tr class="separator:gae87ba650367cd3744e08ce9a0a23c8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0adb6adf8dfbbf4836b243b805cdcf51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga0adb6adf8dfbbf4836b243b805cdcf51">_Thread_queue_Context_restore_priority_updates</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, size_t update_count)</td></tr>
<tr class="memdesc:ga0adb6adf8dfbbf4836b243b805cdcf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority update count of the thread queue context.  <a href="#ga0adb6adf8dfbbf4836b243b805cdcf51">More...</a><br /></td></tr>
<tr class="separator:ga0adb6adf8dfbbf4836b243b805cdcf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5f1fcac92cc64364be93f2f5c131f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga5a5f1fcac92cc64364be93f2f5c131f6">_Thread_queue_Context_add_priority_update</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga5a5f1fcac92cc64364be93f2f5c131f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a priority update of the thread to the thread queue context.  <a href="#ga5a5f1fcac92cc64364be93f2f5c131f6">More...</a><br /></td></tr>
<tr class="separator:ga5a5f1fcac92cc64364be93f2f5c131f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076b043e2ddbb7500429a733cac31f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga076b043e2ddbb7500429a733cac31f1f">_Thread_queue_Context_set_ISR_level</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, <a class="el" href="group__RTEMSScoreISR.html#gad1af728587ebcefec5b5cf94fc7909b9">ISR_Level</a> level)</td></tr>
<tr class="memdesc:ga076b043e2ddbb7500429a733cac31f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread queue context ISR level.  <a href="#ga076b043e2ddbb7500429a733cac31f1f">More...</a><br /></td></tr>
<tr class="separator:ga076b043e2ddbb7500429a733cac31f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcef3658d8266b9f66015474e2c88bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga8dcef3658d8266b9f66015474e2c88bd">_Thread_queue_Dispatch_disable</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga8dcef3658d8266b9f66015474e2c88bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables dispatching in a critical section.  <a href="#ga8dcef3658d8266b9f66015474e2c88bd">More...</a><br /></td></tr>
<tr class="separator:ga8dcef3658d8266b9f66015474e2c88bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8b973ae28379dbf863c01f10c993f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaed8b973ae28379dbf863c01f10c993f3">_Thread_queue_Heads_initialize</a> (<a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *heads)</td></tr>
<tr class="memdesc:gaed8b973ae28379dbf863c01f10c993f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the thread queue heads.  <a href="#gaed8b973ae28379dbf863c01f10c993f3">More...</a><br /></td></tr>
<tr class="separator:gaed8b973ae28379dbf863c01f10c993f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf4b585322581d70c742c7292bc8435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga9bf4b585322581d70c742c7292bc8435">_Thread_queue_Queue_initialize</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, const char *name)</td></tr>
<tr class="memdesc:ga9bf4b585322581d70c742c7292bc8435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the thread queue queue with the given name.  <a href="#ga9bf4b585322581d70c742c7292bc8435">More...</a><br /></td></tr>
<tr class="separator:ga9bf4b585322581d70c742c7292bc8435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9472b4bf5091cab34d1a4099e4cfa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaca9472b4bf5091cab34d1a4099e4cfa6">_Thread_queue_Queue_do_acquire_critical</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gaca9472b4bf5091cab34d1a4099e4cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread queue queue in a critical section.  <a href="#gaca9472b4bf5091cab34d1a4099e4cfa6">More...</a><br /></td></tr>
<tr class="separator:gaca9472b4bf5091cab34d1a4099e4cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf210496afecfdf44064e41e8a83950ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaf210496afecfdf44064e41e8a83950ea">_Thread_queue_Queue_release_critical</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gaf210496afecfdf44064e41e8a83950ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread queue queue in a critical section.  <a href="#gaf210496afecfdf44064e41e8a83950ea">More...</a><br /></td></tr>
<tr class="separator:gaf210496afecfdf44064e41e8a83950ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5074d780cc6e486c858a564e0406f647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga5074d780cc6e486c858a564e0406f647">_Thread_queue_Queue_release</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga5074d780cc6e486c858a564e0406f647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread queue queue and enables interrupts.  <a href="#ga5074d780cc6e486c858a564e0406f647">More...</a><br /></td></tr>
<tr class="separator:ga5074d780cc6e486c858a564e0406f647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac17ae1a1c80b80869cac13c6c8bb9ade"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gac17ae1a1c80b80869cac13c6c8bb9ade">_Thread_queue_Queue_get_name_and_id</a> (const <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, char *buffer, size_t buffer_size, <a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a> *id)</td></tr>
<tr class="memdesc:gac17ae1a1c80b80869cac13c6c8bb9ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the thread queue name to the specified buffer.  <a href="#gac17ae1a1c80b80869cac13c6c8bb9ade">More...</a><br /></td></tr>
<tr class="separator:gac17ae1a1c80b80869cac13c6c8bb9ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1488e09cc925566233f2f1fc76c4d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaf1488e09cc925566233f2f1fc76c4d81">_Thread_queue_Do_acquire_critical</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gaf1488e09cc925566233f2f1fc76c4d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread queue control in a critical section.  <a href="#gaf1488e09cc925566233f2f1fc76c4d81">More...</a><br /></td></tr>
<tr class="separator:gaf1488e09cc925566233f2f1fc76c4d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb5c604a28a636950cca7aa43a47869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga2bb5c604a28a636950cca7aa43a47869">_Thread_queue_Acquire_critical</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga2bb5c604a28a636950cca7aa43a47869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread queue control in a critical section.  <a href="#ga2bb5c604a28a636950cca7aa43a47869">More...</a><br /></td></tr>
<tr class="separator:ga2bb5c604a28a636950cca7aa43a47869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40080175681761a842fe6ab4784735b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga40080175681761a842fe6ab4784735b9">_Thread_queue_Acquire</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga40080175681761a842fe6ab4784735b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread queue control in a critical section.  <a href="#ga40080175681761a842fe6ab4784735b9">More...</a><br /></td></tr>
<tr class="separator:ga40080175681761a842fe6ab4784735b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923d39f206f389ae8a8293e22bae8fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga923d39f206f389ae8a8293e22bae8fbf">_Thread_queue_Do_release_critical</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga923d39f206f389ae8a8293e22bae8fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread queue control is the owner of the lock.  <a href="#ga923d39f206f389ae8a8293e22bae8fbf">More...</a><br /></td></tr>
<tr class="separator:ga923d39f206f389ae8a8293e22bae8fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0796c03f91beaa6caa842433122bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga5f0796c03f91beaa6caa842433122bab">_Thread_queue_Release_critical</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga5f0796c03f91beaa6caa842433122bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread queue control in a critical section.  <a href="#ga5f0796c03f91beaa6caa842433122bab">More...</a><br /></td></tr>
<tr class="separator:ga5f0796c03f91beaa6caa842433122bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8881ef4106a0707b2751cdd3d18bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga0a8881ef4106a0707b2751cdd3d18bef">_Thread_queue_Release</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga0a8881ef4106a0707b2751cdd3d18bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread queue control and enables interrupts.  <a href="#ga0a8881ef4106a0707b2751cdd3d18bef">More...</a><br /></td></tr>
<tr class="separator:ga0a8881ef4106a0707b2751cdd3d18bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1671707d42e9a381c3737b58deed97d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga1671707d42e9a381c3737b58deed97d5">_Thread_queue_Do_dequeue</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations)</td></tr>
<tr class="memdesc:ga1671707d42e9a381c3737b58deed97d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues the first thread waiting on the thread queue and returns it.  <a href="#ga1671707d42e9a381c3737b58deed97d5">More...</a><br /></td></tr>
<tr class="separator:ga1671707d42e9a381c3737b58deed97d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4992b40810f6d287c832bdad240dbc90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90">_Thread_queue_Enqueue</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga4992b40810f6d287c832bdad240dbc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the thread and places it on the thread queue.  <a href="#ga4992b40810f6d287c832bdad240dbc90">More...</a><br /></td></tr>
<tr class="separator:ga4992b40810f6d287c832bdad240dbc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a4a052dcfd0db5df6ff9fa16bbfb4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga91a4a052dcfd0db5df6ff9fa16bbfb4f">_Thread_queue_Extract_locked</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga91a4a052dcfd0db5df6ff9fa16bbfb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the thread from the thread queue, restores the default wait operations and restores the default thread lock.  <a href="#ga91a4a052dcfd0db5df6ff9fa16bbfb4f">More...</a><br /></td></tr>
<tr class="separator:ga91a4a052dcfd0db5df6ff9fa16bbfb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47a7180a4fc9e6e834ec4067e580296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gae47a7180a4fc9e6e834ec4067e580296">_Thread_queue_Unblock_critical</a> (bool unblock, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gae47a7180a4fc9e6e834ec4067e580296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks the thread which was on the thread queue before.  <a href="#gae47a7180a4fc9e6e834ec4067e580296">More...</a><br /></td></tr>
<tr class="separator:gae47a7180a4fc9e6e834ec4067e580296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ce2524fef09fe93a24196dd392093e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaf6ce2524fef09fe93a24196dd392093e">_Thread_queue_Extract_critical</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gaf6ce2524fef09fe93a24196dd392093e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the thread from the thread queue and unblocks it.  <a href="#gaf6ce2524fef09fe93a24196dd392093e">More...</a><br /></td></tr>
<tr class="separator:gaf6ce2524fef09fe93a24196dd392093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade3d717e5bef36275e5abd5c9cb0795f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gade3d717e5bef36275e5abd5c9cb0795f">_Thread_queue_Extract</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gade3d717e5bef36275e5abd5c9cb0795f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts thread from thread queue.  <a href="#gade3d717e5bef36275e5abd5c9cb0795f">More...</a><br /></td></tr>
<tr class="separator:gade3d717e5bef36275e5abd5c9cb0795f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999731e7674266e35751c1afad5a10b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga999731e7674266e35751c1afad5a10b3">_Thread_queue_Extract_with_proxy</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga999731e7674266e35751c1afad5a10b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the_thread from the_thread_queue.  <a href="#ga999731e7674266e35751c1afad5a10b3">More...</a><br /></td></tr>
<tr class="separator:ga999731e7674266e35751c1afad5a10b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f163fd4e89b8ea38e05e2faf4b065cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga2f163fd4e89b8ea38e05e2faf4b065cf">_Thread_queue_Surrender</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *heads, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *previous_owner, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations)</td></tr>
<tr class="memdesc:ga2f163fd4e89b8ea38e05e2faf4b065cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surrenders the thread queue previously owned by the thread to the first enqueued thread.  <a href="#ga2f163fd4e89b8ea38e05e2faf4b065cf">More...</a><br /></td></tr>
<tr class="separator:ga2f163fd4e89b8ea38e05e2faf4b065cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b6fa511ba7c3c55a3afb91cc7b0cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga35b6fa511ba7c3c55a3afb91cc7b0cfb">_Thread_queue_Is_empty</a> (const <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue)</td></tr>
<tr class="memdesc:ga35b6fa511ba7c3c55a3afb91cc7b0cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread queue queue is empty.  <a href="#ga35b6fa511ba7c3c55a3afb91cc7b0cfb">More...</a><br /></td></tr>
<tr class="separator:ga35b6fa511ba7c3c55a3afb91cc7b0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07672b4b41838966ddf124973f51451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gac07672b4b41838966ddf124973f51451">_Thread_queue_First_locked</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations)</td></tr>
<tr class="memdesc:gac07672b4b41838966ddf124973f51451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first thread on the thread queue if it exists, otherwise <code>NULL</code>.  <a href="#gac07672b4b41838966ddf124973f51451">More...</a><br /></td></tr>
<tr class="separator:gac07672b4b41838966ddf124973f51451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4408cda9750cde6b1d469759762ecb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4408cda9750cde6b1d469759762ecb14">_Thread_queue_First</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations)</td></tr>
<tr class="memdesc:ga4408cda9750cde6b1d469759762ecb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first thread on the thread queue if it exists, otherwise <code>NULL</code>.  <a href="#ga4408cda9750cde6b1d469759762ecb14">More...</a><br /></td></tr>
<tr class="separator:ga4408cda9750cde6b1d469759762ecb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ba9f035005918f0e5eca4a3cfc92a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaf7ba9f035005918f0e5eca4a3cfc92a1">_Thread_queue_Flush_default_filter</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gaf7ba9f035005918f0e5eca4a3cfc92a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default thread queue flush filter function.  <a href="#gaf7ba9f035005918f0e5eca4a3cfc92a1">More...</a><br /></td></tr>
<tr class="separator:gaf7ba9f035005918f0e5eca4a3cfc92a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafffea388b0a89cc1ba6540a73477130c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gafffea388b0a89cc1ba6540a73477130c">_Thread_queue_Flush_status_unavailable</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gafffea388b0a89cc1ba6540a73477130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status unavailable thread queue flush filter function.  <a href="#gafffea388b0a89cc1ba6540a73477130c">More...</a><br /></td></tr>
<tr class="separator:gafffea388b0a89cc1ba6540a73477130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33b5b4a755484ecff2e1f72a56be373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gac33b5b4a755484ecff2e1f72a56be373">_Thread_queue_Flush_status_object_was_deleted</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gac33b5b4a755484ecff2e1f72a56be373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status object was deleted thread queue flush filter function.  <a href="#gac33b5b4a755484ecff2e1f72a56be373">More...</a><br /></td></tr>
<tr class="separator:gac33b5b4a755484ecff2e1f72a56be373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac979e73bbbb59a3157ebd782ff70df0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gac979e73bbbb59a3157ebd782ff70df0c">_Thread_queue_Flush_critical</a> (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations, <a class="el" href="group__RTEMSScoreThreadQueue.html#ga66aee78bfdca4bd829cdedf18e7c2451">Thread_queue_Flush_filter</a> filter, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gac979e73bbbb59a3157ebd782ff70df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks all threads enqueued on the thread queue.  <a href="#gac979e73bbbb59a3157ebd782ff70df0c">More...</a><br /></td></tr>
<tr class="separator:gac979e73bbbb59a3157ebd782ff70df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae839c93467db7f3bb1776323a17ac8ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gae839c93467db7f3bb1776323a17ac8ad">_Thread_queue_Initialize</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue, const char *name)</td></tr>
<tr class="memdesc:gae839c93467db7f3bb1776323a17ac8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the thread queue control to the given name.  <a href="#gae839c93467db7f3bb1776323a17ac8ad">More...</a><br /></td></tr>
<tr class="separator:gae839c93467db7f3bb1776323a17ac8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa59fb38f22e409d05123df6627ead47a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaa59fb38f22e409d05123df6627ead47a">_Thread_queue_Destroy</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue)</td></tr>
<tr class="memdesc:gaa59fb38f22e409d05123df6627ead47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the thread queue.  <a href="#gaa59fb38f22e409d05123df6627ead47a">More...</a><br /></td></tr>
<tr class="separator:gaa59fb38f22e409d05123df6627ead47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff2605d33f07f210c22844f1ae71eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gadff2605d33f07f210c22844f1ae71eaf">_Thread_queue_Object_initialize</a> (<a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *the_thread_queue)</td></tr>
<tr class="memdesc:gadff2605d33f07f210c22844f1ae71eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a thread queue embedded in an object with identifier.  <a href="#gadff2605d33f07f210c22844f1ae71eaf">More...</a><br /></td></tr>
<tr class="separator:gadff2605d33f07f210c22844f1ae71eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8882291b516b6920d04dfbcc45faa443"><td class="memItemLeft" align="right" valign="top"><a id="ga8882291b516b6920d04dfbcc45faa443"></a>
const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_Thread_queue_Operations_default</b></td></tr>
<tr class="separator:ga8882291b516b6920d04dfbcc45faa443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga330a81a2edf215fbfed2b82e39d43681"><td class="memItemLeft" align="right" valign="top"><a id="ga330a81a2edf215fbfed2b82e39d43681"></a>
const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_Thread_queue_Operations_FIFO</b></td></tr>
<tr class="separator:ga330a81a2edf215fbfed2b82e39d43681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02d697e0f80325c9d1130798b428520e"><td class="memItemLeft" align="right" valign="top"><a id="ga02d697e0f80325c9d1130798b428520e"></a>
const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_Thread_queue_Operations_priority</b></td></tr>
<tr class="separator:ga02d697e0f80325c9d1130798b428520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872841276b9740c8b2358485795f2feb"><td class="memItemLeft" align="right" valign="top"><a id="ga872841276b9740c8b2358485795f2feb"></a>
const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_Thread_queue_Operations_priority_inherit</b></td></tr>
<tr class="separator:ga872841276b9740c8b2358485795f2feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa050ed6bbc86ca717c26cd68b93a49b7"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaa050ed6bbc86ca717c26cd68b93a49b7">_Thread_queue_Object_name</a> []</td></tr>
<tr class="memdesc:gaa050ed6bbc86ca717c26cd68b93a49b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special thread queue name to indicated that the thread queue is embedded in an object with identifier.  <a href="#gaa050ed6bbc86ca717c26cd68b93a49b7">More...</a><br /></td></tr>
<tr class="separator:gaa050ed6bbc86ca717c26cd68b93a49b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Thread Queue Handler. </p>
<p>This handler provides the capability to have threads block in ordered sets. The sets may be ordered using the FIFO or priority discipline. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaafcdeab82abf0b3ebf08a40c39a32ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcdeab82abf0b3ebf08a40c39a32ee6">&#9670;&nbsp;</a></span>_Thread_queue_Context_ISR_disable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _Thread_queue_Context_ISR_disable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue_context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div><div class="line">    _ISR_Local_disable( level ); \</div><div class="line">    _ISR_lock_ISR_disable_profile( \</div><div class="line">      &amp;( queue_context )-&gt;Lock_context.Lock_context \</div><div class="line">    ) \</div><div class="line">  } <span class="keywordflow">while</span> ( 0 )</div></div><!-- fragment -->
</div>
</div>
<a id="ga18b0ec8fb4243c787a3c5de92fa5d87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18b0ec8fb4243c787a3c5de92fa5d87a">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_MP_callout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _Thread_queue_Context_set_MP_callout</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue_context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp_callout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div><div class="line">    (void) queue_context; \</div><div class="line">  } <span class="keywordflow">while</span> ( 0 )</div></div><!-- fragment -->
<p>Sets the MP callout in the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mp_callout</td><td>Callout to unblock the thread in case it is actually a thread proxy. This parameter is only used on multiprocessing configurations. Used by thread queue extract and unblock methods for objects with multiprocessing (MP) support. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e17044b2e16d3d927c52a4d4ecb0ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e17044b2e16d3d927c52a4d4ecb0ec9">&#9670;&nbsp;</a></span>_Thread_queue_Dequeue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _Thread_queue_Dequeue</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">the_thread_queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">operations, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp_callout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__RTEMSScoreThreadQueue.html#ga1671707d42e9a381c3737b58deed97d5">_Thread_queue_Do_dequeue</a>( \</div><div class="line">      the_thread_queue, \</div><div class="line">      operations \</div><div class="line">    )</div><div class="ttc" id="group__RTEMSScoreThreadQueue_html_ga1671707d42e9a381c3737b58deed97d5"><div class="ttname"><a href="group__RTEMSScoreThreadQueue.html#ga1671707d42e9a381c3737b58deed97d5">_Thread_queue_Do_dequeue</a></div><div class="ttdeci">Thread_Control * _Thread_queue_Do_dequeue(Thread_queue_Control *the_thread_queue, const Thread_queue_Operations *operations)</div><div class="ttdoc">Dequeues the first thread waiting on the thread queue and returns it.</div><div class="ttdef"><b>Definition:</b> threadqenqueue.c:742</div></div>
</div><!-- fragment -->
<p>Gets a pointer to a thread waiting on the_thread_queue. </p>
<p>This function returns a pointer to a thread waiting on the_thread_queue. The selection of this thread is based on the discipline of the_thread_queue. If no threads are waiting on the_thread_queue, then NULL is returned.</p>
<ul>
<li>INTERRUPT LATENCY:<ul>
<li>single case </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga4fd2316f8881e16a62f263e4114ae3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fd2316f8881e16a62f263e4114ae3cc">&#9670;&nbsp;</a></span>THREAD_QUEUE_INITIALIZER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_QUEUE_INITIALIZER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div><div class="line">      .Queue = { \</div><div class="line">        .heads = <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a>, \</div><div class="line">        .owner = <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a>, \</div><div class="line">        .name = _name \</div><div class="line">      } \</div><div class="line">    }</div><div class="ttc" id="bestcomm__api_8h_html_a872bb74de61c3689ccd5b41873fce42c"><div class="ttname"><a href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Requests a GPIO pin group configuration.</div><div class="ttdef"><b>Definition:</b> bestcomm_api.h:77</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad4954a62452db5b9437608875b84138f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4954a62452db5b9437608875b84138f">&#9670;&nbsp;</a></span>THREAD_QUEUE_OBJECT_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_QUEUE_OBJECT_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">object_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait_queue_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structmsg.html">msg</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">RTEMS_STATIC_ASSERT( \</div><div class="line">    offsetof( object_type, wait_queue_member ) \</div><div class="line">      == offsetof( <a class="code" href="structThread__queue__Object.html">Thread_queue_Object</a>, Wait_queue ) \</div><div class="line">    &amp;&amp; <a class="code" href="group__RTEMSScoreBaseDefs.html#ga662d6f57a710150b48c8be4eb1fe9ff8">RTEMS_HAVE_MEMBER_SAME_TYPE</a>( \</div><div class="line">      object_type, \</div><div class="line">      wait_queue_member, \</div><div class="line">      <a class="code" href="structThread__queue__Object.html">Thread_queue_Object</a>, \</div><div class="line">      Wait_queue \</div><div class="line">    ), \</div><div class="line">    <a class="code" href="structmsg.html">msg</a> \</div><div class="line">  )</div><div class="ttc" id="group__RTEMSScoreBaseDefs_html_ga662d6f57a710150b48c8be4eb1fe9ff8"><div class="ttname"><a href="group__RTEMSScoreBaseDefs.html#ga662d6f57a710150b48c8be4eb1fe9ff8">RTEMS_HAVE_MEMBER_SAME_TYPE</a></div><div class="ttdeci">#define RTEMS_HAVE_MEMBER_SAME_TYPE(_t_lhs, _m_lhs, _t_rhs, _m_rhs)</div><div class="ttdoc">Evaluates to true if the members of two types have the same type.</div><div class="ttdef"><b>Definition:</b> basedefs.h:527</div></div>
<div class="ttc" id="structmsg_html"><div class="ttname"><a href="structmsg.html">msg</a></div><div class="ttdef"><b>Definition:</b> b1553brm.c:75</div></div>
<div class="ttc" id="structThread__queue__Object_html"><div class="ttname"><a href="structThread__queue__Object.html">Thread_queue_Object</a></div><div class="ttdoc">Does nothing.</div><div class="ttdef"><b>Definition:</b> threadqimpl.h:1445</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7336809162ffc7b964f9ee223e0d7045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7336809162ffc7b964f9ee223e0d7045">&#9670;&nbsp;</a></span>THREAD_QUEUE_QUEUE_TO_OBJECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_QUEUE_QUEUE_TO_OBJECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__RTEMSScoreBaseDefs.html#gab2e7a0141fd898ae358fa9b134aa2610">RTEMS_CONTAINER_OF</a>( \</div><div class="line">    queue, \</div><div class="line">    <a class="code" href="structThread__queue__Object.html">Thread_queue_Object</a>, \</div><div class="line">    Wait_queue.Queue \</div><div class="line">  )</div><div class="ttc" id="group__RTEMSScoreBaseDefs_html_gab2e7a0141fd898ae358fa9b134aa2610"><div class="ttname"><a href="group__RTEMSScoreBaseDefs.html#gab2e7a0141fd898ae358fa9b134aa2610">RTEMS_CONTAINER_OF</a></div><div class="ttdeci">#define RTEMS_CONTAINER_OF(_m, _type, _member_name)</div><div class="ttdoc">Returns a pointer to the container of a specified member pointer.</div><div class="ttdef"><b>Definition:</b> basedefs.h:430</div></div>
<div class="ttc" id="structThread__queue__Object_html"><div class="ttname"><a href="structThread__queue__Object.html">Thread_queue_Object</a></div><div class="ttdoc">Does nothing.</div><div class="ttdef"><b>Definition:</b> threadqimpl.h:1445</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab2878c08655ad0911fe6540a1adaf3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2878c08655ad0911fe6540a1adaf3a3">&#9670;&nbsp;</a></span>Thread_queue_Deadlock_callout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * Thread_queue_Deadlock_callout) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue deadlock callout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread that detected the deadlock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#gab024e7369bc091e53e7bb04ed8ebfb61" title="Sets the deadlock callout in the thread queue context.">_Thread_queue_Context_set_deadlock_callout()</a>. </dd></dl>

</div>
</div>
<a id="ga3dd59055cd68c42978de9cd8e007ce1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd59055cd68c42978de9cd8e007ce1d">&#9670;&nbsp;</a></span>Thread_queue_Enqueue_callout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * Thread_queue_Enqueue_callout) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, struct <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue enqueue callout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the_thread</td><td>The thread to enqueue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_context</td><td>The thread queue context of the lock acquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#gae3eded5964733b953ab0a461a9d82f5d" title="Sets the enqueue callout in the thread queue context.">_Thread_queue_Context_set_enqueue_callout()</a>. </dd></dl>

</div>
</div>
<a id="ga1d111ef0f5c9457f7e17a217fc7558cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d111ef0f5c9457f7e17a217fc7558cd">&#9670;&nbsp;</a></span>Thread_queue_Enqueue_operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * Thread_queue_Enqueue_operation) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue enqueue operation. </p>
<p>A potential thread to update the priority due to priority inheritance is returned via the thread queue context. This thread is handed over to <a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59" title="Updates the priority of all threads in the set.">_Thread_Priority_update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the_thread</td><td>The thread to enqueue on the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fdee2ebb4fe9f9dae612be0ecce85db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fdee2ebb4fe9f9dae612be0ecce85db">&#9670;&nbsp;</a></span>Thread_queue_Extract_operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * Thread_queue_Extract_operation) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue extract operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the_thread</td><td>The thread to extract from the thread queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd3bee122e35cf14e0ed8680256db439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3bee122e35cf14e0ed8680256db439">&#9670;&nbsp;</a></span>Thread_queue_First_operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct__Thread__Control.html">Thread_Control</a>*( * Thread_queue_First_operation) (<a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *heads)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue first operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heads</td><td>The thread queue heads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>No thread is present on the thread queue. </td></tr>
    <tr><td class="paramname">first</td><td>The first thread of the thread queue according to the insert order. This thread remains on the thread queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66aee78bfdca4bd829cdedf18e7c2451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66aee78bfdca4bd829cdedf18e7c2451">&#9670;&nbsp;</a></span>Thread_queue_Flush_filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct__Thread__Control.html">Thread_Control</a>*( * Thread_queue_Flush_filter) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue flush filter function. </p>
<p>Called under protection of the thread queue lock by <a class="el" href="group__RTEMSScoreThreadQueue.html#gac979e73bbbb59a3157ebd782ff70df0c" title="Unblocks all threads enqueued on the thread queue.">_Thread_queue_Flush_critical()</a> to optionally alter the thread wait information and control the iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to extract. This is the first parameter to optimize for architectures that use the same register for the first parameter and the return value. </td></tr>
    <tr><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramname">queue_context</td><td>The thread queue context of the lock acquire. May be used to pass additional data to the filter function via an overlay structure. The filter function should not release or acquire the thread queue lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">the_thread</td><td>Extract this thread. </td></tr>
    <tr><td class="paramname">NULL</td><td>Do not extract this thread and stop the thread queue flush operation. Threads that are already extracted will complete the flush operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebac32033b009cc8f606a90bd389f8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebac32033b009cc8f606a90bd389f8e9">&#9670;&nbsp;</a></span>Thread_queue_Heads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__Thread__queue__Heads.html">_Thread_queue_Heads</a>  <a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue heads. </p>
<p>Each thread is equipped with spare thread queue heads in case it is not enqueued on a thread queue. The first thread enqueued on a thread queue will give its spare thread queue heads to that thread queue. The threads arriving at the queue will add their thread queue heads to the free chain of the queue heads provided by the first thread enqueued. Once a thread is dequeued it use the free chain to get new spare thread queue heads.</p>
<p>Uses a leading underscore in the structure name to allow forward declarations in standard header files provided by Newlib and GCC. </p>

</div>
</div>
<a id="gacdacb1750c6bbc43f99e9c60bd1beba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdacb1750c6bbc43f99e9c60bd1beba9">&#9670;&nbsp;</a></span>Thread_queue_Priority_actions_operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * Thread_queue_Priority_actions_operation) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="structPriority__Actions.html">Priority_Actions</a> *priority_actions)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue action operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_context</td><td>The thread queue context providing the thread queue action set to perform. Returns the thread queue action set to perform on the thread queue owner or the empty set in case there is nothing to do. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42e805a4c313faaddf8dc08592696574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e805a4c313faaddf8dc08592696574">&#9670;&nbsp;</a></span>Thread_queue_Surrender_operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct__Thread__Control.html">Thread_Control</a>*( * Thread_queue_Surrender_operation) (<a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue, <a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *heads, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *previous_owner, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread queue surrender operation. </p>
<p>This operation must dequeue and return the first thread on the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heads</td><td>The thread queue heads. It must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">previous_owner</td><td>The previous owner of the thread queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous first thread on the queue. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga40080175681761a842fe6ab4784735b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40080175681761a842fe6ab4784735b9">&#9670;&nbsp;</a></span>_Thread_queue_Acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread queue control in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread_queue</td><td>The thread queue control to acquire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bb5c604a28a636950cca7aa43a47869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb5c604a28a636950cca7aa43a47869">&#9670;&nbsp;</a></span>_Thread_queue_Acquire_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Acquire_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread queue control in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread_queue</td><td>The thread queue control to acquire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The interrupt lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ec75c62ea3aad333b84e577a2bb09a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ec75c62ea3aad333b84e577a2bb09a4">&#9670;&nbsp;</a></span>_Thread_queue_Add_timeout_monotonic_timespec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Add_timeout_monotonic_timespec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a monotonic timespec to the thread and sets the watchdog header to monotonic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to add the timeout and set watchdog header to monotonic. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu_self</td><td>The cpu to get the monotonic watchdog header from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14552dcef85b4627e1b2d150f7245f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14552dcef85b4627e1b2d150f7245f81">&#9670;&nbsp;</a></span>_Thread_queue_Add_timeout_realtime_timespec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Add_timeout_realtime_timespec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a monotonic timespec to the thread and sets the watchdog header to realtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to add the timeout and set watchdog header to realtime. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu_self</td><td>The cpu to get the realtime watchdog header from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6191fb5cd1e33990f9b505f12c39734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6191fb5cd1e33990f9b505f12c39734">&#9670;&nbsp;</a></span>_Thread_queue_Add_timeout_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Add_timeout_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds timeout ticks of the queue to the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to add timeout ticks to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu_self</td><td>The cpu for the operation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a5f1fcac92cc64364be93f2f5c131f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5f1fcac92cc64364be93f2f5c131f6">&#9670;&nbsp;</a></span>_Thread_queue_Context_add_priority_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_add_priority_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a priority update of the thread to the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context to increase the priority update count of and set the_thread in its Priority update array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">the_thread</td><td>The thread for the priority update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab84f558bc470437d43ce863f8024534e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab84f558bc470437d43ce863f8024534e">&#9670;&nbsp;</a></span>_Thread_queue_Context_clear_priority_updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_clear_priority_updates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the priority update count of the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context to clear the priority update count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae18ee06777084a67d286d743355d47ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae18ee06777084a67d286d743355d47ac">&#9670;&nbsp;</a></span>_Thread_queue_Context_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0adb6adf8dfbbf4836b243b805cdcf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0adb6adf8dfbbf4836b243b805cdcf51">&#9670;&nbsp;</a></span>_Thread_queue_Context_restore_priority_updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_restore_priority_updates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>update_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the priority update count of the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context to set the priority update count of. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">update_count</td><td>The priority update count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae87ba650367cd3744e08ce9a0a23c8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae87ba650367cd3744e08ce9a0a23c8a0">&#9670;&nbsp;</a></span>_Thread_queue_Context_save_priority_updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> size_t _Thread_queue_Context_save_priority_updates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the priority update count of the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_context</td><td>The thread queue context to get the priority update count of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The priority update count of <em>queue_context</em>. </dd></dl>

</div>
</div>
<a id="gab024e7369bc091e53e7bb04ed8ebfb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab024e7369bc091e53e7bb04ed8ebfb61">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_deadlock_callout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_deadlock_callout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThreadQueue.html#gab2878c08655ad0911fe6540a1adaf3a3">Thread_queue_Deadlock_callout</a>&#160;</td>
          <td class="paramname"><em>deadlock_callout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the deadlock callout in the thread queue context. </p>
<p>A deadlock callout must be provided for <a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a> operations that operate on thread queues which may have an owner, e.g. mutex objects. Available deadlock callouts are <a class="el" href="group__RTEMSScoreThreadQueue.html#gaca11db0fbad98d6b0ee9a41139aa7d54" title="Sets the thread wait return code to STATUS_DEADLOCK.">_Thread_queue_Deadlock_status()</a> and <a class="el" href="group__RTEMSScoreThreadQueue.html#ga673681292c0f047b02c6dbb6819e0ad7" title="Results in an INTERNAL_ERROR_THREAD_QUEUE_DEADLOCK fatal error.">_Thread_queue_Deadlock_fatal()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">deadlock_callout</td><td>The deadlock callout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="gae3eded5964733b953ab0a461a9d82f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3eded5964733b953ab0a461a9d82f5d">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_enqueue_callout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_enqueue_callout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga3dd59055cd68c42978de9cd8e007ce1d">Thread_queue_Enqueue_callout</a>&#160;</td>
          <td class="paramname"><em>enqueue_callout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the enqueue callout in the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">enqueue_callout</td><td>The enqueue callout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="gaa7142c86d5677c5c5b0f993beecdc712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7142c86d5677c5c5b0f993beecdc712">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_enqueue_do_nothing_extra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_enqueue_do_nothing_extra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the do nothing enqueue callout in the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="ga3094c6721a6db2468884cfb502263d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3094c6721a6db2468884cfb502263d36">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_enqueue_timeout_monotonic_timespec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_enqueue_timeout_monotonic_timespec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the enqueue callout to add an absolute monotonic timeout in timespec format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abstime</td><td>The absolute monotonic timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="gab148af32965cdef1887db52409f7ee86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab148af32965cdef1887db52409f7ee86">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_enqueue_timeout_realtime_timespec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_enqueue_timeout_realtime_timespec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the enqueue callout to add an absolute realtime timeout in timespec format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abstime</td><td>The absolute realtime timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="ga539935c21bc9e51bd27d64eb8f2ea26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539935c21bc9e51bd27d64eb8f2ea26c">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_enqueue_timeout_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_enqueue_timeout_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreWatchdog.html#gaa1834fd7531ca9bb5c4ca6fd990388d5">Watchdog_Interval</a>&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the enqueue callout to add a relative monotonic timeout in ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ticks</td><td>The timeout in ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="ga076b043e2ddbb7500429a733cac31f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076b043e2ddbb7500429a733cac31f1f">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_ISR_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_ISR_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreISR.html#gad1af728587ebcefec5b5cf94fc7909b9">ISR_Level</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the thread queue context ISR level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context to set the ISR level of. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">level</td><td>The ISR level to set <em>queue_context</em> to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab31678d367077d484797bc9c4d97574e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab31678d367077d484797bc9c4d97574e">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_thread_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_thread_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td>
          <td class="paramname"><em>thread_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the thread state for the thread to enqueue in the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>The thread state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="gaacc8878446de7eef0f3c3f309fafe88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc8878446de7eef0f3c3f309fafe88c">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_timeout_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_timeout_argument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timeout argument in the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arg</td><td>The timeout argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="ga3c130c25dcaf90625f3787a31821c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c130c25dcaf90625f3787a31821c935">&#9670;&nbsp;</a></span>_Thread_queue_Context_set_timeout_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Context_set_timeout_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreWatchdog.html#gaa1834fd7531ca9bb5c4ca6fd990388d5">Watchdog_Interval</a>&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timeout ticks in the thread queue context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ticks</td><td>The timeout in ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a>. </dd></dl>

</div>
</div>
<a id="ga673681292c0f047b02c6dbb6819e0ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673681292c0f047b02c6dbb6819e0ad7">&#9670;&nbsp;</a></span>_Thread_queue_Deadlock_fatal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Deadlock_fatal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Results in an INTERNAL_ERROR_THREAD_QUEUE_DEADLOCK fatal error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread for the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca11db0fbad98d6b0ee9a41139aa7d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca11db0fbad98d6b0ee9a41139aa7d54">&#9670;&nbsp;</a></span>_Thread_queue_Deadlock_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Deadlock_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the thread wait return code to STATUS_DEADLOCK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread</td><td>The thread to set the wait return code to STATUS_DEADLOCK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa59fb38f22e409d05123df6627ead47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa59fb38f22e409d05123df6627ead47a">&#9670;&nbsp;</a></span>_Thread_queue_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the thread queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread_queue</td><td>The thread queue to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8dcef3658d8266b9f66015474e2c88bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dcef3658d8266b9f66015474e2c88bd">&#9670;&nbsp;</a></span>_Thread_queue_Dispatch_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a>* _Thread_queue_Dispatch_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables dispatching in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_context</td><td>The thread queue context to get the lock context from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current processor. </dd></dl>

</div>
</div>
<a id="gaf1488e09cc925566233f2f1fc76c4d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1488e09cc925566233f2f1fc76c4d81">&#9670;&nbsp;</a></span>_Thread_queue_Do_acquire_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Do_acquire_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread queue control in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread_queue</td><td>The thread queue control to acquire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The interrupt lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1671707d42e9a381c3737b58deed97d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1671707d42e9a381c3737b58deed97d5">&#9670;&nbsp;</a></span>_Thread_queue_Do_dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_queue_Do_dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeues the first thread waiting on the thread queue and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread_queue</td><td>The thread queue for the operation. </td></tr>
    <tr><td class="paramname">operations</td><td>The thread queue operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first locked thread. </dd></dl>

</div>
</div>
<a id="ga923d39f206f389ae8a8293e22bae8fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga923d39f206f389ae8a8293e22bae8fbf">&#9670;&nbsp;</a></span>_Thread_queue_Do_release_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Do_release_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread queue control is the owner of the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread_queue</td><td>The thread queue control for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread queue control is the owner of the lock. </td></tr>
    <tr><td class="paramname">false</td><td>The thread queue control is not the owner of the lock.Releases the thread queue control in a critical section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread_queue</td><td>The thread queue control to release. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The interrupt lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4992b40810f6d287c832bdad240dbc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4992b40810f6d287c832bdad240dbc90">&#9670;&nbsp;</a></span>_Thread_queue_Enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the thread and places it on the thread queue. </p>
<p>This enqueues the thread on the thread queue, blocks the thread, and optionally starts the thread timer in case the timeout discipline is not WATCHDOG_NO_TIMEOUT. Timeout discipline and value are in the queue_context.</p>
<p>The caller must be the owner of the thread queue lock. This function will release the thread queue lock and register it as the new thread lock. Thread dispatching is disabled before the thread queue lock is released. Thread dispatching is enabled once the sequence to block the thread is complete. The operation to enqueue the thread on the queue is protected by the thread queue lock. This makes it possible to use the thread queue lock to protect the state of objects embedding the thread queue and directly enter <a class="el" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90" title="Blocks the thread and places it on the thread queue.">_Thread_queue_Enqueue()</a> in case the thread must block.</p>
<p>The thread queue context must be set up with the following functions, otherwise the behaviour is unpredictable</p>
<ul>
<li><a class="el" href="group__RTEMSScoreThreadQueue.html#gab31678d367077d484797bc9c4d97574e" title="Sets the thread state for the thread to enqueue in the thread queue context.">_Thread_queue_Context_set_thread_state()</a>,</li>
<li><a class="el" href="group__RTEMSScoreThreadQueue.html#gae3eded5964733b953ab0a461a9d82f5d" title="Sets the enqueue callout in the thread queue context.">_Thread_queue_Context_set_enqueue_callout()</a> or <a class="el" href="group__RTEMSScoreThreadQueue.html#gaa7142c86d5677c5c5b0f993beecdc712" title="Sets the do nothing enqueue callout in the thread queue context.">_Thread_queue_Context_set_enqueue_do_nothing_extra()</a> or <a class="el" href="group__RTEMSScoreThreadQueue.html#ga539935c21bc9e51bd27d64eb8f2ea26c" title="Sets the enqueue callout to add a relative monotonic timeout in ticks.">_Thread_queue_Context_set_enqueue_timeout_ticks()</a> or <a class="el" href="group__RTEMSScoreThreadQueue.html#ga3094c6721a6db2468884cfb502263d36" title="Sets the enqueue callout to add an absolute monotonic timeout in timespec format.">_Thread_queue_Context_set_enqueue_timeout_monotonic_timespec()</a> or <a class="el" href="group__RTEMSScoreThreadQueue.html#gab148af32965cdef1887db52409f7ee86" title="Sets the enqueue callout to add an absolute realtime timeout in timespec format.">_Thread_queue_Context_set_enqueue_timeout_realtime_timespec()</a>,</li>
<li><a class="el" href="group__RTEMSScoreThreadQueue.html#gab024e7369bc091e53e7bb04ed8ebfb61" title="Sets the deadlock callout in the thread queue context.">_Thread_queue_Context_set_deadlock_callout()</a>.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="threadqimpl_8h.html">rtems/score/threadqimpl.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="statesimpl_8h.html">rtems/score/statesimpl.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define MUTEX_TQ_OPERATIONS &amp;_Thread_queue_Operations_priority</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">  <a class="code" href="structThread__queue__Control.html">Thread_queue_Control</a> Queue;</div><div class="line">} Mutex;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _Mutex_Obtain( Mutex *<a class="code" href="structmutex.html">mutex</a> )</div><div class="line">{</div><div class="line">  <a class="code" href="structThread__queue__Context.html">Thread_queue_Context</a>  queue_context;</div><div class="line">  <a class="code" href="struct__Thread__Control.html">Thread_Control</a>       *executing;</div><div class="line"></div><div class="line">  <a class="code" href="group__RTEMSScoreThreadQueue.html#gae18ee06777084a67d286d743355d47ac">_Thread_queue_Context_initialize</a>( &amp;queue_context );</div><div class="line">  <a class="code" href="group__RTEMSScoreThreadQueue.html#ga40080175681761a842fe6ab4784735b9">_Thread_queue_Acquire</a>( &amp;<a class="code" href="structmutex.html">mutex</a>-&gt;Queue, queue_context );</div><div class="line"></div><div class="line">  executing = _Thread_Executing;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( <a class="code" href="structmutex.html">mutex</a>-&gt;Queue.owner == <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a> ) {</div><div class="line">    <a class="code" href="structmutex.html">mutex</a>-&gt;Queue.owner = executing;</div><div class="line">    <a class="code" href="group__RTEMSScoreThreadQueue.html#ga0a8881ef4106a0707b2751cdd3d18bef">_Thread_queue_Release</a>( &amp;<a class="code" href="structmutex.html">mutex</a>-&gt;Queue, queue_context );</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <a class="code" href="group__RTEMSScoreThreadQueue.html#gab31678d367077d484797bc9c4d97574e">_Thread_queue_Context_set_thread_state</a>(</div><div class="line">      &amp;queue_context,</div><div class="line">      <a class="code" href="group__RTEMSScoreStates.html#gac728552c70b0e8b76c7f97e537346b6e">STATES_WAITING_FOR_MUTEX</a></div><div class="line">    );</div><div class="line">    <a class="code" href="group__RTEMSScoreThreadQueue.html#gaa7142c86d5677c5c5b0f993beecdc712">_Thread_queue_Context_set_enqueue_do_nothing_extra</a>( &amp;queue_context );</div><div class="line">    <a class="code" href="group__RTEMSScoreThreadQueue.html#gab024e7369bc091e53e7bb04ed8ebfb61">_Thread_queue_Context_set_deadlock_callout</a>(</div><div class="line">      queue_context,</div><div class="line">      <a class="code" href="group__RTEMSScoreThreadQueue.html#ga673681292c0f047b02c6dbb6819e0ad7">_Thread_queue_Deadlock_fatal</a></div><div class="line">    );</div><div class="line">    <a class="code" href="group__RTEMSScoreThreadQueue.html#ga4992b40810f6d287c832bdad240dbc90">_Thread_queue_Enqueue</a>(</div><div class="line">      &amp;<a class="code" href="structmutex.html">mutex</a>-&gt;Queue.Queue,</div><div class="line">      MUTEX_TQ_OPERATIONS,</div><div class="line">      executing,</div><div class="line">      &amp;queue_context</div><div class="line">    );</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operations</td><td>The thread queue operations. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to enqueue. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context of the lock acquire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a087492df4bba9c56d8e8018339a84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a087492df4bba9c56d8e8018339a84e">&#9670;&nbsp;</a></span>_Thread_queue_Enqueue_do_nothing_extra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Enqueue_do_nothing_extra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramname">the_thread</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramname">cpu_self</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramname">queue_context</td><td>This parameter is unused. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade3d717e5bef36275e5abd5c9cb0795f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade3d717e5bef36275e5abd5c9cb0795f">&#9670;&nbsp;</a></span>_Thread_queue_Extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts thread from thread queue. </p>
<p>This routine removes <em>the_thread</em> its thread queue and cancels any timeouts associated with this blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The pointer to a thread control block that is to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6ce2524fef09fe93a24196dd392093e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ce2524fef09fe93a24196dd392093e">&#9670;&nbsp;</a></span>_Thread_queue_Extract_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Extract_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the thread from the thread queue and unblocks it. </p>
<p>The caller must be the owner of the thread queue lock. This function will release the thread queue lock and restore the default thread lock. Thread dispatching is disabled before the thread queue lock is released and an unblock is necessary. Thread dispatching is enabled once the sequence to unblock the thread is complete. This makes it possible to use the thread queue lock to protect the state of objects embedding the thread queue and directly enter <a class="el" href="group__RTEMSScoreThreadQueue.html#gaf6ce2524fef09fe93a24196dd392093e" title="Extracts the thread from the thread queue and unblocks it.">_Thread_queue_Extract_critical()</a> to finalize an operation in case a waiting thread exists.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="threadqimpl_8h.html">rtems/score/threadqimpl.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">  <a class="code" href="structThread__queue__Control.html">Thread_queue_Control</a>  Queue;</div><div class="line">  <a class="code" href="struct__Thread__Control.html">Thread_Control</a>       *owner;</div><div class="line">} Mutex;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> _Mutex_Release( Mutex *<a class="code" href="structmutex.html">mutex</a> )</div><div class="line">{</div><div class="line">  <a class="code" href="structThread__queue__Context.html">Thread_queue_Context</a>  queue_context;</div><div class="line">  <a class="code" href="struct__Thread__Control.html">Thread_Control</a>       *first;</div><div class="line"></div><div class="line">  <a class="code" href="group__RTEMSScoreThreadQueue.html#gae18ee06777084a67d286d743355d47ac">_Thread_queue_Context_initialize</a>( &amp;queue_context, <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a> );</div><div class="line">  <a class="code" href="group__RTEMSScoreThreadQueue.html#ga40080175681761a842fe6ab4784735b9">_Thread_queue_Acquire</a>( &amp;<a class="code" href="structmutex.html">mutex</a>-&gt;Queue, queue_context );</div><div class="line"></div><div class="line">  first = <a class="code" href="group__RTEMSScoreThreadQueue.html#gac07672b4b41838966ddf124973f51451">_Thread_queue_First_locked</a>( &amp;<a class="code" href="structmutex.html">mutex</a>-&gt;Queue );</div><div class="line">  <a class="code" href="structmutex.html">mutex</a>-&gt;owner = first;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ( first != <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a> ) {</div><div class="line">    <a class="code" href="group__RTEMSScoreThreadQueue.html#gaf6ce2524fef09fe93a24196dd392093e">_Thread_queue_Extract_critical</a>(</div><div class="line">      &amp;<a class="code" href="structmutex.html">mutex</a>-&gt;Queue.Queue,</div><div class="line">      <a class="code" href="structmutex.html">mutex</a>-&gt;Queue.operations,</div><div class="line">      first,</div><div class="line">      &amp;queue_context</div><div class="line">  );</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operations</td><td>The thread queue operations. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to extract. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context of the lock acquire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91a4a052dcfd0db5df6ff9fa16bbfb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91a4a052dcfd0db5df6ff9fa16bbfb4f">&#9670;&nbsp;</a></span>_Thread_queue_Extract_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Thread_queue_Extract_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the thread from the thread queue, restores the default wait operations and restores the default thread lock. </p>
<p>The caller must be the owner of the thread queue lock. The thread queue lock is not released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operations</td><td>The thread queue operations. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to extract. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the unblock indicator for <a class="el" href="group__RTEMSScoreThreadQueue.html#gae47a7180a4fc9e6e834ec4067e580296" title="Unblocks the thread which was on the thread queue before.">_Thread_queue_Unblock_critical()</a>. True indicates, that this thread must be unblocked by the scheduler later in <a class="el" href="group__RTEMSScoreThreadQueue.html#gae47a7180a4fc9e6e834ec4067e580296" title="Unblocks the thread which was on the thread queue before.">_Thread_queue_Unblock_critical()</a>, and false otherwise. In case false is returned, then the thread queue enqueue procedure was interrupted. Thus it will unblock itself and the thread wait information is no longer accessible, since this thread may already block on another resource in an SMP configuration. </dd></dl>

</div>
</div>
<a id="ga999731e7674266e35751c1afad5a10b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999731e7674266e35751c1afad5a10b3">&#9670;&nbsp;</a></span>_Thread_queue_Extract_with_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Extract_with_proxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the_thread from the_thread_queue. </p>
<p>This routine extracts the_thread from the_thread_queue and ensures that if there is a proxy for this task on another node, it is also dealt with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The pointer to a thread control block that is to be removed</td></tr>
  </table>
  </dd>
</dl>
<p>Extracts the_thread from the_thread_queue.</p>
<p>This routine extracts the_thread from the_thread_queue and ensures that if there is a proxy for this task on another node, it is also dealt with. A proxy is a data data that is on the thread queue on the remote node and acts as a proxy for the local thread. If the local thread was waiting on a remote operation, then the remote side of the operation must be cleaned up. </p>

</div>
</div>
<a id="ga4408cda9750cde6b1d469759762ecb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4408cda9750cde6b1d469759762ecb14">&#9670;&nbsp;</a></span>_Thread_queue_First()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_queue_First </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first thread on the thread queue if it exists, otherwise <code>NULL</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread_queue</td><td>The thread queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">first</td><td>The first thread on the thread queue according to the enqueue order. </td></tr>
    <tr><td class="paramname">NULL</td><td>No thread is present on the thread queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac07672b4b41838966ddf124973f51451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac07672b4b41838966ddf124973f51451">&#9670;&nbsp;</a></span>_Thread_queue_First_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_queue_First_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first thread on the thread queue if it exists, otherwise <code>NULL</code>. </p>
<p>The caller must be the owner of the thread queue lock. The thread queue lock is not released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread_queue</td><td>The thread queue. </td></tr>
    <tr><td class="paramname">operations</td><td>The thread queue operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">first</td><td>The first thread on the thread queue according to the enqueue order. </td></tr>
    <tr><td class="paramname">NULL</td><td>No thread is present on the thread queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac979e73bbbb59a3157ebd782ff70df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac979e73bbbb59a3157ebd782ff70df0c">&#9670;&nbsp;</a></span>_Thread_queue_Flush_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _Thread_queue_Flush_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThreadQueue.html#ga66aee78bfdca4bd829cdedf18e7c2451">Thread_queue_Flush_filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblocks all threads enqueued on the thread queue. </p>
<p>This function iteratively extracts the first enqueued thread of the thread queue until the thread queue is empty or the filter function indicates a stop. The thread timers of the extracted threads are cancelled. The extracted threads are unblocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramname">operations</td><td>The thread queue operations. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter functions is called for each thread to extract from the thread queue. It may be used to alter the thread under protection of the thread queue lock, for example to set the thread wait return code. The return value of the filter function controls if the thread queue flush operation should stop or continue. </td></tr>
    <tr><td class="paramname">queue_context</td><td>The thread queue context of the lock acquire. May be used to pass additional data to the filter function via an overlay structure. The filter function should not release or acquire the thread queue lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The count of extracted threads. </dd></dl>

</div>
</div>
<a id="gaf7ba9f035005918f0e5eca4a3cfc92a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7ba9f035005918f0e5eca4a3cfc92a1">&#9670;&nbsp;</a></span>_Thread_queue_Flush_default_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_queue_Flush_default_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default thread queue flush filter function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to extract. </td></tr>
    <tr><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramname">queue_context</td><td>This parameter is unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">the_thread</td><td>Extract this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac33b5b4a755484ecff2e1f72a56be373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac33b5b4a755484ecff2e1f72a56be373">&#9670;&nbsp;</a></span>_Thread_queue_Flush_status_object_was_deleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_queue_Flush_status_object_was_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status object was deleted thread queue flush filter function. </p>
<p>Sets the thread wait return code of the thread to STATUS_OBJECT_WAS_DELETED</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread</td><td>The thread to extract. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>This parameter is unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">the_thread</td><td>Extract this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafffea388b0a89cc1ba6540a73477130c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafffea388b0a89cc1ba6540a73477130c">&#9670;&nbsp;</a></span>_Thread_queue_Flush_status_unavailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_queue_Flush_status_unavailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status unavailable thread queue flush filter function. </p>
<p>Sets the thread wait return code of the thread to STATUS_UNAVAILABLE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread</td><td>The thread to extract. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>This parameter is unused. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>This parameter is unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">the_thread</td><td>Extract this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed8b973ae28379dbf863c01f10c993f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed8b973ae28379dbf863c01f10c993f3">&#9670;&nbsp;</a></span>_Thread_queue_Heads_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Heads_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *&#160;</td>
          <td class="paramname"><em>heads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the thread queue heads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">heads</td><td>The thread queue heads to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae839c93467db7f3bb1776323a17ac8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae839c93467db7f3bb1776323a17ac8ad">&#9670;&nbsp;</a></span>_Thread_queue_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the thread queue control to the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread_queue</td><td>The thread queue control to initialize. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The name for <em>the_thread_queue</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35b6fa511ba7c3c55a3afb91cc7b0cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b6fa511ba7c3c55a3afb91cc7b0cfb">&#9670;&nbsp;</a></span>_Thread_queue_Is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_queue_Is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread queue queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The thread queue for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>queue</em> is empty. </td></tr>
    <tr><td class="paramname">false</td><td><em>queue</em> is not empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadff2605d33f07f210c22844f1ae71eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff2605d33f07f210c22844f1ae71eaf">&#9670;&nbsp;</a></span>_Thread_queue_Object_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Object_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a thread queue embedded in an object with identifier. </p>
<p>The object must have the layout specified by <a class="el" href="structThread__queue__Object.html" title="Does nothing.">Thread_queue_Object</a>. It should be ensured with the THREAD_QUEUE_OBJECT_ASSERT() static assertion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread_queue</td><td>The thread queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca9472b4bf5091cab34d1a4099e4cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9472b4bf5091cab34d1a4099e4cfa6">&#9670;&nbsp;</a></span>_Thread_queue_Queue_do_acquire_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Queue_do_acquire_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread queue queue in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The thread queue queue to acquire in a critical section. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lock_stats</td><td>The lock statistics. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The interrupt lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac17ae1a1c80b80869cac13c6c8bb9ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17ae1a1c80b80869cac13c6c8bb9ade">&#9670;&nbsp;</a></span>_Thread_queue_Queue_get_name_and_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _Thread_queue_Queue_get_name_and_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the thread queue name to the specified buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer for the thread queue name copy. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>The buffer size in characters. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>The object identifier in case the thread queue is embedded in an object with identifier, otherwise it is set to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the thread queue name. May be greater than or equal to the buffer size if truncation occurred. </dd></dl>

</div>
</div>
<a id="ga9bf4b585322581d70c742c7292bc8435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bf4b585322581d70c742c7292bc8435">&#9670;&nbsp;</a></span>_Thread_queue_Queue_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Queue_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the thread queue queue with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>The thread queue queue to initialize. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The name for the <em>queue</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5074d780cc6e486c858a564e0406f647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5074d780cc6e486c858a564e0406f647">&#9670;&nbsp;</a></span>_Thread_queue_Queue_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Queue_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread queue queue and enables interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The thread queue queue to release. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The interrupt lock context to enable interrupts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf210496afecfdf44064e41e8a83950ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf210496afecfdf44064e41e8a83950ea">&#9670;&nbsp;</a></span>_Thread_queue_Queue_release_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Queue_release_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread queue queue in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The thread queue queue to release in a critical section. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The interrupt lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a8881ef4106a0707b2751cdd3d18bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a8881ef4106a0707b2751cdd3d18bef">&#9670;&nbsp;</a></span>_Thread_queue_Release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread queue control and enables interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread_queue</td><td>The thread queue control to release. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f0796c03f91beaa6caa842433122bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0796c03f91beaa6caa842433122bab">&#9670;&nbsp;</a></span>_Thread_queue_Release_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_queue_Release_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Control.html">Thread_queue_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread queue control in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread_queue</td><td>The thread queue control to release. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f163fd4e89b8ea38e05e2faf4b065cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f163fd4e89b8ea38e05e2faf4b065cf">&#9670;&nbsp;</a></span>_Thread_queue_Surrender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Surrender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> *&#160;</td>
          <td class="paramname"><em>heads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>previous_owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surrenders the thread queue previously owned by the thread to the first enqueued thread. </p>
<p>The owner of the thread queue must be set to NULL by the caller.</p>
<p>This function releases the thread queue lock. In addition it performs a thread dispatch if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">heads</td><td>The thread queue heads. It must not be NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">previous_owner</td><td>The previous owner thread surrendering the thread queue. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context of the lock acquire. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operations</td><td>The thread queue operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae47a7180a4fc9e6e834ec4067e580296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae47a7180a4fc9e6e834ec4067e580296">&#9670;&nbsp;</a></span>_Thread_queue_Unblock_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_queue_Unblock_critical </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblocks the thread which was on the thread queue before. </p>
<p>The caller must be the owner of the thread queue lock. This function will release the thread queue lock. Thread dispatching is disabled before the thread queue lock is released and an unblock is necessary. Thread dispatching is enabled once the sequence to unblock the thread is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">unblock</td><td>The unblock indicator returned by <a class="el" href="group__RTEMSScoreThreadQueue.html#ga91a4a052dcfd0db5df6ff9fa16bbfb4f" title="Extracts the thread from the thread queue, restores the default wait operations and restores the defa...">_Thread_queue_Extract_locked()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The actual thread queue. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to extract. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock_context</td><td>The lock context of the lock acquire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaa050ed6bbc86ca717c26cd68b93a49b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa050ed6bbc86ca717c26cd68b93a49b7">&#9670;&nbsp;</a></span>_Thread_queue_Object_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char _Thread_queue_Object_name[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The special thread queue name to indicated that the thread queue is embedded in an object with identifier. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThreadQueue.html#gadff2605d33f07f210c22844f1ae71eaf" title="Initializes a thread queue embedded in an object with identifier.">_Thread_queue_Object_initialize()</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
