<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTEMS: Heap Handler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtemslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTEMS
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Heap Handler<div class="ingroups"><a class="el" href="group__RTEMSInternal.html">Internal</a> &raquo; <a class="el" href="group__RTEMSScore.html">SuperCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Heap Handler provides a heap.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__RTEMSScoreProtHeap"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreProtHeap.html">Protected Heap Handler</a></td></tr>
<tr class="memdesc:group__RTEMSScoreProtHeap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides protected heap services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:heap_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8h.html">heap.h</a></td></tr>
<tr class="memdesc:heap_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapimpl_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapimpl_8h.html">heapimpl.h</a></td></tr>
<tr class="memdesc:heapimpl_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler Implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapinfo_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapinfo_8h.html">heapinfo.h</a></td></tr>
<tr class="memdesc:heapinfo_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler Information API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heap_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html">heap.c</a></td></tr>
<tr class="memdesc:heap_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapallocate_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapallocate_8c.html">heapallocate.c</a></td></tr>
<tr class="memdesc:heapallocate_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapextend_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapextend_8c.html">heapextend.c</a></td></tr>
<tr class="memdesc:heapextend_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapfree_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapfree_8c.html">heapfree.c</a></td></tr>
<tr class="memdesc:heapfree_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapgetfreeinfo_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapgetfreeinfo_8c.html">heapgetfreeinfo.c</a></td></tr>
<tr class="memdesc:heapgetfreeinfo_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapgetinfo_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapgetinfo_8c.html">heapgetinfo.c</a></td></tr>
<tr class="memdesc:heapgetinfo_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapgreedy_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapgreedy_8c.html">heapgreedy.c</a></td></tr>
<tr class="memdesc:heapgreedy_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapiterate_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapiterate_8c.html">heapiterate.c</a></td></tr>
<tr class="memdesc:heapiterate_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__RTEMSScoreHeap.html#ga568d8a3b62e8b4b060940770bdeee254" title="Iterates over all blocks of the heap.">_Heap_Iterate()</a> implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapnoextend_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapnoextend_8c.html">heapnoextend.c</a></td></tr>
<tr class="memdesc:heapnoextend_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapresizeblock_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapresizeblock_8c.html">heapresizeblock.c</a></td></tr>
<tr class="memdesc:heapresizeblock_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapsizeofuserarea_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapsizeofuserarea_8c.html">heapsizeofuserarea.c</a></td></tr>
<tr class="memdesc:heapsizeofuserarea_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:heapwalk_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heapwalk_8c.html">heapwalk.c</a></td></tr>
<tr class="memdesc:heapwalk_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap Handler implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Error__context.html">Heap_Error_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context of a heap error.  <a href="structHeap__Error__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Block.html">Heap_Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description for free or used blocks.  <a href="structHeap__Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Control.html">Heap_Control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control block used to manage a heap.  <a href="structHeap__Control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Area.html">Heap_Area</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap area structure for table based heap initialization and extension.  <a href="structHeap__Area.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Statistics.html">Heap_Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-time heap statistics.  <a href="structHeap__Statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Information.html">Heap_Information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about blocks.  <a href="structHeap__Information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeap__Information__block.html">Heap_Information_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information block returned by <a class="el" href="group__RTEMSScoreHeap.html#ga5ee6c8f0dfa456002f117bb202b5c9a6" title="Returns information about used and free blocks for the heap.">_Heap_Get_information()</a>.  <a href="structHeap__Information__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga833b1a69c25ba6db27d6898181e071b8"><td class="memItemLeft" align="right" valign="top"><a id="ga833b1a69c25ba6db27d6898181e071b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HEAP_PROTECTION_HEADER_SIZE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga833b1a69c25ba6db27d6898181e071b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b33e85598957dd367de0f3677261f0"><td class="memItemLeft" align="right" valign="top"><a id="ga42b33e85598957dd367de0f3677261f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga42b33e85598957dd367de0f3677261f0">HEAP_BLOCK_HEADER_SIZE</a>&#160;&#160;&#160;(2 * sizeof(uintptr_t) + HEAP_PROTECTION_HEADER_SIZE)</td></tr>
<tr class="memdesc:ga42b33e85598957dd367de0f3677261f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The block header consists of the two size fields (<a class="el" href="structHeap__Block.html#ac19e44024599b1042cc628ccfd3abf53">Heap_Block::prev_size</a> and <a class="el" href="structHeap__Block.html#ae6f771ed25f18d98146417d7cf38d69c">Heap_Block::size_and_flag</a>). <br /></td></tr>
<tr class="separator:ga42b33e85598957dd367de0f3677261f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70ff8f1aa0b373fc4d677f43486bc98"><td class="memItemLeft" align="right" valign="top"><a id="gad70ff8f1aa0b373fc4d677f43486bc98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gad70ff8f1aa0b373fc4d677f43486bc98">HEAP_PREV_BLOCK_USED</a>&#160;&#160;&#160;((uintptr_t) 1)</td></tr>
<tr class="memdesc:gad70ff8f1aa0b373fc4d677f43486bc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">See also <a class="el" href="structHeap__Block.html#ae6f771ed25f18d98146417d7cf38d69c">Heap_Block::size_and_flag</a>. <br /></td></tr>
<tr class="separator:gad70ff8f1aa0b373fc4d677f43486bc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cfb70eb561f94b43e4271829bebab99"><td class="memItemLeft" align="right" valign="top"><a id="ga7cfb70eb561f94b43e4271829bebab99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga7cfb70eb561f94b43e4271829bebab99">HEAP_ALLOC_BONUS</a>&#160;&#160;&#160;sizeof(uintptr_t)</td></tr>
<tr class="memdesc:ga7cfb70eb561f94b43e4271829bebab99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the part at the block begin which may be used for allocation in charge of the previous block. <br /></td></tr>
<tr class="separator:ga7cfb70eb561f94b43e4271829bebab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb082c4ced17a7121ee138d67eb9cb00"><td class="memItemLeft" align="right" valign="top"><a id="gadb082c4ced17a7121ee138d67eb9cb00"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_Heap_Protection_block_initialize</b>(heap,  block)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="separator:gadb082c4ced17a7121ee138d67eb9cb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e44f410cdcf41d8f5de50ce1adc0636"><td class="memItemLeft" align="right" valign="top"><a id="ga0e44f410cdcf41d8f5de50ce1adc0636"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_Heap_Protection_block_check</b>(heap,  block)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="separator:ga0e44f410cdcf41d8f5de50ce1adc0636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a119c32e50ac5070ddcccd7d42ed011"><td class="memItemLeft" align="right" valign="top"><a id="ga5a119c32e50ac5070ddcccd7d42ed011"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_Heap_Protection_block_error</b>(heap,  block,  reason)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="separator:ga5a119c32e50ac5070ddcccd7d42ed011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940a2498486040631e4c009f99ad3f7c"><td class="memItemLeft" align="right" valign="top"><a id="ga940a2498486040631e4c009f99ad3f7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_Heap_Protection_free_all_delayed_blocks</b>(heap)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="separator:ga940a2498486040631e4c009f99ad3f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6524914ddb953be87872b2ed91ad05f"><td class="memItemLeft" align="right" valign="top"><a id="gad6524914ddb953be87872b2ed91ad05f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_HAssert</b>(cond)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="separator:gad6524914ddb953be87872b2ed91ad05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3efd1e74160003a73c2e4d875f0eee4e"><td class="memItemLeft" align="right" valign="top"><a id="ga3efd1e74160003a73c2e4d875f0eee4e"></a>
typedef struct <a class="el" href="structHeap__Control.html">Heap_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Heap_Control</b></td></tr>
<tr class="separator:ga3efd1e74160003a73c2e4d875f0eee4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218cc5fc882bff932b75fc65341a0bbe"><td class="memItemLeft" align="right" valign="top"><a id="ga218cc5fc882bff932b75fc65341a0bbe"></a>
typedef struct <a class="el" href="structHeap__Block.html">Heap_Block</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Heap_Block</b></td></tr>
<tr class="separator:ga218cc5fc882bff932b75fc65341a0bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8953b692d39ca1c8a2780e9e8e2d9b1f"><td class="memItemLeft" align="right" valign="top">typedef uintptr_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga8953b692d39ca1c8a2780e9e8e2d9b1f">Heap_Initialization_or_extend_handler</a>) (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *area_begin, uintptr_t area_size, uintptr_t page_size_or_unused)</td></tr>
<tr class="memdesc:ga8953b692d39ca1c8a2780e9e8e2d9b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap initialization and extend handler type.  <a href="#ga8953b692d39ca1c8a2780e9e8e2d9b1f">More...</a><br /></td></tr>
<tr class="separator:ga8953b692d39ca1c8a2780e9e8e2d9b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5fc026bfabc31c620545e574d579b64"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gab5fc026bfabc31c620545e574d579b64">Heap_Block_visitor</a>) (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block, uintptr_t block_size, bool block_is_used, void *visitor_arg)</td></tr>
<tr class="memdesc:gab5fc026bfabc31c620545e574d579b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap block visitor.  <a href="#gab5fc026bfabc31c620545e574d579b64">More...</a><br /></td></tr>
<tr class="separator:gab5fc026bfabc31c620545e574d579b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9f62692d135584572333cc6d1759e5e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga9f62692d135584572333cc6d1759e5e4">Heap_Error_reason</a> { <br />
&#160;&#160;<a class="el" href="group__RTEMSScoreHeap.html#gga9f62692d135584572333cc6d1759e5e4ac63d3bd4d7901840f92555406bf0c98f">HEAP_ERROR_BROKEN_PROTECTOR</a>, 
<a class="el" href="group__RTEMSScoreHeap.html#gga9f62692d135584572333cc6d1759e5e4afb6094258c33a4c129972f5b7295bbaf">HEAP_ERROR_FREE_PATTERN</a>, 
<a class="el" href="group__RTEMSScoreHeap.html#gga9f62692d135584572333cc6d1759e5e4ae79a312b7fc1f5e0ee8c31a7f85c1e0a">HEAP_ERROR_DOUBLE_FREE</a>, 
<a class="el" href="group__RTEMSScoreHeap.html#gga9f62692d135584572333cc6d1759e5e4a27e8fabd5846f9b48df3a6e31484a142">HEAP_ERROR_BAD_USED_BLOCK</a>, 
<br />
&#160;&#160;<a class="el" href="group__RTEMSScoreHeap.html#gga9f62692d135584572333cc6d1759e5e4aed114f40b13a7bc4ac394bdd017e667d">HEAP_ERROR_BAD_FREE_BLOCK</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9f62692d135584572333cc6d1759e5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heap error reason.  <a href="group__RTEMSScoreHeap.html#ga9f62692d135584572333cc6d1759e5e4">More...</a><br /></td></tr>
<tr class="separator:ga9f62692d135584572333cc6d1759e5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2cffc99d60d783b92e79fd412d1cbdc"><td class="memItemLeft" align="right" valign="top"><a id="gac2cffc99d60d783b92e79fd412d1cbdc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gac2cffc99d60d783b92e79fd412d1cbdc">Heap_Resize_status</a> { <b>HEAP_RESIZE_SUCCESSFUL</b>, 
<b>HEAP_RESIZE_UNSATISFIED</b>, 
<b>HEAP_RESIZE_FATAL_ERROR</b>
 }</td></tr>
<tr class="memdesc:gac2cffc99d60d783b92e79fd412d1cbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__RTEMSScoreHeap.html#ga89495f3d0b1206d098d2733d37c1610e" title="Resizes the block of the allocated memory area.">_Heap_Resize_block()</a>. <br /></td></tr>
<tr class="separator:gac2cffc99d60d783b92e79fd412d1cbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7484f40d81ae26a7f5b3773a2dd006be"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga7484f40d81ae26a7f5b3773a2dd006be">_Heap_Extend</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *area_begin, uintptr_t area_size, uintptr_t unused)</td></tr>
<tr class="memdesc:ga7484f40d81ae26a7f5b3773a2dd006be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the memory available for the heap.  <a href="#ga7484f40d81ae26a7f5b3773a2dd006be">More...</a><br /></td></tr>
<tr class="separator:ga7484f40d81ae26a7f5b3773a2dd006be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c79fc0ef24f7bff393aedccff17a29"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga34c79fc0ef24f7bff393aedccff17a29">_Heap_No_extend</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *unused_0, void *unused_1, uintptr_t unused_2, uintptr_t unused_3)</td></tr>
<tr class="memdesc:ga34c79fc0ef24f7bff393aedccff17a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns always zero.  <a href="#ga34c79fc0ef24f7bff393aedccff17a29">More...</a><br /></td></tr>
<tr class="separator:ga34c79fc0ef24f7bff393aedccff17a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5">_Heap_Align_up</a> (uintptr_t value, uintptr_t alignment)</td></tr>
<tr class="memdesc:gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the value to a given alignment, rounding up.  <a href="#gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5">More...</a><br /></td></tr>
<tr class="separator:gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ed70e7cf8e99037c356772c927eaee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga54ed70e7cf8e99037c356772c927eaee">_Heap_Min_block_size</a> (uintptr_t page_size)</td></tr>
<tr class="memdesc:ga54ed70e7cf8e99037c356772c927eaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimal Heap Block size for the given page_size.  <a href="#ga54ed70e7cf8e99037c356772c927eaee">More...</a><br /></td></tr>
<tr class="separator:ga54ed70e7cf8e99037c356772c927eaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4fd1c467f6288c7c7501e99b8446e27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gaa4fd1c467f6288c7c7501e99b8446e27">_Heap_Area_overhead</a> (uintptr_t page_size)</td></tr>
<tr class="memdesc:gaa4fd1c467f6288c7c7501e99b8446e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the worst case overhead to manage a memory area.  <a href="#gaa4fd1c467f6288c7c7501e99b8446e27">More...</a><br /></td></tr>
<tr class="separator:gaa4fd1c467f6288c7c7501e99b8446e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d53e87789012f59ec95f97911f3f8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga00d53e87789012f59ec95f97911f3f8b">_Heap_Size_with_overhead</a> (uintptr_t page_size, uintptr_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>, uintptr_t alignment)</td></tr>
<tr class="memdesc:ga00d53e87789012f59ec95f97911f3f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size with administration and alignment overhead for one allocation.  <a href="#ga00d53e87789012f59ec95f97911f3f8b">More...</a><br /></td></tr>
<tr class="separator:ga00d53e87789012f59ec95f97911f3f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ce1fc13ec844eaccf67486e290324b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga31ce1fc13ec844eaccf67486e290324b">_Heap_Get_first_and_last_block</a> (uintptr_t heap_area_begin, uintptr_t heap_area_size, uintptr_t page_size, uintptr_t min_block_size, <a class="el" href="structHeap__Block.html">Heap_Block</a> **first_block_ptr, <a class="el" href="structHeap__Block.html">Heap_Block</a> **last_block_ptr)</td></tr>
<tr class="memdesc:ga31ce1fc13ec844eaccf67486e290324b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first and last block for the heap area.  <a href="#ga31ce1fc13ec844eaccf67486e290324b">More...</a><br /></td></tr>
<tr class="separator:ga31ce1fc13ec844eaccf67486e290324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5974c7ccf84c152ba6c8e17bea3ca5f"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gac5974c7ccf84c152ba6c8e17bea3ca5f">_Heap_Initialize</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *area_begin, uintptr_t area_size, uintptr_t page_size)</td></tr>
<tr class="memdesc:gac5974c7ccf84c152ba6c8e17bea3ca5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the heap control block.  <a href="#gac5974c7ccf84c152ba6c8e17bea3ca5f">More...</a><br /></td></tr>
<tr class="separator:gac5974c7ccf84c152ba6c8e17bea3ca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15167f1ad5eb93d85f15adb5e5524ff5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga15167f1ad5eb93d85f15adb5e5524ff5">_Heap_Allocate_aligned_with_boundary</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, uintptr_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>, uintptr_t alignment, uintptr_t boundary)</td></tr>
<tr class="memdesc:ga15167f1ad5eb93d85f15adb5e5524ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an aligned memory area with boundary constraint.  <a href="#ga15167f1ad5eb93d85f15adb5e5524ff5">More...</a><br /></td></tr>
<tr class="separator:ga15167f1ad5eb93d85f15adb5e5524ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951f109f2bfe07c7a769714f97b96a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga951f109f2bfe07c7a769714f97b96a35">_Heap_Allocate_aligned</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, uintptr_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>, uintptr_t alignment)</td></tr>
<tr class="memdesc:ga951f109f2bfe07c7a769714f97b96a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an aligned memory area.  <a href="#ga951f109f2bfe07c7a769714f97b96a35">More...</a><br /></td></tr>
<tr class="separator:ga951f109f2bfe07c7a769714f97b96a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26c02ca60b04b7e5845ec959f6d4330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gad26c02ca60b04b7e5845ec959f6d4330">_Heap_Allocate</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, uintptr_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="memdesc:gad26c02ca60b04b7e5845ec959f6d4330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a memory area.  <a href="#gad26c02ca60b04b7e5845ec959f6d4330">More...</a><br /></td></tr>
<tr class="separator:gad26c02ca60b04b7e5845ec959f6d4330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a1cc19751295ceb71d1d495fa56b39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gab9a1cc19751295ceb71d1d495fa56b39">_Heap_Free</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *addr)</td></tr>
<tr class="memdesc:gab9a1cc19751295ceb71d1d495fa56b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the allocated memory area.  <a href="#gab9a1cc19751295ceb71d1d495fa56b39">More...</a><br /></td></tr>
<tr class="separator:gab9a1cc19751295ceb71d1d495fa56b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914249a9e285bdbd75ea1699a5771a7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga914249a9e285bdbd75ea1699a5771a7a">_Heap_Walk</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, int source, bool dump)</td></tr>
<tr class="memdesc:ga914249a9e285bdbd75ea1699a5771a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the integrity of the heap.  <a href="#ga914249a9e285bdbd75ea1699a5771a7a">More...</a><br /></td></tr>
<tr class="separator:ga914249a9e285bdbd75ea1699a5771a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568d8a3b62e8b4b060940770bdeee254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga568d8a3b62e8b4b060940770bdeee254">_Heap_Iterate</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, <a class="el" href="group__RTEMSScoreHeap.html#gab5fc026bfabc31c620545e574d579b64">Heap_Block_visitor</a> visitor, void *visitor_arg)</td></tr>
<tr class="memdesc:ga568d8a3b62e8b4b060940770bdeee254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all blocks of the heap.  <a href="#ga568d8a3b62e8b4b060940770bdeee254">More...</a><br /></td></tr>
<tr class="separator:ga568d8a3b62e8b4b060940770bdeee254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e5154cbd4e707d42fb39b2e9c565ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gae3e5154cbd4e707d42fb39b2e9c565ff">_Heap_Greedy_allocate</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, const uintptr_t *block_sizes, size_t block_count)</td></tr>
<tr class="memdesc:gae3e5154cbd4e707d42fb39b2e9c565ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily allocates and empties the heap.  <a href="#gae3e5154cbd4e707d42fb39b2e9c565ff">More...</a><br /></td></tr>
<tr class="separator:gae3e5154cbd4e707d42fb39b2e9c565ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7822352d7403927196f2403ec48fc882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga7822352d7403927196f2403ec48fc882">_Heap_Greedy_allocate_all_except_largest</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, uintptr_t *allocatable_size)</td></tr>
<tr class="memdesc:ga7822352d7403927196f2403ec48fc882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedily allocates all blocks except the largest free block.  <a href="#ga7822352d7403927196f2403ec48fc882">More...</a><br /></td></tr>
<tr class="separator:ga7822352d7403927196f2403ec48fc882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01401364d81dc07728aea35aac06e84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga01401364d81dc07728aea35aac06e84d">_Heap_Greedy_free</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, <a class="el" href="structHeap__Block.html">Heap_Block</a> *blocks)</td></tr>
<tr class="memdesc:ga01401364d81dc07728aea35aac06e84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees blocks of a greedy allocation.  <a href="#ga01401364d81dc07728aea35aac06e84d">More...</a><br /></td></tr>
<tr class="separator:ga01401364d81dc07728aea35aac06e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee6c8f0dfa456002f117bb202b5c9a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga5ee6c8f0dfa456002f117bb202b5c9a6">_Heap_Get_information</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, <a class="el" href="structHeap__Information__block.html">Heap_Information_block</a> *info)</td></tr>
<tr class="memdesc:ga5ee6c8f0dfa456002f117bb202b5c9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about used and free blocks for the heap.  <a href="#ga5ee6c8f0dfa456002f117bb202b5c9a6">More...</a><br /></td></tr>
<tr class="separator:ga5ee6c8f0dfa456002f117bb202b5c9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7bc4e8658d953f8b178f4ff6453ec6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gaf7bc4e8658d953f8b178f4ff6453ec6e">_Heap_Get_free_information</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, <a class="el" href="structHeap__Information.html">Heap_Information</a> *info)</td></tr>
<tr class="memdesc:gaf7bc4e8658d953f8b178f4ff6453ec6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about free blocks for the heap.  <a href="#gaf7bc4e8658d953f8b178f4ff6453ec6e">More...</a><br /></td></tr>
<tr class="separator:gaf7bc4e8658d953f8b178f4ff6453ec6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8985839270f72039581fb4ddc44d433a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga8985839270f72039581fb4ddc44d433a">_Heap_Size_of_alloc_area</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *addr, uintptr_t *<a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="memdesc:ga8985839270f72039581fb4ddc44d433a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the allocatable memory area.  <a href="#ga8985839270f72039581fb4ddc44d433a">More...</a><br /></td></tr>
<tr class="separator:ga8985839270f72039581fb4ddc44d433a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89495f3d0b1206d098d2733d37c1610e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreHeap.html#gac2cffc99d60d783b92e79fd412d1cbdc">Heap_Resize_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga89495f3d0b1206d098d2733d37c1610e">_Heap_Resize_block</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *addr, uintptr_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>, uintptr_t *old_size, uintptr_t *new_size)</td></tr>
<tr class="memdesc:ga89495f3d0b1206d098d2733d37c1610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the block of the allocated memory area.  <a href="#ga89495f3d0b1206d098d2733d37c1610e">More...</a><br /></td></tr>
<tr class="separator:ga89495f3d0b1206d098d2733d37c1610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e78547be096281a6f5189402e639cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga4e78547be096281a6f5189402e639cd8">_Heap_Block_allocate</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, <a class="el" href="structHeap__Block.html">Heap_Block</a> *block, uintptr_t alloc_begin, uintptr_t alloc_size)</td></tr>
<tr class="memdesc:ga4e78547be096281a6f5189402e639cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the memory area. starting at <em>alloc_begin</em> of size <em>alloc_size</em> bytes in the block <em>block</em>.  <a href="#ga4e78547be096281a6f5189402e639cd8">More...</a><br /></td></tr>
<tr class="separator:ga4e78547be096281a6f5189402e639cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad616af34405ce4473f9ff3050ce39d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gad616af34405ce4473f9ff3050ce39d90">_Heap_Protection_set_delayed_free_fraction</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, uintptr_t fraction)</td></tr>
<tr class="memdesc:gad616af34405ce4473f9ff3050ce39d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fraction of delayed free blocks that is actually freed during memory shortage.  <a href="#gad616af34405ce4473f9ff3050ce39d90">More...</a><br /></td></tr>
<tr class="separator:gad616af34405ce4473f9ff3050ce39d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860e7959de03ba830d0ebe1b4cca8273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga860e7959de03ba830d0ebe1b4cca8273">_Heap_Free_list_head</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap)</td></tr>
<tr class="memdesc:ga860e7959de03ba830d0ebe1b4cca8273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the head of the free list of the heap.  <a href="#ga860e7959de03ba830d0ebe1b4cca8273">More...</a><br /></td></tr>
<tr class="separator:ga860e7959de03ba830d0ebe1b4cca8273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad25276de4aa987568f1bfc66a0c66700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gad25276de4aa987568f1bfc66a0c66700">_Heap_Free_list_tail</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap)</td></tr>
<tr class="memdesc:gad25276de4aa987568f1bfc66a0c66700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tail of the free list of the heap.  <a href="#gad25276de4aa987568f1bfc66a0c66700">More...</a><br /></td></tr>
<tr class="separator:gad25276de4aa987568f1bfc66a0c66700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0299809a91130b3da718ee889f4fe43d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga0299809a91130b3da718ee889f4fe43d">_Heap_Free_list_first</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap)</td></tr>
<tr class="memdesc:ga0299809a91130b3da718ee889f4fe43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first block of the free list of the heap.  <a href="#ga0299809a91130b3da718ee889f4fe43d">More...</a><br /></td></tr>
<tr class="separator:ga0299809a91130b3da718ee889f4fe43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26aaa1feb8cf3773e5e38a13afcc4efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga26aaa1feb8cf3773e5e38a13afcc4efe">_Heap_Free_list_last</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap)</td></tr>
<tr class="memdesc:ga26aaa1feb8cf3773e5e38a13afcc4efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last block of the free list of the heap.  <a href="#ga26aaa1feb8cf3773e5e38a13afcc4efe">More...</a><br /></td></tr>
<tr class="separator:ga26aaa1feb8cf3773e5e38a13afcc4efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73da7f4190c5ae1af555374509a5e302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga73da7f4190c5ae1af555374509a5e302">_Heap_Free_list_remove</a> (<a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:ga73da7f4190c5ae1af555374509a5e302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the block from the free list.  <a href="#ga73da7f4190c5ae1af555374509a5e302">More...</a><br /></td></tr>
<tr class="separator:ga73da7f4190c5ae1af555374509a5e302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade52dd12ae2cb6570271313e8bd7fdf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gade52dd12ae2cb6570271313e8bd7fdf7">_Heap_Free_list_replace</a> (<a class="el" href="structHeap__Block.html">Heap_Block</a> *old_block, <a class="el" href="structHeap__Block.html">Heap_Block</a> *new_block)</td></tr>
<tr class="memdesc:gade52dd12ae2cb6570271313e8bd7fdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one block in the free list by another.  <a href="#gade52dd12ae2cb6570271313e8bd7fdf7">More...</a><br /></td></tr>
<tr class="separator:gade52dd12ae2cb6570271313e8bd7fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd632ea52e7866d26cd025fb154387b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga7dd632ea52e7866d26cd025fb154387b">_Heap_Free_list_insert_after</a> (<a class="el" href="structHeap__Block.html">Heap_Block</a> *block_before, <a class="el" href="structHeap__Block.html">Heap_Block</a> *new_block)</td></tr>
<tr class="memdesc:ga7dd632ea52e7866d26cd025fb154387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a block after an existing block in the free list.  <a href="#ga7dd632ea52e7866d26cd025fb154387b">More...</a><br /></td></tr>
<tr class="separator:ga7dd632ea52e7866d26cd025fb154387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c27f15a2fb2b9e662eba8e023e02ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga5c27f15a2fb2b9e662eba8e023e02ce8">_Heap_Free_list_insert_before</a> (<a class="el" href="structHeap__Block.html">Heap_Block</a> *block_next, <a class="el" href="structHeap__Block.html">Heap_Block</a> *new_block)</td></tr>
<tr class="memdesc:ga5c27f15a2fb2b9e662eba8e023e02ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a block before an existing block in the free list.  <a href="#ga5c27f15a2fb2b9e662eba8e023e02ce8">More...</a><br /></td></tr>
<tr class="separator:ga5c27f15a2fb2b9e662eba8e023e02ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a21a1797970a73dfe515f3defc5fe8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga6a21a1797970a73dfe515f3defc5fe8d">_Heap_Is_aligned</a> (uintptr_t value, uintptr_t alignment)</td></tr>
<tr class="memdesc:ga6a21a1797970a73dfe515f3defc5fe8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the value is aligned to the given alignment.  <a href="#ga6a21a1797970a73dfe515f3defc5fe8d">More...</a><br /></td></tr>
<tr class="separator:ga6a21a1797970a73dfe515f3defc5fe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b11e4f1b69d3f6197165e4fb7f2e956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga2b11e4f1b69d3f6197165e4fb7f2e956">_Heap_Align_down</a> (uintptr_t value, uintptr_t alignment)</td></tr>
<tr class="memdesc:ga2b11e4f1b69d3f6197165e4fb7f2e956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the aligned value, truncating.  <a href="#ga2b11e4f1b69d3f6197165e4fb7f2e956">More...</a><br /></td></tr>
<tr class="separator:ga2b11e4f1b69d3f6197165e4fb7f2e956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231bdbf1ec3d6b82583d0cc3198fc00b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga231bdbf1ec3d6b82583d0cc3198fc00b">_Heap_Block_at</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block, uintptr_t offset)</td></tr>
<tr class="memdesc:ga231bdbf1ec3d6b82583d0cc3198fc00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block which is <em>offset</em> away from <em>block</em>.  <a href="#ga231bdbf1ec3d6b82583d0cc3198fc00b">More...</a><br /></td></tr>
<tr class="separator:ga231bdbf1ec3d6b82583d0cc3198fc00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f927e073f140a91ccbd846879984de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga1f927e073f140a91ccbd846879984de6">_Heap_Prev_block</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:ga1f927e073f140a91ccbd846879984de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the previous block.  <a href="#ga1f927e073f140a91ccbd846879984de6">More...</a><br /></td></tr>
<tr class="separator:ga1f927e073f140a91ccbd846879984de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2563e03746d89148a8782b02f6159821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga2563e03746d89148a8782b02f6159821">_Heap_Alloc_area_of_block</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:ga2563e03746d89148a8782b02f6159821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first address in the block without the heap header.  <a href="#ga2563e03746d89148a8782b02f6159821">More...</a><br /></td></tr>
<tr class="separator:ga2563e03746d89148a8782b02f6159821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd70a7d05fc0c46a87ff68d759ab3af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gafd70a7d05fc0c46a87ff68d759ab3af3">_Heap_Block_of_alloc_area</a> (uintptr_t alloc_begin, uintptr_t page_size)</td></tr>
<tr class="memdesc:gafd70a7d05fc0c46a87ff68d759ab3af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the starting address of the block corresponding to the allocatable area.  <a href="#gafd70a7d05fc0c46a87ff68d759ab3af3">More...</a><br /></td></tr>
<tr class="separator:gafd70a7d05fc0c46a87ff68d759ab3af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161ac37dea0961191b2698abf0e61841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga161ac37dea0961191b2698abf0e61841">_Heap_Block_size</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:ga161ac37dea0961191b2698abf0e61841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size.  <a href="#ga161ac37dea0961191b2698abf0e61841">More...</a><br /></td></tr>
<tr class="separator:ga161ac37dea0961191b2698abf0e61841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c66d5f866002204674e2639575efc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gaf0c66d5f866002204674e2639575efc3">_Heap_Block_set_size</a> (<a class="el" href="structHeap__Block.html">Heap_Block</a> *block, uintptr_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="memdesc:gaf0c66d5f866002204674e2639575efc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the block size.  <a href="#gaf0c66d5f866002204674e2639575efc3">More...</a><br /></td></tr>
<tr class="separator:gaf0c66d5f866002204674e2639575efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88e4681224e360888f3f4bd020c97a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gad88e4681224e360888f3f4bd020c97a9">_Heap_Is_prev_used</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:gad88e4681224e360888f3f4bd020c97a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the previous heap block is used.  <a href="#gad88e4681224e360888f3f4bd020c97a9">More...</a><br /></td></tr>
<tr class="separator:gad88e4681224e360888f3f4bd020c97a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7108eed881e09dc3519e8a35220f0feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga7108eed881e09dc3519e8a35220f0feb">_Heap_Is_used</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:ga7108eed881e09dc3519e8a35220f0feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the heap block is used.  <a href="#ga7108eed881e09dc3519e8a35220f0feb">More...</a><br /></td></tr>
<tr class="separator:ga7108eed881e09dc3519e8a35220f0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a216779de2fa37926f7cba5d8342dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gae9a216779de2fa37926f7cba5d8342dd">_Heap_Is_free</a> (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:gae9a216779de2fa37926f7cba5d8342dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the heap block is free.  <a href="#gae9a216779de2fa37926f7cba5d8342dd">More...</a><br /></td></tr>
<tr class="separator:gae9a216779de2fa37926f7cba5d8342dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc511a89a627aea2d91fbc21b95a4ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gabc511a89a627aea2d91fbc21b95a4ae7">_Heap_Is_block_in_heap</a> (const <a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block)</td></tr>
<tr class="memdesc:gabc511a89a627aea2d91fbc21b95a4ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the block is part of the heap.  <a href="#gabc511a89a627aea2d91fbc21b95a4ae7">More...</a><br /></td></tr>
<tr class="separator:gabc511a89a627aea2d91fbc21b95a4ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95a9dbdca32f811e64b2bedf4f74ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#gaf95a9dbdca32f811e64b2bedf4f74ff3">_Heap_Set_last_block_size</a> (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap)</td></tr>
<tr class="memdesc:gaf95a9dbdca32f811e64b2bedf4f74ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the last block for the heap.  <a href="#gaf95a9dbdca32f811e64b2bedf4f74ff3">More...</a><br /></td></tr>
<tr class="separator:gaf95a9dbdca32f811e64b2bedf4f74ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4942bc8727061905343458c29ad01282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga4942bc8727061905343458c29ad01282">_Heap_Get_size</a> (const <a class="el" href="structHeap__Control.html">Heap_Control</a> *heap)</td></tr>
<tr class="memdesc:ga4942bc8727061905343458c29ad01282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the allocatable area in bytes.  <a href="#ga4942bc8727061905343458c29ad01282">More...</a><br /></td></tr>
<tr class="separator:ga4942bc8727061905343458c29ad01282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ce876152e1f3a06b5caf377c92c9f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga35ce876152e1f3a06b5caf377c92c9f3">_Heap_Max</a> (uintptr_t a, uintptr_t b)</td></tr>
<tr class="memdesc:ga35ce876152e1f3a06b5caf377c92c9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bigger one of the two arguments.  <a href="#ga35ce876152e1f3a06b5caf377c92c9f3">More...</a><br /></td></tr>
<tr class="separator:ga35ce876152e1f3a06b5caf377c92c9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb0b895f87524b8bf4e7fe7c1b41da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreHeap.html#ga09fb0b895f87524b8bf4e7fe7c1b41da">_Heap_Min</a> (uintptr_t a, uintptr_t b)</td></tr>
<tr class="memdesc:ga09fb0b895f87524b8bf4e7fe7c1b41da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller one of the two arguments.  <a href="#ga09fb0b895f87524b8bf4e7fe7c1b41da">More...</a><br /></td></tr>
<tr class="separator:ga09fb0b895f87524b8bf4e7fe7c1b41da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Heap Handler provides a heap. </p>
<p>A heap is a doubly linked list of variable size blocks which are allocated using the first fit method. Garbage collection is performed each time a block is returned to the heap by coalescing neighbor blocks. Control information for both allocated and free blocks is contained in the heap area. A heap control structure contains control information for the heap.</p>
<p>The alignment routines could be made faster should we require only powers of two to be supported for page size, alignment and boundary arguments. The minimum alignment requirement for pages is currently CPU_ALIGNMENT and this value is only required to be multiple of two and explicitly not required to be a power of two.</p>
<p>There are two kinds of blocks. One sort describes a free block from which we can allocate memory. The other blocks are used and provide an allocated memory area. The free blocks are accessible via a list of free blocks.</p>
<p>Blocks or areas cover a continuous set of memory addresses. They have a begin and end address. The end address is not part of the set. The size of a block or area equals the distance between the begin and end address in units of bytes.</p>
<p>Free blocks look like: </p><table class="doxtable">
<tr>
<td rowspan="4"><a class="el" href="structHeap__Block.html">Heap_Block</a></td><td>previous block size in case the previous block is free, <br />
 otherwise it may contain data used by the previous block  </td></tr>
<tr>
<td>block size and a flag which indicates if the previous block is free or used, <br />
 this field contains always valid data regardless of the block usage  </td></tr>
<tr>
<td>pointer to next block (this field is page size aligned) </td></tr>
<tr>
<td>pointer to previous block </td></tr>
<tr>
<td colspan="2">free space </td></tr>
</table>
<p>Used blocks look like: </p><table class="doxtable">
<tr>
<td rowspan="4"><a class="el" href="structHeap__Block.html">Heap_Block</a></td><td>previous block size in case the previous block is free,<br />
otherwise it may contain data used by the previous block  </td></tr>
<tr>
<td>block size and a flag which indicates if the previous block is free or used, <br />
 this field contains always valid data regardless of the block usage  </td></tr>
<tr>
<td>begin of allocated area (this field is page size aligned) </td></tr>
<tr>
<td>allocated space </td></tr>
<tr>
<td colspan="2">allocated space </td></tr>
</table>
<p>The heap area after initialization contains two blocks and looks like: </p><table class="doxtable">
<tr>
<th>Label</th><th colspan="2">Content </th></tr>
<tr>
<td>heap-&gt;area_begin</td><td colspan="2">heap area begin address </td></tr>
<tr>
<td>first_block-&gt;prev_size </td><td colspan="2">subordinate heap area end address (this will be used to maintain a linked list of scattered heap areas)   </td></tr>
<tr>
<td>first_block-&gt;size </td><td colspan="2">size available for allocation | <code>HEAP_PREV_BLOCK_USED</code>   </td></tr>
<tr>
<td>first_block-&gt;next</td><td>_Heap_Free_list_tail(heap) </td><td rowspan="3">memory area available for allocation  </td></tr>
<tr>
<td>first_block-&gt;prev</td><td>_Heap_Free_list_head(heap) </td></tr>
<tr>
<td>... </td></tr>
<tr>
<td>last_block-&gt;prev_size</td><td colspan="2">size of first block  </td></tr>
<tr>
<td>last_block-&gt;size </td><td colspan="2">first block begin address - last block begin address  </td></tr>
<tr>
<td>heap-&gt;area_end</td><td colspan="2">heap area end address </td></tr>
</table>
<p>The next block of the last block is the first block. Since the first block indicates that the previous block is used, this ensures that the last block appears as used for the <a class="el" href="group__RTEMSScoreHeap.html#ga7108eed881e09dc3519e8a35220f0feb" title="Returns if the heap block is used.">_Heap_Is_used()</a> and <a class="el" href="group__RTEMSScoreHeap.html#gae9a216779de2fa37926f7cba5d8342dd" title="Returns if the heap block is free.">_Heap_Is_free()</a> functions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab5fc026bfabc31c620545e574d579b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5fc026bfabc31c620545e574d579b64">&#9670;&nbsp;</a></span>Heap_Block_visitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* Heap_Block_visitor) (const <a class="el" href="structHeap__Block.html">Heap_Block</a> *block, uintptr_t block_size, bool block_is_used, void *visitor_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heap block visitor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreHeap.html#ga568d8a3b62e8b4b060940770bdeee254" title="Iterates over all blocks of the heap.">_Heap_Iterate()</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Stop the iteration. </td></tr>
    <tr><td class="paramname">false</td><td>Continue the iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8953b692d39ca1c8a2780e9e8e2d9b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8953b692d39ca1c8a2780e9e8e2d9b1f">&#9670;&nbsp;</a></span>Heap_Initialization_or_extend_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t(* Heap_Initialization_or_extend_handler) (<a class="el" href="structHeap__Control.html">Heap_Control</a> *heap, void *area_begin, uintptr_t area_size, uintptr_t page_size_or_unused)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heap initialization and extend handler type. </p>
<p>This helps to do a table based heap initialization and extension. Create a table of <a class="el" href="structHeap__Area.html" title="Heap area structure for table based heap initialization and extension.">Heap_Area</a> elements and iterate through it. Set the handler to <a class="el" href="group__RTEMSScoreHeap.html#gac5974c7ccf84c152ba6c8e17bea3ca5f" title="Initializes the heap control block.">_Heap_Initialize()</a> in the first iteration and then to <a class="el" href="group__RTEMSScoreHeap.html#ga7484f40d81ae26a7f5b3773a2dd006be" title="Extends the memory available for the heap.">_Heap_Extend()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structHeap__Area.html" title="Heap area structure for table based heap initialization and extension.">Heap_Area</a>, <a class="el" href="group__RTEMSScoreHeap.html#gac5974c7ccf84c152ba6c8e17bea3ca5f" title="Initializes the heap control block.">_Heap_Initialize()</a>, <a class="el" href="group__RTEMSScoreHeap.html#ga7484f40d81ae26a7f5b3773a2dd006be" title="Extends the memory available for the heap.">_Heap_Extend()</a>, or <a class="el" href="group__RTEMSScoreHeap.html#ga34c79fc0ef24f7bff393aedccff17a29" title="This function returns always zero.">_Heap_No_extend()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9f62692d135584572333cc6d1759e5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f62692d135584572333cc6d1759e5e4">&#9670;&nbsp;</a></span>Heap_Error_reason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__RTEMSScoreHeap.html#ga9f62692d135584572333cc6d1759e5e4">Heap_Error_reason</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The heap error reason. </p>
<dl class="section see"><dt>See also</dt><dd>_Heap_Protection_block_error(). </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9f62692d135584572333cc6d1759e5e4ac63d3bd4d7901840f92555406bf0c98f"></a>HEAP_ERROR_BROKEN_PROTECTOR&#160;</td><td class="fielddoc"><p>There is an unexpected value in the heap block protector area. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f62692d135584572333cc6d1759e5e4afb6094258c33a4c129972f5b7295bbaf"></a>HEAP_ERROR_FREE_PATTERN&#160;</td><td class="fielddoc"><p>There is an unexpected value in the free pattern of a free heap block. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f62692d135584572333cc6d1759e5e4ae79a312b7fc1f5e0ee8c31a7f85c1e0a"></a>HEAP_ERROR_DOUBLE_FREE&#160;</td><td class="fielddoc"><p>There is was an attempt to free the same block twice. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f62692d135584572333cc6d1759e5e4a27e8fabd5846f9b48df3a6e31484a142"></a>HEAP_ERROR_BAD_USED_BLOCK&#160;</td><td class="fielddoc"><p>The next block of a supposed to be used block does not indicate that the block is used. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f62692d135584572333cc6d1759e5e4aed114f40b13a7bc4ac394bdd017e667d"></a>HEAP_ERROR_BAD_FREE_BLOCK&#160;</td><td class="fielddoc"><p>A supposed to be free block is not inside the heap memory area. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2b11e4f1b69d3f6197165e4fb7f2e956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b11e4f1b69d3f6197165e4fb7f2e956">&#9670;&nbsp;</a></span>_Heap_Align_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Align_down </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the aligned value, truncating. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be aligned </td></tr>
    <tr><td class="paramname">alignment</td><td>The alignment for the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aligned value, truncated. </dd></dl>

</div>
</div>
<a id="gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c54b3d49cb3fbcf12bbf7a7a45e8d5">&#9670;&nbsp;</a></span>_Heap_Align_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Align_up </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns the value to a given alignment, rounding up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be aligned. </td></tr>
    <tr><td class="paramname">alignment</td><td>The alignment for the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>value</em> aligned to the given <em>alignment</em>, rounded up. </dd></dl>

</div>
</div>
<a id="ga2563e03746d89148a8782b02f6159821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2563e03746d89148a8782b02f6159821">&#9670;&nbsp;</a></span>_Heap_Alloc_area_of_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Alloc_area_of_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first address in the block without the heap header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block for the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first address after the heap header. </dd></dl>

</div>
</div>
<a id="gad26c02ca60b04b7e5845ec959f6d4330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad26c02ca60b04b7e5845ec959f6d4330">&#9670;&nbsp;</a></span>_Heap_Allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void* _Heap_Allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a memory area. </p>
<p>A size value of zero will return a unique address which may be freed with <a class="el" href="group__RTEMSScoreHeap.html#gab9a1cc19751295ceb71d1d495fa56b39" title="Frees the allocated memory area.">_Heap_Free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to allocate a memory are from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>The size of the desired memory are in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>The starting address of the allocated memory area. </td></tr>
    <tr><td class="paramname">NULL</td><td>No memory is available of the parameters are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga951f109f2bfe07c7a769714f97b96a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga951f109f2bfe07c7a769714f97b96a35">&#9670;&nbsp;</a></span>_Heap_Allocate_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void* _Heap_Allocate_aligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an aligned memory area. </p>
<p>A size value of zero will return a unique address which may be freed with <a class="el" href="group__RTEMSScoreHeap.html#gab9a1cc19751295ceb71d1d495fa56b39" title="Frees the allocated memory area.">_Heap_Free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to allocate a memory are from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>The size of the desired memory are in bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alignment</td><td>The allocated memory area will begin at an address aligned by this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>The starting address of the allocated memory area. </td></tr>
    <tr><td class="paramname">NULL</td><td>No memory is available of the parameters are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15167f1ad5eb93d85f15adb5e5524ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15167f1ad5eb93d85f15adb5e5524ff5">&#9670;&nbsp;</a></span>_Heap_Allocate_aligned_with_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _Heap_Allocate_aligned_with_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an aligned memory area with boundary constraint. </p>
<p>A size value of zero will return a unique address which may be freed with <a class="el" href="group__RTEMSScoreHeap.html#gab9a1cc19751295ceb71d1d495fa56b39" title="Frees the allocated memory area.">_Heap_Free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to allocate a memory are from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>The size of the desired memory are in bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alignment</td><td>The allocated memory area will begin at an address aligned by this value. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">boundary</td><td>The allocated memory area will fulfill a boundary constraint, if this value is not equal to zero. The boundary value specifies the set of addresses which are aligned by the boundary value. The interior of the allocated memory area will not contain an element of this set. The begin or end address of the area may be a member of the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>The starting address of the allocated memory area. </td></tr>
    <tr><td class="paramname">NULL</td><td>No memory is available of the parameters are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4fd1c467f6288c7c7501e99b8446e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4fd1c467f6288c7c7501e99b8446e27">&#9670;&nbsp;</a></span>_Heap_Area_overhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Area_overhead </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>page_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the worst case overhead to manage a memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_size</td><td>The page size to calculate the worst case memory manage overhead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The worst case overhead to manage a memory area. </dd></dl>

</div>
</div>
<a id="ga4e78547be096281a6f5189402e639cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e78547be096281a6f5189402e639cd8">&#9670;&nbsp;</a></span>_Heap_Block_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Block_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alloc_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the memory area. starting at <em>alloc_begin</em> of size <em>alloc_size</em> bytes in the block <em>block</em>. </p>
<p>The block may be split up into multiple blocks. The previous and next block may be used or free. Free block parts which form a vaild new block will be inserted into the free list or merged with an adjacent free block. If the block is used, they will be inserted after the free list head. If the block is free, they will be inserted after the previous block in the free list.</p>
<p>Inappropriate values for <em>alloc_begin</em> or <em>alloc_size</em> may corrupt the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to operate upon. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>The block in which the memory area should be allocated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alloc_begin</td><td>The starting address of the memory area that shall be allocated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alloc_size</td><td>The size of the desired allocated area in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block containing the allocated memory area. </dd></dl>

</div>
</div>
<a id="ga231bdbf1ec3d6b82583d0cc3198fc00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga231bdbf1ec3d6b82583d0cc3198fc00b">&#9670;&nbsp;</a></span>_Heap_Block_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Block_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the block which is <em>offset</em> away from <em>block</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block for the relative calculation. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset for the calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the block which is <em>offset</em> away from <em>block</em>. </dd></dl>

</div>
</div>
<a id="gafd70a7d05fc0c46a87ff68d759ab3af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd70a7d05fc0c46a87ff68d759ab3af3">&#9670;&nbsp;</a></span>_Heap_Block_of_alloc_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Block_of_alloc_area </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alloc_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the starting address of the block corresponding to the allocatable area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc_begin</td><td>The starting address of the allocatable area. </td></tr>
    <tr><td class="paramname">page_size</td><td>The page size for the calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Starting address of the corresponding block of the allocatable area. </dd></dl>

</div>
</div>
<a id="gaf0c66d5f866002204674e2639575efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c66d5f866002204674e2639575efc3">&#9670;&nbsp;</a></span>_Heap_Block_set_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Block_set_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>The block of which the size shall be set. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>The new size of the block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga161ac37dea0961191b2698abf0e61841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161ac37dea0961191b2698abf0e61841">&#9670;&nbsp;</a></span>_Heap_Block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Block_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block of which the size is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The block size. </dd></dl>

</div>
</div>
<a id="ga7484f40d81ae26a7f5b3773a2dd006be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7484f40d81ae26a7f5b3773a2dd006be">&#9670;&nbsp;</a></span>_Heap_Extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t _Heap_Extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>area_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>area_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the memory available for the heap. </p>
<p>There are no alignment requirements for the memory area. The memory area must be big enough to contain some maintenance blocks. It must not overlap parts of the current heap memory areas. Disconnected memory areas added to the heap will lead to used blocks which cover the gaps. Extending with an inappropriate memory area will corrupt the heap resulting in undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to extend. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">area_begin</td><td>The start address of the area to extend the <em>heap</em> with. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">area_size</td><td>The size of the area in bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">unused</td><td>Is not used, only provided to have the same signature as <a class="el" href="group__RTEMSScoreHeap.html#gac5974c7ccf84c152ba6c8e17bea3ca5f" title="Initializes the heap control block.">_Heap_Initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">some_value</td><td>The extended space available for allocation after successful extension. </td></tr>
    <tr><td class="paramname">0</td><td>The heap extension failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreHeap.html#ga8953b692d39ca1c8a2780e9e8e2d9b1f" title="Heap initialization and extend handler type.">Heap_Initialization_or_extend_handler</a>. </dd></dl>

</div>
</div>
<a id="gab9a1cc19751295ceb71d1d495fa56b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a1cc19751295ceb71d1d495fa56b39">&#9670;&nbsp;</a></span>_Heap_Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Heap_Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the allocated memory area. </p>
<p>Inappropriate values for <em>addr</em> may corrupt the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap of the allocated memory area. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">addr</td><td>The starting address of the memory area to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The allocated memory area was successfully freed. </td></tr>
    <tr><td class="paramname">false</td><td>The method failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0299809a91130b3da718ee889f4fe43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0299809a91130b3da718ee889f4fe43d">&#9670;&nbsp;</a></span>_Heap_Free_list_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Free_list_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first block of the free list of the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap to operate upon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first block of the free list. </dd></dl>

</div>
</div>
<a id="ga860e7959de03ba830d0ebe1b4cca8273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga860e7959de03ba830d0ebe1b4cca8273">&#9670;&nbsp;</a></span>_Heap_Free_list_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Free_list_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the head of the free list of the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap to operate upon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The head of the free list. </dd></dl>

</div>
</div>
<a id="ga7dd632ea52e7866d26cd025fb154387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dd632ea52e7866d26cd025fb154387b">&#9670;&nbsp;</a></span>_Heap_Free_list_insert_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Free_list_insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block_before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a block after an existing block in the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_before</td><td>The block that is already in the free list. </td></tr>
    <tr><td class="paramname">new_block</td><td>The block to be inserted after <em>block_before</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c27f15a2fb2b9e662eba8e023e02ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c27f15a2fb2b9e662eba8e023e02ce8">&#9670;&nbsp;</a></span>_Heap_Free_list_insert_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Free_list_insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a block before an existing block in the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_before</td><td>The block that is already in the free list. </td></tr>
    <tr><td class="paramname">new_block</td><td>The block to be inserted before <em>block_before</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26aaa1feb8cf3773e5e38a13afcc4efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26aaa1feb8cf3773e5e38a13afcc4efe">&#9670;&nbsp;</a></span>_Heap_Free_list_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Free_list_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last block of the free list of the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap to operate upon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last block of the free list. </dd></dl>

</div>
</div>
<a id="ga73da7f4190c5ae1af555374509a5e302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73da7f4190c5ae1af555374509a5e302">&#9670;&nbsp;</a></span>_Heap_Free_list_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Free_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the block from the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade52dd12ae2cb6570271313e8bd7fdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade52dd12ae2cb6570271313e8bd7fdf7">&#9670;&nbsp;</a></span>_Heap_Free_list_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Free_list_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>old_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one block in the free list by another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_block</td><td>The block in the free list to replace. </td></tr>
    <tr><td class="paramname">new_block</td><td>The block that should replace <em>old_block</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad25276de4aa987568f1bfc66a0c66700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad25276de4aa987568f1bfc66a0c66700">&#9670;&nbsp;</a></span>_Heap_Free_list_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Free_list_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tail of the free list of the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap to operate upon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tail of the free list. </dd></dl>

</div>
</div>
<a id="ga31ce1fc13ec844eaccf67486e290324b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ce1fc13ec844eaccf67486e290324b">&#9670;&nbsp;</a></span>_Heap_Get_first_and_last_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Heap_Get_first_and_last_block </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>heap_area_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>heap_area_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>min_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> **&#160;</td>
          <td class="paramname"><em>first_block_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> **&#160;</td>
          <td class="paramname"><em>last_block_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first and last block for the heap area. </p>
<p>Nothing will be written to this area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">heap_area_begin</td><td>The starting address of the heap area. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">heap_area_size</td><td>The size of the heap area. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">page_size</td><td>The page size for the calculation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">min_block_size</td><td>The minimal block size for the calculation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_block_ptr</td><td>The pointer to the first block in the case of success </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">last_block_ptr</td><td>The pointer to the last block in the case of success</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The area is big enough. </td></tr>
    <tr><td class="paramname">false</td><td>The area is not big enough. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7bc4e8658d953f8b178f4ff6453ec6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7bc4e8658d953f8b178f4ff6453ec6e">&#9670;&nbsp;</a></span>_Heap_Get_free_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Heap_Get_free_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Information.html">Heap_Information</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information about free blocks for the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">heap</td><td>The heap to get the information from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Stores the information about free blocks of <em>heap</em> after the method call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ee6c8f0dfa456002f117bb202b5c9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee6c8f0dfa456002f117bb202b5c9a6">&#9670;&nbsp;</a></span>_Heap_Get_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Heap_Get_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Information__block.html">Heap_Information_block</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information about used and free blocks for the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">heap</td><td>The heap to get the information from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Stores the information of the <em>heap</em> after the method call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4942bc8727061905343458c29ad01282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4942bc8727061905343458c29ad01282">&#9670;&nbsp;</a></span>_Heap_Get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the allocatable area in bytes. </p>
<p>This value is an integral multiple of the page size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap to get the allocatable area from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the allocatable area in <em>heap</em> in bytes. </dd></dl>

</div>
</div>
<a id="gae3e5154cbd4e707d42fb39b2e9c565ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e5154cbd4e707d42fb39b2e9c565ff">&#9670;&nbsp;</a></span>_Heap_Greedy_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Greedy_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uintptr_t *&#160;</td>
          <td class="paramname"><em>block_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedily allocates and empties the heap. </p>
<p>Afterwards, the heap has at most <em>block_count</em> allocatable blocks of sizes specified by <em>block_sizes</em>. All other blocks are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to operate upon </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_sizes</td><td>The sizes of the allocatable blocks. Must point to an array with <em>block_count</em> members. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">block_count</td><td>The maximum number of allocatable blocks of sizes specified by @block_sizes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first allocated block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreHeap.html#ga01401364d81dc07728aea35aac06e84d" title="Frees blocks of a greedy allocation.">_Heap_Greedy_free()</a>. </dd></dl>

</div>
</div>
<a id="ga7822352d7403927196f2403ec48fc882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7822352d7403927196f2403ec48fc882">&#9670;&nbsp;</a></span>_Heap_Greedy_allocate_all_except_largest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Greedy_allocate_all_except_largest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>allocatable_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedily allocates all blocks except the largest free block. </p>
<p>Afterwards the heap has at most one allocatable block. This block is the largest free block if it exists. All other blocks are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to operate upon. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocatable_size</td><td>Stores the size of the largest free block of the heap after the method call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first allocated block.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreHeap.html#ga01401364d81dc07728aea35aac06e84d" title="Frees blocks of a greedy allocation.">_Heap_Greedy_free()</a>. </dd></dl>

</div>
</div>
<a id="ga01401364d81dc07728aea35aac06e84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01401364d81dc07728aea35aac06e84d">&#9670;&nbsp;</a></span>_Heap_Greedy_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Heap_Greedy_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees blocks of a greedy allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to operate upon. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blocks</td><td>Must be the return value of <a class="el" href="group__RTEMSScoreHeap.html#gae3e5154cbd4e707d42fb39b2e9c565ff" title="Greedily allocates and empties the heap.">_Heap_Greedy_allocate()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5974c7ccf84c152ba6c8e17bea3ca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5974c7ccf84c152ba6c8e17bea3ca5f">&#9670;&nbsp;</a></span>_Heap_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t _Heap_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>area_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>area_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the heap control block. </p>
<p>Blocks of memory are allocated from the heap in multiples of <em>page_size</em> byte units. If the <em>page_size</em> is equal to zero or is not multiple of <code>CPU_ALIGNMENT</code>, it is aligned up to the nearest <code>CPU_ALIGNMENT</code> boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">heap</td><td>The heap control block to manage the area. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">area_begin</td><td>The starting address of the area. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">area_size</td><td>The size of the area in bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">page_size</td><td>The page size for the calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">some_value</td><td>The maximum memory available. </td></tr>
    <tr><td class="paramname">0</td><td>The initialization failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreHeap.html#ga8953b692d39ca1c8a2780e9e8e2d9b1f" title="Heap initialization and extend handler type.">Heap_Initialization_or_extend_handler</a>. </dd></dl>

</div>
</div>
<a id="ga6a21a1797970a73dfe515f3defc5fe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a21a1797970a73dfe515f3defc5fe8d">&#9670;&nbsp;</a></span>_Heap_Is_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Heap_Is_aligned </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the value is aligned to the given alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check the alignment of. </td></tr>
    <tr><td class="paramname">alignment</td><td>The alignment for the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The value is aligned to the given alignment. </td></tr>
    <tr><td class="paramname">false</td><td>The value is not aligned to the given alignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc511a89a627aea2d91fbc21b95a4ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc511a89a627aea2d91fbc21b95a4ae7">&#9670;&nbsp;</a></span>_Heap_Is_block_in_heap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Heap_Is_block_in_heap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the block is part of the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap to test if the <em>block</em> is part of it. </td></tr>
    <tr><td class="paramname">block</td><td>The block of which the information is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The block is part of the heap. </td></tr>
    <tr><td class="paramname">false</td><td>The block is not part of the heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9a216779de2fa37926f7cba5d8342dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a216779de2fa37926f7cba5d8342dd">&#9670;&nbsp;</a></span>_Heap_Is_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Heap_Is_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the heap block is free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block of which the information is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The block is free. </td></tr>
    <tr><td class="paramname">false</td><td>The block is not free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad88e4681224e360888f3f4bd020c97a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88e4681224e360888f3f4bd020c97a9">&#9670;&nbsp;</a></span>_Heap_Is_prev_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Heap_Is_prev_used </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the previous heap block is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block of which the information about the previous block is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The previous block is used. </td></tr>
    <tr><td class="paramname">false</td><td>The previous block is not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7108eed881e09dc3519e8a35220f0feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7108eed881e09dc3519e8a35220f0feb">&#9670;&nbsp;</a></span>_Heap_Is_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Heap_Is_used </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the heap block is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block of which the information is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The block is used. </td></tr>
    <tr><td class="paramname">false</td><td>The block is not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga568d8a3b62e8b4b060940770bdeee254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568d8a3b62e8b4b060940770bdeee254">&#9670;&nbsp;</a></span>_Heap_Iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Heap_Iterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreHeap.html#gab5fc026bfabc31c620545e574d579b64">Heap_Block_visitor</a>&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>visitor_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over all blocks of the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to iterate over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">visitor</td><td>This will be called for each heap block with the argument <em>visitor_arg</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">visitor_arg</td><td>The argument for all calls of <em>visitor</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35ce876152e1f3a06b5caf377c92c9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35ce876152e1f3a06b5caf377c92c9f3">&#9670;&nbsp;</a></span>_Heap_Max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Max </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bigger one of the two arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The parameter on the left hand side of the comparison. </td></tr>
    <tr><td class="paramname">b</td><td>The parameter on the right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>If a &gt; b. </td></tr>
    <tr><td class="paramname">b</td><td>If b &gt;= a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09fb0b895f87524b8bf4e7fe7c1b41da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09fb0b895f87524b8bf4e7fe7c1b41da">&#9670;&nbsp;</a></span>_Heap_Min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Min </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smaller one of the two arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The parameter on the left hand side of the comparison. </td></tr>
    <tr><td class="paramname">b</td><td>The parameter on the right hand side of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>If a &lt; b. </td></tr>
    <tr><td class="paramname">b</td><td>If b &lt;= a </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54ed70e7cf8e99037c356772c927eaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54ed70e7cf8e99037c356772c927eaee">&#9670;&nbsp;</a></span>_Heap_Min_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Min_block_size </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>page_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimal Heap Block size for the given page_size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_size</td><td>The page size for the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimal Heap Block size for the given <em>page_size</em>. </dd></dl>

</div>
</div>
<a id="ga34c79fc0ef24f7bff393aedccff17a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34c79fc0ef24f7bff393aedccff17a29">&#9670;&nbsp;</a></span>_Heap_No_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t _Heap_No_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>unused_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>unused_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>unused_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>unused_3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns always zero. </p>
<p>This function only returns zero and does nothing else.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unused_0</td><td>This parameter does nothing. </td></tr>
    <tr><td class="paramname">unused_1</td><td>This parameter does nothing. </td></tr>
    <tr><td class="paramname">unused_2</td><td>This parameter does nothing. </td></tr>
    <tr><td class="paramname">unused_3</td><td>This parameter does nothing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreHeap.html#ga8953b692d39ca1c8a2780e9e8e2d9b1f" title="Heap initialization and extend handler type.">Heap_Initialization_or_extend_handler</a>. </dd></dl>

</div>
</div>
<a id="ga1f927e073f140a91ccbd846879984de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f927e073f140a91ccbd846879984de6">&#9670;&nbsp;</a></span>_Heap_Prev_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structHeap__Block.html">Heap_Block</a>* _Heap_Prev_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHeap__Block.html">Heap_Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address of the previous block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block of which the address of the previous block is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the previous block. </dd></dl>

</div>
</div>
<a id="gad616af34405ce4473f9ff3050ce39d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad616af34405ce4473f9ff3050ce39d90">&#9670;&nbsp;</a></span>_Heap_Protection_set_delayed_free_fraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Protection_set_delayed_free_fraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fraction of delayed free blocks that is actually freed during memory shortage. </p>
<p>The default is to free half the delayed free blocks. This is equal to a fraction value of two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap control. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fraction</td><td>The fraction is one divided by this fraction value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89495f3d0b1206d098d2733d37c1610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89495f3d0b1206d098d2733d37c1610e">&#9670;&nbsp;</a></span>_Heap_Resize_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreHeap.html#gac2cffc99d60d783b92e79fd412d1cbdc">Heap_Resize_status</a> _Heap_Resize_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the block of the allocated memory area. </p>
<p>Inappropriate values for <em>addr</em> may corrupt the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to operate upon. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">addr</td><td>The starting address of the allocated memory area to be resized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>The least possible size for the new memory area. Resize may be impossible and depends on the current heap usage. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_size</td><td>Stores the size available for allocation in the current block before the resize after the method call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_size</td><td>Stores the size available for allocation in the resized block after the method call. In the case of an unsuccessful resize, zero is returned in this parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HEAP_RESIZE_SUCCESSFUL</td><td>The resize was successful. </td></tr>
    <tr><td class="paramname">HEAP_RESIZE_UNSATISFIED</td><td>The least possible size <em>size</em> was too big. Resize not possible. </td></tr>
    <tr><td class="paramname">HEAP_RESIZE_FATAL_ERROR</td><td>The block starting at <em>addr</em> is not part of the heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf95a9dbdca32f811e64b2bedf4f74ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95a9dbdca32f811e64b2bedf4f74ff3">&#9670;&nbsp;</a></span>_Heap_Set_last_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Heap_Set_last_block_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the last block for the heap. </p>
<p>The next block of the last block will be the first block. Since the first block indicates that the previous block is used, this ensures that the last block appears as used for the <a class="el" href="group__RTEMSScoreHeap.html#ga7108eed881e09dc3519e8a35220f0feb" title="Returns if the heap block is used.">_Heap_Is_used()</a> and <a class="el" href="group__RTEMSScoreHeap.html#gae9a216779de2fa37926f7cba5d8342dd" title="Returns if the heap block is free.">_Heap_Is_free()</a> functions.</p>
<p>This feature will be used to terminate the scattered heap area list. See also <a class="el" href="group__RTEMSScoreHeap.html#ga7484f40d81ae26a7f5b3773a2dd006be" title="Extends the memory available for the heap.">_Heap_Extend()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>The heap to set the last block size of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8985839270f72039581fb4ddc44d433a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8985839270f72039581fb4ddc44d433a">&#9670;&nbsp;</a></span>_Heap_Size_of_alloc_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Heap_Size_of_alloc_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the allocatable memory area. </p>
<p>The size value may be greater than the initially requested size in <a class="el" href="group__RTEMSScoreHeap.html#ga15167f1ad5eb93d85f15adb5e5524ff5" title="Allocates an aligned memory area with boundary constraint.">_Heap_Allocate_aligned_with_boundary()</a>.</p>
<p>Inappropriate values for <em>addr</em> will not corrupt the heap, but may yield invalid size values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">heap</td><td>The heap to operate upon. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">addr</td><td>The starting address of the allocatable memory area. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Stores the size of the allocatable memory area after the method call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">false</td><td>The operation was not successful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00d53e87789012f59ec95f97911f3f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d53e87789012f59ec95f97911f3f8b">&#9670;&nbsp;</a></span>_Heap_Size_with_overhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uintptr_t _Heap_Size_with_overhead </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size with administration and alignment overhead for one allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_size</td><td>The page size for the allocation. </td></tr>
    <tr><td class="paramname">size</td><td>The size to allocate. </td></tr>
    <tr><td class="paramname">alignment</td><td>The alignment that needs to be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size with administration and alignment overhead for one allocation. </dd></dl>

</div>
</div>
<a id="ga914249a9e285bdbd75ea1699a5771a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga914249a9e285bdbd75ea1699a5771a7a">&#9670;&nbsp;</a></span>_Heap_Walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Heap_Walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeap__Control.html">Heap_Control</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dump</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies the integrity of the heap. </p>
<p>Walks the heap to verify its integrity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap whose integrity is to be verified. </td></tr>
    <tr><td class="paramname">source</td><td>If <em>dump</em> is <code>true</code>, this is used to mark the output lines. </td></tr>
    <tr><td class="paramname">dump</td><td>Indicates whether diagnostic messages will be printed to standard output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>No errors occured, the heaps integrity is not violated. </td></tr>
    <tr><td class="paramname">false</td><td>The heap is corrupt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
