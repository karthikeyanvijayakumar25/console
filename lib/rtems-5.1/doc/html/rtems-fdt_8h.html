<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTEMS: cpukit/include/rtems/rtems-fdt.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtemslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTEMS
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cd198e36225ba3f41de97552050ac017.html">cpukit</a></li><li class="navelem"><a class="el" href="dir_4f6a7e6de63bf7faab77653961b179a0.html">include</a></li><li class="navelem"><a class="el" href="dir_be382d098cd1aaaaf11a7ebea3d850c0.html">rtems</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rtems-fdt.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RTEMS Flattened Device Tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="rtems_8h_source.html">rtems.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="chain_8h_source.html">rtems/chain.h</a>&gt;</code><br />
</div>
<p><a href="rtems-fdt_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a60c40da67e6383e601b3b92c267b0ab5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a60c40da67e6383e601b3b92c267b0ab5">RTEMS_FDT_ERR_NOTFOUND</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a60c40da67e6383e601b3b92c267b0ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7077da16961f22b6a669f42e14754a19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a7077da16961f22b6a669f42e14754a19">RTEMS_FDT_ERR_EXISTS</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7077da16961f22b6a669f42e14754a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac572292c1bf4b03caf1ed614297df75f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#ac572292c1bf4b03caf1ed614297df75f">RTEMS_FDT_ERR_NOSPACE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ac572292c1bf4b03caf1ed614297df75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc1bbe15934b882af1366e96be49f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aa3fc1bbe15934b882af1366e96be49f7">RTEMS_FDT_ERR_BADOFFSET</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aa3fc1bbe15934b882af1366e96be49f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6408443266323215cd2616432644ab6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a6408443266323215cd2616432644ab6f">RTEMS_FDT_ERR_BADPATH</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a6408443266323215cd2616432644ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65317278a6c62afefc1d986c8c1686ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a65317278a6c62afefc1d986c8c1686ad">RTEMS_FDT_ERR_BADPHANDLE</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a65317278a6c62afefc1d986c8c1686ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750ba759dda889c4a66d6eaa232c878a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a750ba759dda889c4a66d6eaa232c878a">RTEMS_FDT_ERR_BADSTATE</a>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a750ba759dda889c4a66d6eaa232c878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7370489ac101a450c2fb9453a6f7d06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aa7370489ac101a450c2fb9453a6f7d06">RTEMS_FDT_ERR_TRUNCATED</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:aa7370489ac101a450c2fb9453a6f7d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade4d657298b170677b2a29f4e3c3b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a1ade4d657298b170677b2a29f4e3c3b6">RTEMS_FDT_ERR_BADMAGIC</a>&#160;&#160;&#160;9</td></tr>
<tr class="separator:a1ade4d657298b170677b2a29f4e3c3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1335b18e4b59d15f05fc888cb2725dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#af1335b18e4b59d15f05fc888cb2725dc">RTEMS_FDT_ERR_BADVERSION</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:af1335b18e4b59d15f05fc888cb2725dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0a6ee11fdd227e8e95088edfb4d8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#ad6f0a6ee11fdd227e8e95088edfb4d8f">RTEMS_FDT_ERR_BADSTRUCTURE</a>&#160;&#160;&#160;11</td></tr>
<tr class="separator:ad6f0a6ee11fdd227e8e95088edfb4d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c970b5dd3c0b17772fed719b4f606b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a1c970b5dd3c0b17772fed719b4f606b2">RTEMS_FDT_ERR_BADLAYOUT</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:a1c970b5dd3c0b17772fed719b4f606b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4caa4ae7a6ee091aba109d321a1d12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aeb4caa4ae7a6ee091aba109d321a1d12">RTEMS_FDT_ERR_INTERNAL</a>&#160;&#160;&#160;13</td></tr>
<tr class="separator:aeb4caa4ae7a6ee091aba109d321a1d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6f3cad8bb35b7827abd788a1f2afb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a7e6f3cad8bb35b7827abd788a1f2afb3">RTEMS_FDT_ERR_INVALID_HANDLE</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a7e6f3cad8bb35b7827abd788a1f2afb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaa83d086fdece4ae7b58063444e4f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aceaa83d086fdece4ae7b58063444e4f8">RTEMS_FDT_ERR_NO_MEMORY</a>&#160;&#160;&#160;101</td></tr>
<tr class="separator:aceaa83d086fdece4ae7b58063444e4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af669f9280824e70fcf06a377724be893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#af669f9280824e70fcf06a377724be893">RTEMS_FDT_ERR_NOT_FOUND</a>&#160;&#160;&#160;102</td></tr>
<tr class="separator:af669f9280824e70fcf06a377724be893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e372e1e99ca64f229614e5c7fa7bc7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a35e372e1e99ca64f229614e5c7fa7bc7">RTEMS_FDT_ERR_READ_FAIL</a>&#160;&#160;&#160;103</td></tr>
<tr class="separator:a35e372e1e99ca64f229614e5c7fa7bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef76af337c06a43049c280b90b3f2755"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aef76af337c06a43049c280b90b3f2755">RTEMS_FDT_ERR_REFERENCED</a>&#160;&#160;&#160;104</td></tr>
<tr class="separator:aef76af337c06a43049c280b90b3f2755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f3efabdbdf9b96522d711aa4911ef1"><td class="memItemLeft" align="right" valign="top"><a id="ad1f3efabdbdf9b96522d711aa4911ef1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_FDT_ERR_RTEMS_MIN</b>&#160;&#160;&#160;100</td></tr>
<tr class="separator:ad1f3efabdbdf9b96522d711aa4911ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab64b1535655dc3f2eaec0d77db585a"><td class="memItemLeft" align="right" valign="top"><a id="aeab64b1535655dc3f2eaec0d77db585a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_FDT_ERR_MAX</b>&#160;&#160;&#160;104</td></tr>
<tr class="separator:aeab64b1535655dc3f2eaec0d77db585a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac716d8c4c221b55ee318476ad8ee7aba"><td class="memItemLeft" align="right" valign="top"><a id="ac716d8c4c221b55ee318476ad8ee7aba"></a>
typedef struct <a class="el" href="structrtems__fdt__blob.html">rtems_fdt_blob</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_fdt_blob</b></td></tr>
<tr class="separator:ac716d8c4c221b55ee318476ad8ee7aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3315346f05c8e25cd84b62626f249da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a3315346f05c8e25cd84b62626f249da4">rtems_fdt_init_handle</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:a3315346f05c8e25cd84b62626f249da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7345cc5334e1afde88e13f65ddb68f12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a7345cc5334e1afde88e13f65ddb68f12">rtems_fdt_dup_handle</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *from, <a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *to)</td></tr>
<tr class="separator:a7345cc5334e1afde88e13f65ddb68f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef15751554a2804bbde895bf07dffe80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aef15751554a2804bbde895bf07dffe80">rtems_fdt_release_handle</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:aef15751554a2804bbde895bf07dffe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabed205ff98f5b2ae70709106b8cd8f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aabed205ff98f5b2ae70709106b8cd8f2">rtems_fdt_valid_handle</a> (const <a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:aabed205ff98f5b2ae70709106b8cd8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ee27464217327e0e7fb40ef60a48ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a82ee27464217327e0e7fb40ef60a48ac">rtems_fdt_find_path_offset</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, const char *path)</td></tr>
<tr class="separator:a82ee27464217327e0e7fb40ef60a48ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade27ea157b92bb17f531baae94571c5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#ade27ea157b92bb17f531baae94571c5b">rtems_fdt_load</a> (const char *const filename, <a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:ade27ea157b92bb17f531baae94571c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6903d840a58d8b99ede97ac20bd94af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#ad6903d840a58d8b99ede97ac20bd94af">rtems_fdt_register</a> (const void *blob, <a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:ad6903d840a58d8b99ede97ac20bd94af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1e782f453d0e9f42afa462803a350"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#af6f1e782f453d0e9f42afa462803a350">rtems_fdt_unload</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:af6f1e782f453d0e9f42afa462803a350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afded44117e8bf86b1fa32164b081f3bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#afded44117e8bf86b1fa32164b081f3bb">rtems_fdt_num_mem_rsv</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:afded44117e8bf86b1fa32164b081f3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bed3b15e9467073b96de9eb48b0f58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#af1bed3b15e9467073b96de9eb48b0f58">rtems_fdt_get_mem_rsv</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int n, uint64_t *address, uint64_t *<a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="separator:af1bed3b15e9467073b96de9eb48b0f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46722743c63e5a5ccaec9769296112a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a46722743c63e5a5ccaec9769296112a2">rtems_fdt_subnode_offset_namelen</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int parentoffset, const char *const name, int namelen)</td></tr>
<tr class="separator:a46722743c63e5a5ccaec9769296112a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e2da108a4d349e480859964ad66b87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a85e2da108a4d349e480859964ad66b87">rtems_fdt_subnode_offset</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int parentoffset, const char *const name)</td></tr>
<tr class="separator:a85e2da108a4d349e480859964ad66b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57007eed312123059461eb8bbace1c09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a57007eed312123059461eb8bbace1c09">rtems_fdt_path_offset</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, const char *path)</td></tr>
<tr class="separator:a57007eed312123059461eb8bbace1c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231745529cbd5da1e22005e6c2168bc5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a231745529cbd5da1e22005e6c2168bc5">rtems_fdt_get_name</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset, int *length)</td></tr>
<tr class="separator:a231745529cbd5da1e22005e6c2168bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2898a55d17e55765179f2d4b1acebcf"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#ac2898a55d17e55765179f2d4b1acebcf">rtems_fdt_getprop_namelen</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset, const char *const name, int namelen, int *length)</td></tr>
<tr class="separator:ac2898a55d17e55765179f2d4b1acebcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf20b3498dc0cce9c497c0adacb77955"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#aaf20b3498dc0cce9c497c0adacb77955">rtems_fdt_getprop</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset, const char *const name, int *length)</td></tr>
<tr class="separator:aaf20b3498dc0cce9c497c0adacb77955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380df921ada4d6d9b5e1c1605448744a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a380df921ada4d6d9b5e1c1605448744a">rtems_fdt_get_phandle</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset)</td></tr>
<tr class="separator:a380df921ada4d6d9b5e1c1605448744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424bf49f7d9b45ac4340206aef66c8f4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a424bf49f7d9b45ac4340206aef66c8f4">rtems_fdt_get_alias_namelen</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, const char *const name, int namelen)</td></tr>
<tr class="separator:a424bf49f7d9b45ac4340206aef66c8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af220698849e74aac90bea92864e5d628"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#af220698849e74aac90bea92864e5d628">rtems_fdt_get_alias</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, const char *name)</td></tr>
<tr class="separator:af220698849e74aac90bea92864e5d628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdb3310c5a54e1f954e30a16af3dc6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#afcdb3310c5a54e1f954e30a16af3dc6a">rtems_fdt_get_path</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset, char *buf, int buflen)</td></tr>
<tr class="separator:afcdb3310c5a54e1f954e30a16af3dc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20478964d261bd15846a70f3d8af55ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a20478964d261bd15846a70f3d8af55ab">rtems_fdt_supernode_atdepth_offset</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset, int supernodedepth, int *nodedepth)</td></tr>
<tr class="separator:a20478964d261bd15846a70f3d8af55ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec16b9548b07b98f9d88e2e7a6f62cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a9ec16b9548b07b98f9d88e2e7a6f62cc">rtems_fdt_node_depth</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset)</td></tr>
<tr class="separator:a9ec16b9548b07b98f9d88e2e7a6f62cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99132e68dc89a9345760db5f986e26be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a99132e68dc89a9345760db5f986e26be">rtems_fdt_parent_offset</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset)</td></tr>
<tr class="separator:a99132e68dc89a9345760db5f986e26be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc37bcb0ea7b3d2a6f1c9bb9369305c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#acc37bcb0ea7b3d2a6f1c9bb9369305c4">rtems_fdt_node_offset_by_prop_value</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int startoffset, const char *const propname, const void *propval, int proplen)</td></tr>
<tr class="separator:acc37bcb0ea7b3d2a6f1c9bb9369305c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e325bcc41668532f9d4fdc6d66d5fb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a0e325bcc41668532f9d4fdc6d66d5fb6">rtems_fdt_node_offset_by_phandle</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, uint32_t phandle)</td></tr>
<tr class="separator:a0e325bcc41668532f9d4fdc6d66d5fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abac9c2c215d99055a4f0c85c831ba1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a6abac9c2c215d99055a4f0c85c831ba1">rtems_fdt_node_check_compatible</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int nodeoffset, const char *const compatible)</td></tr>
<tr class="separator:a6abac9c2c215d99055a4f0c85c831ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe269c0fdda9a30c153f87b507c9a1f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#abe269c0fdda9a30c153f87b507c9a1f3">rtems_fdt_node_offset_by_compatible</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int startoffset, const char *compatible)</td></tr>
<tr class="separator:abe269c0fdda9a30c153f87b507c9a1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20680319175c55fcc8f375730f2fc98e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a20680319175c55fcc8f375730f2fc98e">rtems_fdt_next_node</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int offset, int *depth)</td></tr>
<tr class="separator:a20680319175c55fcc8f375730f2fc98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d5e02973f7a6950997f9df08fbcdbe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a29d5e02973f7a6950997f9df08fbcdbe">rtems_fdt_strerror</a> (int errval)</td></tr>
<tr class="separator:a29d5e02973f7a6950997f9df08fbcdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80bd246991e1af0ae5b67ad548f75c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#ab80bd246991e1af0ae5b67ad548f75c2">rtems_fdt_prop_value</a> (const char *const path, const char *const propname, void *value, size_t *<a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>)</td></tr>
<tr class="separator:ab80bd246991e1af0ae5b67ad548f75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ecd00704b8d133666365ade18e563b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a59ecd00704b8d133666365ade18e563b">rtems_fdt_prop_map</a> (const char *const path, const char *const propname, const char *const names[], uint32_t *values, size_t count)</td></tr>
<tr class="separator:a59ecd00704b8d133666365ade18e563b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30e807853d110c9e5b9c5b03e06cc28"><td class="memItemLeft" align="right" valign="top"><a id="ab30e807853d110c9e5b9c5b03e06cc28"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_fdt_get_value</b> (const char *const path, const char *const property, size_t <a class="el" href="sun4u_2tte_8h.html#a245260f6f74972558f61b85227df5aae">size</a>, uint32_t *value)</td></tr>
<tr class="separator:ab30e807853d110c9e5b9c5b03e06cc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a5642dfec6745846f5fea1a512cf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a3f1a5642dfec6745846f5fea1a512cf5">rtems_fdt_num_entries</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle)</td></tr>
<tr class="separator:a3f1a5642dfec6745846f5fea1a512cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fcb9df3611e0a99021b38f00571713"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a40fcb9df3611e0a99021b38f00571713">rtems_fdt_entry_name</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int id)</td></tr>
<tr class="separator:a40fcb9df3611e0a99021b38f00571713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a00ac7324cf4c362286922a734a7e79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtems-fdt_8h.html#a5a00ac7324cf4c362286922a734a7e79">rtems_fdt_entry_offset</a> (<a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *handle, int id)</td></tr>
<tr class="separator:a5a00ac7324cf4c362286922a734a7e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f0d88fab8a465c1087170ce20f21d"><td class="memItemLeft" align="right" valign="top"><a id="a777f0d88fab8a465c1087170ce20f21d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_fdt_get_uint32</b> (const void *prop)</td></tr>
<tr class="separator:a777f0d88fab8a465c1087170ce20f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTEMS Flattened Device Tree. </p>
<p>Support for loading, managing and accessing FDT blobs in RTEMS. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1c970b5dd3c0b17772fed719b4f606b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c970b5dd3c0b17772fed719b4f606b2">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADLAYOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADLAYOUT&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADLAYOUT: For read-write functions, the given device tree has it's sub-blocks in an order that the function can't handle (memory reserve map, then structure, then strings). Use rtems_fdt_open_into() to reorganize the tree into a form suitable for the read-write operations. </p>

</div>
</div>
<a id="a1ade4d657298b170677b2a29f4e3c3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ade4d657298b170677b2a29f4e3c3b6">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADMAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADMAGIC&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADMAGIC: Given "device tree" appears not to be a device tree at all - it is missing the flattened device tree magic number. </p>

</div>
</div>
<a id="aa3fc1bbe15934b882af1366e96be49f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fc1bbe15934b882af1366e96be49f7">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADOFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADOFFSET&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADOFFSET: Function was passed a structure block offset which is out-of-bounds, or which points to an unsuitable part of the structure for the operation. </p>

</div>
</div>
<a id="a6408443266323215cd2616432644ab6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6408443266323215cd2616432644ab6f">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADPATH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADPATH&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADPATH: Function was passed a badly formatted path (e.g. missing a leading / for a function which requires an absolute path) </p>

</div>
</div>
<a id="a65317278a6c62afefc1d986c8c1686ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65317278a6c62afefc1d986c8c1686ad">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADPHANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADPHANDLE&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADPHANDLE: Function was passed an invalid phandle value. phandle values of 0 and -1 are not permitted. </p>

</div>
</div>
<a id="a750ba759dda889c4a66d6eaa232c878a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750ba759dda889c4a66d6eaa232c878a">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADSTATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADSTATE&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADSTATE: Function was passed an incomplete device tree created by the sequential-write functions, which is not sufficiently complete for the requested operation. </p>

</div>
</div>
<a id="ad6f0a6ee11fdd227e8e95088edfb4d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f0a6ee11fdd227e8e95088edfb4d8f">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADSTRUCTURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADSTRUCTURE&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADSTRUCTURE: Given device tree has a corrupt structure block or other serious error (e.g. misnested nodes, or subnodes preceding properties). </p>

</div>
</div>
<a id="af1335b18e4b59d15f05fc888cb2725dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1335b18e4b59d15f05fc888cb2725dc">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_BADVERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_BADVERSION&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_BADVERSION: Given device tree has a version which can't be handled by the requested operation. For read-write functions, this may mean that rtems_fdt_open_into() is required to convert the tree to the expected version. </p>

</div>
</div>
<a id="a7077da16961f22b6a669f42e14754a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7077da16961f22b6a669f42e14754a19">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_EXISTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_EXISTS&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_EXISTS: Attemped to create a node or property which already exists </p>

</div>
</div>
<a id="aeb4caa4ae7a6ee091aba109d321a1d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4caa4ae7a6ee091aba109d321a1d12">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_INTERNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_INTERNAL&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>"Can't happen" error indicating a bug in libfdt </p>

</div>
</div>
<a id="a7e6f3cad8bb35b7827abd788a1f2afb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6f3cad8bb35b7827abd788a1f2afb3">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_INVALID_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_INVALID_HANDLE&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid handle. </p>

</div>
</div>
<a id="aceaa83d086fdece4ae7b58063444e4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaa83d086fdece4ae7b58063444e4f8">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_NO_MEMORY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_NO_MEMORY&#160;&#160;&#160;101</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No memory. </p>

</div>
</div>
<a id="ac572292c1bf4b03caf1ed614297df75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac572292c1bf4b03caf1ed614297df75f">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_NOSPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_NOSPACE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_NOSPACE: Operation needed to expand the device tree, but its buffer did not have sufficient space to contain the expanded tree. Use rtems_fdt_open_into() to move the device tree to a buffer with more space. </p>

</div>
</div>
<a id="af669f9280824e70fcf06a377724be893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af669f9280824e70fcf06a377724be893">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_NOT_FOUND&#160;&#160;&#160;102</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File not found. </p>

</div>
</div>
<a id="a60c40da67e6383e601b3b92c267b0ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c40da67e6383e601b3b92c267b0ab5">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_NOTFOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_NOTFOUND&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_NOTFOUND: The requested node or property does not exist </p>

</div>
</div>
<a id="a35e372e1e99ca64f229614e5c7fa7bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e372e1e99ca64f229614e5c7fa7bc7">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_READ_FAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_READ_FAIL&#160;&#160;&#160;103</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cannot read the DTB into memory. </p>

</div>
</div>
<a id="aef76af337c06a43049c280b90b3f2755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef76af337c06a43049c280b90b3f2755">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_REFERENCED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_REFERENCED&#160;&#160;&#160;104</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The blob cannot be unloaded as it is referenced. </p>

</div>
</div>
<a id="aa7370489ac101a450c2fb9453a6f7d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7370489ac101a450c2fb9453a6f7d06">&#9670;&nbsp;</a></span>RTEMS_FDT_ERR_TRUNCATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_FDT_ERR_TRUNCATED&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTEMS_FDT_ERR_TRUNCATED: Structure block of the given device tree ends without an RTEMS_FDT_END tag. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7345cc5334e1afde88e13f65ddb68f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7345cc5334e1afde88e13f65ddb68f12">&#9670;&nbsp;</a></span>rtems_fdt_dup_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_fdt_dup_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicate a handle. The copy must be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Duplicate from this handle. </td></tr>
    <tr><td class="paramname">to</td><td>Duplicate to this handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40fcb9df3611e0a99021b38f00571713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fcb9df3611e0a99021b38f00571713">&#9670;&nbsp;</a></span>rtems_fdt_entry_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rtems_fdt_entry_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the numbered entry name. Note that the id isn't the same as the offset - it's numbered 0, 1, 2 ... num_entries-1 </p>

</div>
</div>
<a id="a5a00ac7324cf4c362286922a734a7e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a00ac7324cf4c362286922a734a7e79">&#9670;&nbsp;</a></span>rtems_fdt_entry_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_entry_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the numbered entry offset. Note that the id isn't the same as the offset - it's numbered 0, 1, 2 ... num_entries-1 </p>

</div>
</div>
<a id="a82ee27464217327e0e7fb40ef60a48ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ee27464217327e0e7fb40ef60a48ac">&#9670;&nbsp;</a></span>rtems_fdt_find_path_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_find_path_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a tree node by its full path looking across of loaded blobs.. Each path component may omit the unit address portion, but the results of this are undefined if any such path component is ambiguous (that is if there are multiple nodes at the relevant level matching the given component, differentiated only by unit address).</p>
<p>If the handle points to a valid blob it is release and the search starts from the first blob.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle assigned to the blob if found else left invalid. </td></tr>
    <tr><td class="paramname">path</td><td>Full path of the node to locate. </td></tr>
    <tr><td class="paramname">int</td><td>If less than 0 an error code else the node offset is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af220698849e74aac90bea92864e5d628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af220698849e74aac90bea92864e5d628">&#9670;&nbsp;</a></span>rtems_fdt_get_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rtems_fdt_get_alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retreive the path referenced by a given alias. That is, the value of the property named 'name' in the node /aliases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the alias to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* A pointer to the expansion of the alias named 'name', of it exists NULL, if the given alias or the /aliases node does not exist </dd></dl>

</div>
</div>
<a id="a424bf49f7d9b45ac4340206aef66c8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424bf49f7d9b45ac4340206aef66c8f4">&#9670;&nbsp;</a></span>rtems_fdt_get_alias_namelen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rtems_fdt_get_alias_namelen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>namelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get alias based on substring. Identical to <a class="el" href="rtems-fdt_8h.html#af220698849e74aac90bea92864e5d628">rtems_fdt_get_alias()</a>, but only examine the first namelen characters of name for matching the alias name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the alias th look up. </td></tr>
    <tr><td class="paramname">namelen</td><td>The number of characters of name to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* The alias or NULL. </dd></dl>

</div>
</div>
<a id="af1bed3b15e9467073b96de9eb48b0f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bed3b15e9467073b96de9eb48b0f58">&#9670;&nbsp;</a></span>rtems_fdt_get_mem_rsv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_get_mem_rsv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve one memory reserve map entry. On success, *address and *size will contain the address and size of the n-th reserve map entry from the device tree blob, in native-endian format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_desc</td><td>A valid blob descriptor. </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to 64-bit variables to hold the addresses. </td></tr>
    <tr><td class="paramname">size</td><td>Pointer to 64-bit variables to hold the size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 it is an error code else 0 is returned on success. </dd></dl>

</div>
</div>
<a id="a231745529cbd5da1e22005e6c2168bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231745529cbd5da1e22005e6c2168bc5">&#9670;&nbsp;</a></span>rtems_fdt_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rtems_fdt_get_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of a given node (including unit address) of the device tree node at structure block offset @nodeoffset. If @length is non-NULL, the length of this name is also returned, in the integer pointed to by @length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>Structure block offset of the starting node. </td></tr>
    <tr><td class="paramname">length</td><td>Pointer to an integer variable (will be overwritten) or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* The node's name on success or NULL on error. The length if non-NULL will hold the error code. </dd></dl>

</div>
</div>
<a id="afcdb3310c5a54e1f954e30a16af3dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdb3310c5a54e1f954e30a16af3dc6a">&#9670;&nbsp;</a></span>rtems_fdt_get_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_get_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the full path of a node. This function is expensive, as it must scan the device tree structure from the start to nodeoffset. It computes the full path of the node at offset nodeoffset, and records that path in the buffer at buf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>The offset of the node whose path to find. </td></tr>
    <tr><td class="paramname">buf</td><td>A character buffer to contain the returned path (will be overwritten) </td></tr>
    <tr><td class="paramname">buflen</td><td>The size of the character buffer at buf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success of an error code. </dd></dl>

</div>
</div>
<a id="a380df921ada4d6d9b5e1c1605448744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380df921ada4d6d9b5e1c1605448744a">&#9670;&nbsp;</a></span>rtems_fdt_get_phandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtems_fdt_get_phandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the phandle of a given of the device tree node at structure block offset nodeoffset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. @oaram nodeoffset The structure block offset of the node. return uint32_t The phandle of the node at nodeoffset, on success (!= 0, != -1) 0, if the node has no phandle, or another error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf20b3498dc0cce9c497c0adacb77955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf20b3498dc0cce9c497c0adacb77955">&#9670;&nbsp;</a></span>rtems_fdt_getprop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* rtems_fdt_getprop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value of a given property. Retrieves a pointer to the value of the property named 'name' of the node at offset nodeoffset (this will be a pointer to within the device blob itself, not a copy of the value). If lenp is non-NULL, the length of the property value is also returned, in the integer pointed to by @length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>The offset of the node whose property to find. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property to find. </td></tr>
    <tr><td class="paramname">length</td><td>A pointer to an integer variable (will be overwritten) or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const void* The node's property on success or NULL on error. The length if non-NULL will hold the error code. </dd></dl>

</div>
</div>
<a id="ac2898a55d17e55765179f2d4b1acebcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2898a55d17e55765179f2d4b1acebcf">&#9670;&nbsp;</a></span>rtems_fdt_getprop_namelen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* rtems_fdt_getprop_namelen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>namelen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get property value based on substring. Identical to <a class="el" href="rtems-fdt_8h.html#aaf20b3498dc0cce9c497c0adacb77955">rtems_fdt_getprop()</a>, but only examine the first namelen characters of name for matching the property name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>Offset of the node whose property to find </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property to find </td></tr>
    <tr><td class="paramname">namelen</td><td>The number of characters of name to consider </td></tr>
    <tr><td class="paramname">length</td><td>A pointer to an integer variable (will be overwritten) or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const void* The node's property on success or NULL on error. The length if non-NULL will hold the error code. </dd></dl>

</div>
</div>
<a id="a3315346f05c8e25cd84b62626f249da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3315346f05c8e25cd84b62626f249da4">&#9670;&nbsp;</a></span>rtems_fdt_init_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_fdt_init_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise a handle to a default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to initialise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade27ea157b92bb17f531baae94571c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade27ea157b92bb17f531baae94571c5b">&#9670;&nbsp;</a></span>rtems_fdt_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_load </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a device tree blob or DTB file into memory and register it on the chain of blobs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the blob file to load. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle returns the reference to the blob once load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 it is an error code else it is the blob descriptor. </dd></dl>

</div>
</div>
<a id="a20680319175c55fcc8f375730f2fc98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20680319175c55fcc8f375730f2fc98e">&#9670;&nbsp;</a></span>rtems_fdt_next_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_next_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverse to the next node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the blob to start looking for the next node. </td></tr>
    <tr><td class="paramname">depth</td><td>Pointer to return the depth the node is. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 an error else the node offset. </dd></dl>

</div>
</div>
<a id="a6abac9c2c215d99055a4f0c85c831ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abac9c2c215d99055a4f0c85c831ba1">&#9670;&nbsp;</a></span>rtems_fdt_node_check_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_node_check_compatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>compatible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check a node's compatible property returning 0 if the given node contains a 'compatible' property with the given string as one of its elements, it returns non-zero otherwise, or on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>The offset of a tree node. </td></tr>
    <tr><td class="paramname">compatible</td><td>The string to match against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0,if</td><td>the node has a 'compatible' property listing the given string. </td></tr>
    <tr><td class="paramname">1,if</td><td>the node has a 'compatible' property, but it does not list the given string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ec16b9548b07b98f9d88e2e7a6f62cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec16b9548b07b98f9d88e2e7a6f62cc">&#9670;&nbsp;</a></span>rtems_fdt_node_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_node_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the depth of a given node. The root node has depth 0, its immediate subnodes depth 1 and so forth.</p>
<dl class="section note"><dt>Note</dt><dd>This function is expensive, as it must scan the device tree structure from the start to nodeoffset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>The offset of the node whose parent to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 an error else the node offset. </dd></dl>

</div>
</div>
<a id="abe269c0fdda9a30c153f87b507c9a1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe269c0fdda9a30c153f87b507c9a1f3">&#9670;&nbsp;</a></span>rtems_fdt_node_offset_by_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_node_offset_by_compatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compatible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find nodes with a given 'compatible' value returning the offset of the first node after startoffset, which has a 'compatible' property which lists the given compatible string; or if startoffset is -1, the very first such node in the tree.</p>
<p>To iterate through all nodes matching the criterion, the following idiom can be used:</p>
<p>offset = rtems_fdt_node_offset_by_compatible(blob, -1, compatible); while (offset != -RTEMS_FDT_ERR_NOTFOUND) { // other code here offset = rtems_fdt_node_offset_by_compatible(blob, offset, compatible); }</p>
<dl class="section note"><dt>Note</dt><dd>The -1 in the first call to the function, if 0 is used here instead, the function will never locate the root node, even if it matches the criterion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">startoffset</td><td>Only find nodes after this offset. </td></tr>
    <tr><td class="paramname">compatible</td><td>The 'compatible' string to match against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 an error else the node offset. </dd></dl>

</div>
</div>
<a id="a0e325bcc41668532f9d4fdc6d66d5fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e325bcc41668532f9d4fdc6d66d5fb6">&#9670;&nbsp;</a></span>rtems_fdt_node_offset_by_phandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_node_offset_by_phandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the node with a given phandle returning the offset of the node which has the given phandle value. If there is more than one node in the tree with the given phandle (an invalid tree), results are undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">phandle</td><td>The phandle value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 an error else the node offset. </dd></dl>

</div>
</div>
<a id="acc37bcb0ea7b3d2a6f1c9bb9369305c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc37bcb0ea7b3d2a6f1c9bb9369305c4">&#9670;&nbsp;</a></span>rtems_fdt_node_offset_by_prop_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_node_offset_by_prop_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>propval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proplen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find nodes with a given property value. This funtion returns the offset of the first node after startoffset, which has a property named propname whose value is of length proplen and has value equal to propval; or if startoffset is -1, the very first such node in the tree.</p>
<p>To iterate through all nodes matching the criterion, the following idiom can be used: offset = rtemsfdt_node_offset_by_prop_value(blob, -1, propname, propval, proplen); while (offset != -RTEMS_FDT_ERR_NOTFOUND) { // other code here offset = rtems_fdt_node_offset_by_prop_value(fdt, offset, propname, propval, proplen); }</p>
<dl class="section note"><dt>Note</dt><dd>The -1 in the first call to the function, if 0 is used here instead, the function will never locate the root node, even if it matches the criterion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">startoffset</td><td>Only find nodes after this offset. </td></tr>
    <tr><td class="paramname">propname</td><td>The property name to check. </td></tr>
    <tr><td class="paramname">propval</td><td>The property value to search for. </td></tr>
    <tr><td class="paramname">proplen</td><td>The length of the value in propval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The structure block offset of the located node (&gt;= 0, &gt;startoffset), on success and an error code is less than 0. </dd></dl>

</div>
</div>
<a id="a3f1a5642dfec6745846f5fea1a512cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1a5642dfec6745846f5fea1a512cf5">&#9670;&nbsp;</a></span>rtems_fdt_num_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_num_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of entries in an FDT handle. </p>

</div>
</div>
<a id="afded44117e8bf86b1fa32164b081f3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afded44117e8bf86b1fa32164b081f3bb">&#9670;&nbsp;</a></span>rtems_fdt_num_mem_rsv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_num_mem_rsv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of entries in the device tree blob's memory reservation map. This does not include the terminating 0,0 entry or any other (0,0) entries reserved for expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_desc</td><td>A valid blob descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The number of entries. </dd></dl>

</div>
</div>
<a id="a99132e68dc89a9345760db5f986e26be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99132e68dc89a9345760db5f986e26be">&#9670;&nbsp;</a></span>rtems_fdt_parent_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_parent_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the parent of a given node. This funciton locates the parent node of a given node (that is, it finds the offset of the node which contains the node at nodeoffset as a subnode).</p>
<dl class="section note"><dt>Note</dt><dd>This function is expensive, as it must scan the device tree structure from the start to nodeoffset, <em>twice</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>The offset of the node whose parent to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 an error else the node offset. </dd></dl>

</div>
</div>
<a id="a57007eed312123059461eb8bbace1c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57007eed312123059461eb8bbace1c09">&#9670;&nbsp;</a></span>rtems_fdt_path_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_path_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a tree node by its full path. Each path component may omit the unit address portion, but the results of this are undefined if any such path component is ambiguous (that is if there are multiple nodes at the relevant level matching the given component, differentiated only by unit address).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">path</td><td>Full path of the node to locate. </td></tr>
    <tr><td class="paramname">int</td><td>If less than 0 an error code else the node offset is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59ecd00704b8d133666365ade18e563b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ecd00704b8d133666365ade18e563b">&#9670;&nbsp;</a></span>rtems_fdt_prop_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_prop_map </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>names</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a map given a path the property name and the names of the subnodes of the path. </p>

</div>
</div>
<a id="ab80bd246991e1af0ae5b67ad548f75c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80bd246991e1af0ae5b67ad548f75c2">&#9670;&nbsp;</a></span>rtems_fdt_prop_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_prop_value </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a property given a path. </p>

</div>
</div>
<a id="ad6903d840a58d8b99ede97ac20bd94af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6903d840a58d8b99ede97ac20bd94af">&#9670;&nbsp;</a></span>rtems_fdt_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_register </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a device tree blob or DTB on to the chain of blobs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_desc</td><td>A pointer to the blob. </td></tr>
    <tr><td class="paramname">handle</td><td>The handle returns the reference to the blob once load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 it is an error code else it is the blob descriptor. </dd></dl>

</div>
</div>
<a id="aef15751554a2804bbde895bf07dffe80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef15751554a2804bbde895bf07dffe80">&#9670;&nbsp;</a></span>rtems_fdt_release_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_fdt_release_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a blob from a handle and clear it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29d5e02973f7a6950997f9df08fbcdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d5e02973f7a6950997f9df08fbcdbe">&#9670;&nbsp;</a></span>rtems_fdt_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rtems_fdt_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an error string given an error value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errval</td><td>The error value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* The error string. </dd></dl>

</div>
</div>
<a id="a85e2da108a4d349e480859964ad66b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e2da108a4d349e480859964ad66b87">&#9670;&nbsp;</a></span>rtems_fdt_subnode_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_subnode_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a subnode of a given node at structure block offset parentoffset with the given name. The name may include a unit address, in which case <a class="el" href="rtems-fdt_8h.html#a85e2da108a4d349e480859964ad66b87">rtems_fdt_subnode_offset()</a> will find the subnode with that unit address, or the unit address may be omitted, in which case <a class="el" href="rtems-fdt_8h.html#a85e2da108a4d349e480859964ad66b87">rtems_fdt_subnode_offset()</a> will find an arbitrary subnode whose name excluding unit address matches the given name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_desc</td><td>A valid blob descriptor. </td></tr>
    <tr><td class="paramname">parentoffset</td><td>Structure block offset of a node. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the subnode to locate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 it is an error code else the subnode offset is returned. </dd></dl>

</div>
</div>
<a id="a46722743c63e5a5ccaec9769296112a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46722743c63e5a5ccaec9769296112a2">&#9670;&nbsp;</a></span>rtems_fdt_subnode_offset_namelen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_subnode_offset_namelen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>namelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a subnode based on substring. Identical to <a class="el" href="rtems-fdt_8h.html#a85e2da108a4d349e480859964ad66b87">rtems_fdt_subnode_offset()</a>, but only examine the first namelen characters of name for matching the subnode name. This is useful for finding subnodes based on a portion of a larger string, such as a full path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_desc</td><td>A valid blob descriptor. </td></tr>
    <tr><td class="paramname">arentoffset</td><td>Structure block offset of a node </td></tr>
    <tr><td class="paramname">name</td><td>Name of the subnode to locate. </td></tr>
    <tr><td class="paramname">namelen</td><td>Number of characters of name to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 it is an error code else the node offset is returned. </dd></dl>

</div>
</div>
<a id="a20478964d261bd15846a70f3d8af55ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20478964d261bd15846a70f3d8af55ab">&#9670;&nbsp;</a></span>rtems_fdt_supernode_atdepth_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_supernode_atdepth_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>supernodedepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nodedepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a specific ancestor of a node at a specific depth from the root (where the root itself has depth 0, its immediate subnodes depth 1 and so forth). So rtems_fdt_supernode_atdepth_offset(blob, nodeoffset, 0, NULL); will always return 0, the offset of the root node. If the node at nodeoffset has depth D, then: rtems_fdt_supernode_atdepth_offset(blob, nodeoffset, D, NULL); will return nodeoffset itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The FDT handle to the current blob. </td></tr>
    <tr><td class="paramname">nodeoffset</td><td>The offset of the node whose parent to find. </td></tr>
    <tr><td class="paramname">supernodedepth</td><td>The depth of the ancestor to find. @oaram nodedepth The pointer to an integer variable (will be overwritten) or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 an error else the node offset. </dd></dl>

</div>
</div>
<a id="af6f1e782f453d0e9f42afa462803a350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f1e782f453d0e9f42afa462803a350">&#9670;&nbsp;</a></span>rtems_fdt_unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtems_fdt_unload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unload a device tree blob or DTB file and release any memory allocated when loading. The blob is removed from the list of registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_desc</td><td>A valid blob descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int If less than 0 it is an error code else 0 is return on success. </dd></dl>

</div>
</div>
<a id="aabed205ff98f5b2ae70709106b8cd8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabed205ff98f5b2ae70709106b8cd8f2">&#9670;&nbsp;</a></span>rtems_fdt_valid_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtems_fdt_valid_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrtems__fdt__handle.html">rtems_fdt_handle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a handle had a valid blob assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The handle has a valid blob. </td></tr>
    <tr><td class="paramname">false</td><td>The handle does not have a valid blob. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
