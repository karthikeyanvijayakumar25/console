<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTEMS: Thread Handler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtemslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTEMS
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Thread Handler<div class="ingroups"><a class="el" href="group__RTEMSInternal.html">Internal</a> &raquo; <a class="el" href="group__RTEMSScore.html">SuperCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread Handler.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:score_2thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="score_2thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:score_2thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants and Structures Related with the Thread Control Block. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threaddispatch_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threaddispatch_8h.html">threaddispatch.h</a></td></tr>
<tr class="memdesc:threaddispatch_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants and Structures Related with Thread Dispatch. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadidledata_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadidledata_8h.html">threadidledata.h</a></td></tr>
<tr class="memdesc:threadidledata_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for the idle threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadimpl_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadimpl_8h.html">threadimpl.h</a></td></tr>
<tr class="memdesc:threadimpl_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined Routines from the Thread Handler. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:iterateoverthreads_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iterateoverthreads_8c.html">iterateoverthreads.c</a></td></tr>
<tr class="memdesc:iterateoverthreads_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates Over All Threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:thread_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html">thread.c</a></td></tr>
<tr class="memdesc:thread_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Thread Handler. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadallocateunlimited_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadallocateunlimited_8c.html">threadallocateunlimited.c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadchangepriority_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadchangepriority_8c.html">threadchangepriority.c</a></td></tr>
<tr class="memdesc:threadchangepriority_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Priority of a Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadclearstate_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadclearstate_8c.html">threadclearstate.c</a></td></tr>
<tr class="memdesc:threadclearstate_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Thread state. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadcreateidle_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadcreateidle_8c.html">threadcreateidle.c</a></td></tr>
<tr class="memdesc:threadcreateidle_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Idle Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threaddispatch_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threaddispatch_8c.html">threaddispatch.c</a></td></tr>
<tr class="memdesc:threaddispatch_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadget_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadget_8c.html">threadget.c</a></td></tr>
<tr class="memdesc:threadget_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps Thread IDs to TCB Pointer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadhandler_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadhandler_8c.html">threadhandler.c</a></td></tr>
<tr class="memdesc:threadhandler_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Handler. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadinitialize_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadinitialize_8c.html">threadinitialize.c</a></td></tr>
<tr class="memdesc:threadinitialize_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadloadenv_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadloadenv_8c.html">threadloadenv.c</a></td></tr>
<tr class="memdesc:threadloadenv_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes Enviroment for A Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadrestart_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadrestart_8c.html">threadrestart.c</a></td></tr>
<tr class="memdesc:threadrestart_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadsetstate_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadsetstate_8c.html">threadsetstate.c</a></td></tr>
<tr class="memdesc:threadsetstate_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets States for a Thread. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadstart_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadstart_8c.html">threadstart.c</a></td></tr>
<tr class="memdesc:threadstart_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes Thread and Executes it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadstartmultitasking_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadstartmultitasking_8c.html">threadstartmultitasking.c</a></td></tr>
<tr class="memdesc:threadstartmultitasking_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Thread Multitasking. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadtimeout_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadtimeout_8c.html">threadtimeout.c</a></td></tr>
<tr class="memdesc:threadtimeout_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Wait Timeout. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:threadyield_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadyield_8c.html">threadyield.c</a></td></tr>
<tr class="memdesc:threadyield_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Yield. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Entry__idle.html">Thread_Entry_idle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for idle thread entry.  <a href="structThread__Entry__idle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Entry__numeric.html">Thread_Entry_numeric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for thread entry with one numeric argument and no return value.  <a href="structThread__Entry__numeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Entry__pointer.html">Thread_Entry_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for thread entry with one pointer argument and a pointer return value.  <a href="structThread__Entry__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread entry information.  <a href="structThread__Entry__information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Start__information.html">Thread_Start_information</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Scheduler__control.html">Thread_Scheduler_control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread scheduler control.  <a href="structThread__Scheduler__control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionThread__Wait__information__Object__argument__type.html">Thread_Wait_information_Object_argument_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union type to hold a pointer to an immutable or a mutable object.  <a href="unionThread__Wait__information__Object__argument__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Wait__information.html">Thread_Wait_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information required to manage a thread while it is blocked.  <a href="structThread__Wait__information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Timer__information.html">Thread_Timer_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information required to manage a thread timer.  <a href="structThread__Timer__information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Proxy__control.html">Thread_Proxy_control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Action.html">Thread_Action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread action.  <a href="structThread__Action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Keys__information.html">Thread_Keys_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-thread information for POSIX Keys.  <a href="structThread__Keys__information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Action__control.html">Thread_Action_control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control block to manage thread actions.  <a href="structThread__Action__control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Life__control.html">Thread_Life_control</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread life control.  <a href="structThread__Life__control.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Capture__control.html">Thread_Capture_control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Thread__Control.html">_Thread_Control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Control__add__on.html">Thread_Control_add_on</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread control add-on.  <a href="structThread__Control__add__on.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Information.html">Thread_Information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread object information.  <a href="structThread__Information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Configuration.html">Thread_Configuration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration of a new thread to initialize.  <a href="structThread__Configuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThread__Close__context.html">Thread_Close_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga999c7d8bffc09330eee98d784487132a"><td class="memItemLeft" align="right" valign="top"><a id="ga999c7d8bffc09330eee98d784487132a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_SCORE_THREAD_ENABLE_EXHAUST_TIMESLICE</b></td></tr>
<tr class="separator:ga999c7d8bffc09330eee98d784487132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d92fbff0443c39af75e4ab458d6cda"><td class="memItemLeft" align="right" valign="top"><a id="ga26d92fbff0443c39af75e4ab458d6cda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_SCORE_THREAD_ENABLE_SCHEDULER_CALLOUT</b></td></tr>
<tr class="separator:ga26d92fbff0443c39af75e4ab458d6cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8beca1577c24c8107f1d30a0b5c1c4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaa8beca1577c24c8107f1d30a0b5c1c4c">THREAD_API_FIRST</a>&#160;&#160;&#160;<a class="el" href="group__RTEMSScoreThread.html#ggaf87b9c0fbba9460ccb284584454c5280abe3da3f1c02de606c8ff1488564a0a73">THREAD_API_RTEMS</a></td></tr>
<tr class="separator:gaa8beca1577c24c8107f1d30a0b5c1c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9eede8eaa139d657213be4d38a5f756"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae9eede8eaa139d657213be4d38a5f756">THREAD_API_LAST</a>&#160;&#160;&#160;<a class="el" href="group__RTEMSScoreThread.html#ggaf87b9c0fbba9460ccb284584454c5280a643780b2fad6bb2de6b6688b2f2423cc">THREAD_API_POSIX</a></td></tr>
<tr class="separator:gae9eede8eaa139d657213be4d38a5f756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e095a67ea3f48b97721e9c2be35a8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga68e095a67ea3f48b97721e9c2be35a8a">THREAD_DEFAULT_MAXIMUM_NAME_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga68e095a67ea3f48b97721e9c2be35a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum size of a thread name in characters (including the terminating '\0' character).  <a href="#ga68e095a67ea3f48b97721e9c2be35a8a">More...</a><br /></td></tr>
<tr class="separator:ga68e095a67ea3f48b97721e9c2be35a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a02e6653cabfda359b41cc391a7ae4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga51a02e6653cabfda359b41cc391a7ae4">_Thread_queue_Heads_size</a>&#160;&#160;&#160;sizeof(<a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a>)</td></tr>
<tr class="memdesc:ga51a02e6653cabfda359b41cc391a7ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the thread queue heads of a particular application.  <a href="#ga51a02e6653cabfda359b41cc391a7ae4">More...</a><br /></td></tr>
<tr class="separator:ga51a02e6653cabfda359b41cc391a7ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd41a9bcb4638f354c0ca1f721ff500"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_INFORMATION_DEFINE_ZERO</b>(name,  api,  cls)</td></tr>
<tr class="separator:gabcd41a9bcb4638f354c0ca1f721ff500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b827079acdd2597db9cbb6f69d12b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>THREAD_INFORMATION_DEFINE</b>(name,  api,  cls,  max)</td></tr>
<tr class="separator:ga57b827079acdd2597db9cbb6f69d12b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf826e03e6ef568e8773a98274b64e069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaf826e03e6ef568e8773a98274b64e069">RTEMS_SCORE_ROBUST_THREAD_DISPATCH</a></td></tr>
<tr class="memdesc:gaf826e03e6ef568e8773a98274b64e069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a robust thread dispatch.  <a href="#gaf826e03e6ef568e8773a98274b64e069">More...</a><br /></td></tr>
<tr class="separator:gaf826e03e6ef568e8773a98274b64e069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78eb026f8d00b7dfb3d8b5c82a5d888a"><td class="memItemLeft" align="right" valign="top"><a id="ga78eb026f8d00b7dfb3d8b5c82a5d888a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga78eb026f8d00b7dfb3d8b5c82a5d888a">THREAD_WAIT_FLAGS_INITIAL</a>&#160;&#160;&#160;0x0U</td></tr>
<tr class="memdesc:ga78eb026f8d00b7dfb3d8b5c82a5d888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial thread wait flags value set by <a class="el" href="group__RTEMSScoreThread.html#gab4f561fd816d0b93318afa48f609fad2" title="Initializes thread.">_Thread_Initialize()</a>. <br /></td></tr>
<tr class="separator:ga78eb026f8d00b7dfb3d8b5c82a5d888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac0d0df4596a8518bced0bc0a52c41c7"><td class="memItemLeft" align="right" valign="top"><a id="gaac0d0df4596a8518bced0bc0a52c41c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaac0d0df4596a8518bced0bc0a52c41c7">THREAD_WAIT_STATE_MASK</a>&#160;&#160;&#160;0xffU</td></tr>
<tr class="memdesc:gaac0d0df4596a8518bced0bc0a52c41c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get the thread wait state flags. <br /></td></tr>
<tr class="separator:gaac0d0df4596a8518bced0bc0a52c41c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82059fe7353c5129db4c812b7c82f6bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga82059fe7353c5129db4c812b7c82f6bf">THREAD_WAIT_STATE_INTEND_TO_BLOCK</a>&#160;&#160;&#160;0x1U</td></tr>
<tr class="memdesc:ga82059fe7353c5129db4c812b7c82f6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread begins with the blocking operation.  <a href="#ga82059fe7353c5129db4c812b7c82f6bf">More...</a><br /></td></tr>
<tr class="separator:ga82059fe7353c5129db4c812b7c82f6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9487eb8db998d29cb1f712155769583"><td class="memItemLeft" align="right" valign="top"><a id="gaa9487eb8db998d29cb1f712155769583"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaa9487eb8db998d29cb1f712155769583">THREAD_WAIT_STATE_BLOCKED</a>&#160;&#160;&#160;0x2U</td></tr>
<tr class="memdesc:gaa9487eb8db998d29cb1f712155769583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread completed the blocking operation. <br /></td></tr>
<tr class="separator:gaa9487eb8db998d29cb1f712155769583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00cb9ccdda63a4731f4d80a89371ea0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gac00cb9ccdda63a4731f4d80a89371ea0">THREAD_WAIT_STATE_READY_AGAIN</a>&#160;&#160;&#160;0x4U</td></tr>
<tr class="memdesc:gac00cb9ccdda63a4731f4d80a89371ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a condition to end the thread wait occurred.  <a href="#gac00cb9ccdda63a4731f4d80a89371ea0">More...</a><br /></td></tr>
<tr class="separator:gac00cb9ccdda63a4731f4d80a89371ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f763ac3474c8e2e5a493de0f9fd676"><td class="memItemLeft" align="right" valign="top"><a id="gab8f763ac3474c8e2e5a493de0f9fd676"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab8f763ac3474c8e2e5a493de0f9fd676">THREAD_WAIT_CLASS_MASK</a>&#160;&#160;&#160;0xff00U</td></tr>
<tr class="memdesc:gab8f763ac3474c8e2e5a493de0f9fd676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get the thread wait class flags. <br /></td></tr>
<tr class="separator:gab8f763ac3474c8e2e5a493de0f9fd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe28b0cc1c352513a17974207cf9f4b"><td class="memItemLeft" align="right" valign="top"><a id="gaefe28b0cc1c352513a17974207cf9f4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaefe28b0cc1c352513a17974207cf9f4b">THREAD_WAIT_CLASS_EVENT</a>&#160;&#160;&#160;0x100U</td></tr>
<tr class="memdesc:gaefe28b0cc1c352513a17974207cf9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread waits for an event. <br /></td></tr>
<tr class="separator:gaefe28b0cc1c352513a17974207cf9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87c9c823f1022eb0843801438b91f29"><td class="memItemLeft" align="right" valign="top"><a id="gad87c9c823f1022eb0843801438b91f29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad87c9c823f1022eb0843801438b91f29">THREAD_WAIT_CLASS_SYSTEM_EVENT</a>&#160;&#160;&#160;0x200U</td></tr>
<tr class="memdesc:gad87c9c823f1022eb0843801438b91f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread waits for a system event. <br /></td></tr>
<tr class="separator:gad87c9c823f1022eb0843801438b91f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad326b1eb2ad7ab1c74a69052aac37c"><td class="memItemLeft" align="right" valign="top"><a id="ga8ad326b1eb2ad7ab1c74a69052aac37c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga8ad326b1eb2ad7ab1c74a69052aac37c">THREAD_WAIT_CLASS_OBJECT</a>&#160;&#160;&#160;0x400U</td></tr>
<tr class="memdesc:ga8ad326b1eb2ad7ab1c74a69052aac37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread waits for an object. <br /></td></tr>
<tr class="separator:ga8ad326b1eb2ad7ab1c74a69052aac37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c32beedd8bfee369f065b40a33a8af7"><td class="memItemLeft" align="right" valign="top"><a id="ga3c32beedd8bfee369f065b40a33a8af7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3c32beedd8bfee369f065b40a33a8af7">THREAD_WAIT_CLASS_PERIOD</a>&#160;&#160;&#160;0x800U</td></tr>
<tr class="memdesc:ga3c32beedd8bfee369f065b40a33a8af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread waits for a period. <br /></td></tr>
<tr class="separator:ga3c32beedd8bfee369f065b40a33a8af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7f0af080cbd9a675e6620229577bd498"><td class="memItemLeft" align="right" valign="top"><a id="ga7f0af080cbd9a675e6620229577bd498"></a>
typedef void *Thread&#160;</td><td class="memItemRight" valign="bottom"><b>RTEMS_DEPRECATED</b></td></tr>
<tr class="separator:ga7f0af080cbd9a675e6620229577bd498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56e437830bb9a4af5b27ac7ec503b6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__RTEMSScoreCPUARM.html#ga9fca17f81f850e128fcc8ed5b87ff2ab">CPU_Uint32ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab56e437830bb9a4af5b27ac7ec503b6a">Thread_Entry_numeric_type</a></td></tr>
<tr class="memdesc:gab56e437830bb9a4af5b27ac7ec503b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the numeric argument of a thread entry function with at least one numeric argument.  <a href="#gab56e437830bb9a4af5b27ac7ec503b6a">More...</a><br /></td></tr>
<tr class="separator:gab56e437830bb9a4af5b27ac7ec503b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f15cbe9653e5bfcb2595454e9ffd14a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga2f15cbe9653e5bfcb2595454e9ffd14a">Thread_CPU_budget_algorithm_callout</a>) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *)</td></tr>
<tr class="separator:ga2f15cbe9653e5bfcb2595454e9ffd14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a047ae9c77bc90a258203d4f2cc57db"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a></td></tr>
<tr class="memdesc:ga9a047ae9c77bc90a258203d4f2cc57db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is able to contain several flags used to control the wait class and state of a thread.  <a href="#ga9a047ae9c77bc90a258203d4f2cc57db">More...</a><br /></td></tr>
<tr class="separator:ga9a047ae9c77bc90a258203d4f2cc57db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e09db039db106f22c17c0b8e4bd748c"><td class="memItemLeft" align="right" valign="top"><a id="ga5e09db039db106f22c17c0b8e4bd748c"></a>
typedef struct <a class="el" href="structThread__Action.html">Thread_Action</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_Action</b></td></tr>
<tr class="separator:ga5e09db039db106f22c17c0b8e4bd748c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed91c6271fd8090120d824662541c74"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3ed91c6271fd8090120d824662541c74">Thread_Action_handler</a>) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__Action.html">Thread_Action</a> *action, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga3ed91c6271fd8090120d824662541c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread action handler.  <a href="#ga3ed91c6271fd8090120d824662541c74">More...</a><br /></td></tr>
<tr class="separator:ga3ed91c6271fd8090120d824662541c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2d551ce2693b640db21f452d6436b8"><td class="memItemLeft" align="right" valign="top"><a id="ga3c2d551ce2693b640db21f452d6436b8"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_per_thread_routine</b>) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *)</td></tr>
<tr class="separator:ga3c2d551ce2693b640db21f452d6436b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9fc745768399b59fb0ff5e81838540"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__RTEMSScoreThread.html#gadf9fc745768399b59fb0ff5e81838540">Thread_Configured_control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gadf9fc745768399b59fb0ff5e81838540">Thread_Configured_control</a></td></tr>
<tr class="memdesc:gadf9fc745768399b59fb0ff5e81838540"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configured thread control block.  <a href="#gadf9fc745768399b59fb0ff5e81838540">More...</a><br /></td></tr>
<tr class="separator:gadf9fc745768399b59fb0ff5e81838540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2edd6c043930e8159685c0cb2e19ca7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gac2edd6c043930e8159685c0cb2e19ca7">Thread_queue_Configured_heads</a></td></tr>
<tr class="memdesc:gac2edd6c043930e8159685c0cb2e19ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configured thread queue heads.  <a href="#gac2edd6c043930e8159685c0cb2e19ca7">More...</a><br /></td></tr>
<tr class="separator:gac2edd6c043930e8159685c0cb2e19ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e6fd0b5cd35ee2ea9e36be90a84c1b"><td class="memItemLeft" align="right" valign="top"><a id="ga45e6fd0b5cd35ee2ea9e36be90a84c1b"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga45e6fd0b5cd35ee2ea9e36be90a84c1b">Thread_Idle_body</a>) (uintptr_t)</td></tr>
<tr class="memdesc:ga45e6fd0b5cd35ee2ea9e36be90a84c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The idle thread body type. <br /></td></tr>
<tr class="separator:ga45e6fd0b5cd35ee2ea9e36be90a84c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132f6ea936a5073b50fa88f6a46805bc"><td class="memItemLeft" align="right" valign="top"><a id="ga132f6ea936a5073b50fa88f6a46805bc"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_Visitor</b>) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, void *arg)</td></tr>
<tr class="separator:ga132f6ea936a5073b50fa88f6a46805bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab6f48556812ffc781a69df144ef49be0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab6f48556812ffc781a69df144ef49be0">Thread_CPU_budget_algorithms</a> { <b>THREAD_CPU_BUDGET_ALGORITHM_NONE</b>, 
<b>THREAD_CPU_BUDGET_ALGORITHM_RESET_TIMESLICE</b>, 
<b>THREAD_CPU_BUDGET_ALGORITHM_EXHAUST_TIMESLICE</b>, 
<b>THREAD_CPU_BUDGET_ALGORITHM_CALLOUT</b>
 }</td></tr>
<tr class="separator:gab6f48556812ffc781a69df144ef49be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87b9c0fbba9460ccb284584454c5280"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaf87b9c0fbba9460ccb284584454c5280">Thread_APIs</a> { <a class="el" href="group__RTEMSScoreThread.html#ggaf87b9c0fbba9460ccb284584454c5280abe3da3f1c02de606c8ff1488564a0a73">THREAD_API_RTEMS</a>, 
<a class="el" href="group__RTEMSScoreThread.html#ggaf87b9c0fbba9460ccb284584454c5280a643780b2fad6bb2de6b6688b2f2423cc">THREAD_API_POSIX</a>
 }</td></tr>
<tr class="separator:gaf87b9c0fbba9460ccb284584454c5280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4c61e432a0c21855e3122bb394583d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> { <br />
&#160;&#160;<b>THREAD_LIFE_PROTECTED</b> = 0x1, 
<b>THREAD_LIFE_RESTARTING</b> = 0x2, 
<b>THREAD_LIFE_TERMINATING</b> = 0x4, 
<b>THREAD_LIFE_CHANGE_DEFERRED</b> = 0x8, 
<br />
&#160;&#160;<b>THREAD_LIFE_DETACHED</b> = 0x10
<br />
 }</td></tr>
<tr class="memdesc:ga0b4c61e432a0c21855e3122bb394583d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread life states.  <a href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">More...</a><br /></td></tr>
<tr class="separator:ga0b4c61e432a0c21855e3122bb394583d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5dc64d34fc67591fa08d18fb6aa055ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga5dc64d34fc67591fa08d18fb6aa055ca">rtems_iterate_over_all_threads</a> (rtems_per_thread_routine routine) <a class="el" href="group__RTEMSScoreBaseDefs.html#gab651a076d4d51d50221e7ef7ac99d4e7">RTEMS_DEPRECATED</a></td></tr>
<tr class="memdesc:ga5dc64d34fc67591fa08d18fb6aa055ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, use <a class="el" href="group__ClassicTasks.html#ga7255f41eb20238aebe5ce139d5dfd97d" title="Iterates over all tasks in the system.">rtems_task_iterate()</a> instead.  <a href="#ga5dc64d34fc67591fa08d18fb6aa055ca">More...</a><br /></td></tr>
<tr class="separator:ga5dc64d34fc67591fa08d18fb6aa055ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb5db6d9e872bde5dc6d3d3489bcc19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structObjects__Control.html">Objects_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga2cb5db6d9e872bde5dc6d3d3489bcc19">_Thread_Allocate_unlimited</a> (<a class="el" href="structObjects__Information.html">Objects_Information</a> *information)</td></tr>
<tr class="memdesc:ga2cb5db6d9e872bde5dc6d3d3489bcc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an inactive thread object or NULL.  <a href="#ga2cb5db6d9e872bde5dc6d3d3489bcc19">More...</a><br /></td></tr>
<tr class="separator:ga2cb5db6d9e872bde5dc6d3d3489bcc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa847ae7c8e3c4cf3f3f3f082124eac8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaa847ae7c8e3c4cf3f3f3f082124eac8e">_Thread_Dispatch_is_enabled</a> (void)</td></tr>
<tr class="memdesc:gaa847ae7c8e3c4cf3f3f3f082124eac8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the executing thread is inside a thread dispatch critical section.  <a href="#gaa847ae7c8e3c4cf3f3f3f082124eac8e">More...</a><br /></td></tr>
<tr class="separator:gaa847ae7c8e3c4cf3f3f3f082124eac8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f098a76c363d6d1daff302c5d7a9d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3f098a76c363d6d1daff302c5d7a9d9b">_Thread_Dispatch_get_disable_level</a> (void)</td></tr>
<tr class="memdesc:ga3f098a76c363d6d1daff302c5d7a9d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets thread dispatch disable level.  <a href="#ga3f098a76c363d6d1daff302c5d7a9d9b">More...</a><br /></td></tr>
<tr class="separator:ga3f098a76c363d6d1daff302c5d7a9d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b097ce535f591840d891f691812759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae1b097ce535f591840d891f691812759">_Thread_Dispatch_initialization</a> (void)</td></tr>
<tr class="memdesc:gae1b097ce535f591840d891f691812759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread dispatch initialization.  <a href="#gae1b097ce535f591840d891f691812759">More...</a><br /></td></tr>
<tr class="separator:gae1b097ce535f591840d891f691812759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e949c0f400cda43b1e7547e50b088d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga14e949c0f400cda43b1e7547e50b088d">_Thread_Dispatch</a> (void)</td></tr>
<tr class="memdesc:ga14e949c0f400cda43b1e7547e50b088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a thread dispatch if necessary.  <a href="#ga14e949c0f400cda43b1e7547e50b088d">More...</a><br /></td></tr>
<tr class="separator:ga14e949c0f400cda43b1e7547e50b088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4251559fe6a0c06762de333bca275f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab4251559fe6a0c06762de333bca275f5">_Thread_Dispatch_direct</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self)</td></tr>
<tr class="memdesc:gab4251559fe6a0c06762de333bca275f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly do a thread dispatch.  <a href="#gab4251559fe6a0c06762de333bca275f5">More...</a><br /></td></tr>
<tr class="separator:gab4251559fe6a0c06762de333bca275f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ea5fef985f18cd60d85d9cedab4c6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaf0ea5fef985f18cd60d85d9cedab4c6c">_Thread_Do_dispatch</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="group__RTEMSScoreISR.html#gad1af728587ebcefec5b5cf94fc7909b9">ISR_Level</a> level)</td></tr>
<tr class="memdesc:gaf0ea5fef985f18cd60d85d9cedab4c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a thread dispatch on the current processor.  <a href="#gaf0ea5fef985f18cd60d85d9cedab4c6c">More...</a><br /></td></tr>
<tr class="separator:gaf0ea5fef985f18cd60d85d9cedab4c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a71da4ea096f7ea92781a872b955ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga80a71da4ea096f7ea92781a872b955ae">_Thread_Dispatch_disable_with_CPU</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, const <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga80a71da4ea096f7ea92781a872b955ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables thread dispatching inside a critical section (interrupts disabled) with the current processor.  <a href="#ga80a71da4ea096f7ea92781a872b955ae">More...</a><br /></td></tr>
<tr class="separator:ga80a71da4ea096f7ea92781a872b955ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffeb81480c63293a317f69efc74dec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga5ffeb81480c63293a317f69efc74dec3">_Thread_Dispatch_disable_critical</a> (const <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga5ffeb81480c63293a317f69efc74dec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables thread dispatching inside a critical section (interrupts disabled).  <a href="#ga5ffeb81480c63293a317f69efc74dec3">More...</a><br /></td></tr>
<tr class="separator:ga5ffeb81480c63293a317f69efc74dec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044bfb6e9317180d21b05c5338cedd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga044bfb6e9317180d21b05c5338cedd1a">_Thread_Dispatch_disable</a> (void)</td></tr>
<tr class="memdesc:ga044bfb6e9317180d21b05c5338cedd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables thread dispatching.  <a href="#ga044bfb6e9317180d21b05c5338cedd1a">More...</a><br /></td></tr>
<tr class="separator:ga044bfb6e9317180d21b05c5338cedd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c773b97624be1dc304a2d3d038f19a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab0c773b97624be1dc304a2d3d038f19a">_Thread_Dispatch_enable</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self)</td></tr>
<tr class="memdesc:gab0c773b97624be1dc304a2d3d038f19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables thread dispatching.  <a href="#gab0c773b97624be1dc304a2d3d038f19a">More...</a><br /></td></tr>
<tr class="separator:gab0c773b97624be1dc304a2d3d038f19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89324d5b965715261d6fa55527297b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga89324d5b965715261d6fa55527297b1a">_Thread_Dispatch_unnest</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self)</td></tr>
<tr class="memdesc:ga89324d5b965715261d6fa55527297b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unnests thread dispatching.  <a href="#ga89324d5b965715261d6fa55527297b1a">More...</a><br /></td></tr>
<tr class="separator:ga89324d5b965715261d6fa55527297b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216a6330c178a36afc4eb50a4a66ba4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga216a6330c178a36afc4eb50a4a66ba4a">_Thread_Dispatch_request</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_target)</td></tr>
<tr class="memdesc:ga216a6330c178a36afc4eb50a4a66ba4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a thread dispatch on the target processor.  <a href="#ga216a6330c178a36afc4eb50a4a66ba4a">More...</a><br /></td></tr>
<tr class="separator:ga216a6330c178a36afc4eb50a4a66ba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf2d81d16187ed8808e76addc8da0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaccf2d81d16187ed8808e76addc8da0ed">_Thread_Iterate</a> (Thread_Visitor visitor, void *arg)</td></tr>
<tr class="memdesc:gaccf2d81d16187ed8808e76addc8da0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the visitor with all threads and the given argument until it is done.  <a href="#gaccf2d81d16187ed8808e76addc8da0ed">More...</a><br /></td></tr>
<tr class="separator:gaccf2d81d16187ed8808e76addc8da0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd86ef6b0e5fb19ec14d7fe51e3868e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gacd86ef6b0e5fb19ec14d7fe51e3868e2">_Thread_Initialize_information</a> (<a class="el" href="structThread__Information.html">Thread_Information</a> *information)</td></tr>
<tr class="memdesc:gacd86ef6b0e5fb19ec14d7fe51e3868e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the thread information.  <a href="#gacd86ef6b0e5fb19ec14d7fe51e3868e2">More...</a><br /></td></tr>
<tr class="separator:gacd86ef6b0e5fb19ec14d7fe51e3868e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439268e164b067a866d2901085c8c672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga439268e164b067a866d2901085c8c672">_Thread_Handler_initialization</a> (void)</td></tr>
<tr class="memdesc:ga439268e164b067a866d2901085c8c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes thread handler.  <a href="#ga439268e164b067a866d2901085c8c672">More...</a><br /></td></tr>
<tr class="separator:ga439268e164b067a866d2901085c8c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a9db1abab176f3d74f4f46a423c2c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga86a9db1abab176f3d74f4f46a423c2c3">_Thread_Create_idle</a> (void)</td></tr>
<tr class="memdesc:ga86a9db1abab176f3d74f4f46a423c2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates idle thread.  <a href="#ga86a9db1abab176f3d74f4f46a423c2c3">More...</a><br /></td></tr>
<tr class="separator:ga86a9db1abab176f3d74f4f46a423c2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab27215302814d0aa0ec3306b165ea247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab27215302814d0aa0ec3306b165ea247">_Thread_Start_multitasking</a> (void) <a class="el" href="group__RTEMSScoreBaseDefs.html#gaa2f0ed67aa174f684bb31b7e8bdb386f">RTEMS_NO_RETURN</a></td></tr>
<tr class="memdesc:gab27215302814d0aa0ec3306b165ea247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts thread multitasking.  <a href="#gab27215302814d0aa0ec3306b165ea247">More...</a><br /></td></tr>
<tr class="separator:gab27215302814d0aa0ec3306b165ea247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f561fd816d0b93318afa48f609fad2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab4f561fd816d0b93318afa48f609fad2">_Thread_Initialize</a> (<a class="el" href="structThread__Information.html">Thread_Information</a> *information, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, const <a class="el" href="structThread__Configuration.html">Thread_Configuration</a> *<a class="el" href="structconfig__s.html">config</a>)</td></tr>
<tr class="memdesc:gab4f561fd816d0b93318afa48f609fad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes thread.  <a href="#gab4f561fd816d0b93318afa48f609fad2">More...</a><br /></td></tr>
<tr class="separator:gab4f561fd816d0b93318afa48f609fad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03378c6b7617ec1b5fcc541423e662e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga03378c6b7617ec1b5fcc541423e662e5">_Thread_Start</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, const <a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a> *<a class="el" href="structentry.html">entry</a>, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga03378c6b7617ec1b5fcc541423e662e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes thread and executes it.  <a href="#ga03378c6b7617ec1b5fcc541423e662e5">More...</a><br /></td></tr>
<tr class="separator:ga03378c6b7617ec1b5fcc541423e662e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbbb447ef2795643c4055ecd2b0f714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaecbbb447ef2795643c4055ecd2b0f714">_Thread_Restart_self</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing, const <a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a> *<a class="el" href="structentry.html">entry</a>, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context) <a class="el" href="group__RTEMSScoreBaseDefs.html#gaa2f0ed67aa174f684bb31b7e8bdb386f">RTEMS_NO_RETURN</a></td></tr>
<tr class="memdesc:gaecbbb447ef2795643c4055ecd2b0f714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts the currently executing thread.  <a href="#gaecbbb447ef2795643c4055ecd2b0f714">More...</a><br /></td></tr>
<tr class="separator:gaecbbb447ef2795643c4055ecd2b0f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509001fb716aaf996d70507d74b769ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga509001fb716aaf996d70507d74b769ea">_Thread_Restart_other</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, const <a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a> *<a class="el" href="structentry.html">entry</a>, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga509001fb716aaf996d70507d74b769ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts the thread.  <a href="#ga509001fb716aaf996d70507d74b769ea">More...</a><br /></td></tr>
<tr class="separator:ga509001fb716aaf996d70507d74b769ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c1e28e7fcc27135782ff978dcdcb8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga82c1e28e7fcc27135782ff978dcdcb8f">_Thread_Yield</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:ga82c1e28e7fcc27135782ff978dcdcb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the currently executing thread.  <a href="#ga82c1e28e7fcc27135782ff978dcdcb8f">More...</a><br /></td></tr>
<tr class="separator:ga82c1e28e7fcc27135782ff978dcdcb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e2c11aa0d3c505d0d3e264fbb6bbe7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7e2c11aa0d3c505d0d3e264fbb6bbe7e">_Thread_Change_life</a> (<a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> clear, <a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> set, <a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> ignore)</td></tr>
<tr class="memdesc:ga7e2c11aa0d3c505d0d3e264fbb6bbe7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the currently executing thread to a new state with the sets.  <a href="#ga7e2c11aa0d3c505d0d3e264fbb6bbe7e">More...</a><br /></td></tr>
<tr class="separator:ga7e2c11aa0d3c505d0d3e264fbb6bbe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5aaea7af4482aebd880403fb9c238af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad5aaea7af4482aebd880403fb9c238af">_Thread_Set_life_protection</a> (<a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> state)</td></tr>
<tr class="memdesc:gad5aaea7af4482aebd880403fb9c238af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread to life protected.  <a href="#gad5aaea7af4482aebd880403fb9c238af">More...</a><br /></td></tr>
<tr class="separator:gad5aaea7af4482aebd880403fb9c238af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986b5354464f933956a6ea28ba9b74a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga986b5354464f933956a6ea28ba9b74a2">_Thread_Kill_zombies</a> (void)</td></tr>
<tr class="memdesc:ga986b5354464f933956a6ea28ba9b74a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kills all zombie threads in the system.  <a href="#ga986b5354464f933956a6ea28ba9b74a2">More...</a><br /></td></tr>
<tr class="separator:ga986b5354464f933956a6ea28ba9b74a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bebb00c256fb08bd5c1bdf546c5e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga99bebb00c256fb08bd5c1bdf546c5e1f">_Thread_Exit</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing, <a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> set, void *exit_value)</td></tr>
<tr class="memdesc:ga99bebb00c256fb08bd5c1bdf546c5e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits the currently executing thread.  <a href="#ga99bebb00c256fb08bd5c1bdf546c5e1f">More...</a><br /></td></tr>
<tr class="separator:ga99bebb00c256fb08bd5c1bdf546c5e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659bc82bc257e001d0b94f10436fbab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga659bc82bc257e001d0b94f10436fbab2">_Thread_Join</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> waiting_for_join, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga659bc82bc257e001d0b94f10436fbab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the currently executing thread with the given thread to wait for.  <a href="#ga659bc82bc257e001d0b94f10436fbab2">More...</a><br /></td></tr>
<tr class="separator:ga659bc82bc257e001d0b94f10436fbab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1fb3719c77dc89881e4686fad81eeee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab1fb3719c77dc89881e4686fad81eeee">_Thread_Cancel</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing, void *exit_value)</td></tr>
<tr class="memdesc:gab1fb3719c77dc89881e4686fad81eeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels the thread.  <a href="#gab1fb3719c77dc89881e4686fad81eeee">More...</a><br /></td></tr>
<tr class="separator:gab1fb3719c77dc89881e4686fad81eeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42a844061758d4a5bda639ffc21b8f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaf42a844061758d4a5bda639ffc21b8f5">_Thread_Close</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing, <a class="el" href="structThread__Close__context.html">Thread_Close_context</a> *<a class="el" href="sun4u_2tte_8h.html#a9b4a99475e2709333b8e5d70483173f1">context</a>)</td></tr>
<tr class="memdesc:gaf42a844061758d4a5bda639ffc21b8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the thread.  <a href="#gaf42a844061758d4a5bda639ffc21b8f5">More...</a><br /></td></tr>
<tr class="separator:gaf42a844061758d4a5bda639ffc21b8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4493fc6ffddc8fd05987cb405f9cf71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab4493fc6ffddc8fd05987cb405f9cf71">_Thread_Is_ready</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gab4493fc6ffddc8fd05987cb405f9cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread is ready.  <a href="#gab4493fc6ffddc8fd05987cb405f9cf71">More...</a><br /></td></tr>
<tr class="separator:gab4493fc6ffddc8fd05987cb405f9cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54a6095e8c9f868b54545fdbfc8f061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae54a6095e8c9f868b54545fdbfc8f061">_Thread_Clear_state_locked</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> state)</td></tr>
<tr class="memdesc:gae54a6095e8c9f868b54545fdbfc8f061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified thread state without locking the lock context.  <a href="#gae54a6095e8c9f868b54545fdbfc8f061">More...</a><br /></td></tr>
<tr class="separator:gae54a6095e8c9f868b54545fdbfc8f061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e35e9ebb9a5364d00f1f1b1e166e701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7e35e9ebb9a5364d00f1f1b1e166e701">_Thread_Clear_state</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> state)</td></tr>
<tr class="memdesc:ga7e35e9ebb9a5364d00f1f1b1e166e701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified thread state.  <a href="#ga7e35e9ebb9a5364d00f1f1b1e166e701">More...</a><br /></td></tr>
<tr class="separator:ga7e35e9ebb9a5364d00f1f1b1e166e701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6439dfd95e92d9d3b2679d2b7c6891a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad6439dfd95e92d9d3b2679d2b7c6891a">_Thread_Set_state_locked</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> state)</td></tr>
<tr class="memdesc:gad6439dfd95e92d9d3b2679d2b7c6891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified thread state without locking the lock context.  <a href="#gad6439dfd95e92d9d3b2679d2b7c6891a">More...</a><br /></td></tr>
<tr class="separator:gad6439dfd95e92d9d3b2679d2b7c6891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630f8dade381bc0c0c70298a757acba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga630f8dade381bc0c0c70298a757acba8">_Thread_Set_state</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> state)</td></tr>
<tr class="memdesc:ga630f8dade381bc0c0c70298a757acba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified thread state.  <a href="#ga630f8dade381bc0c0c70298a757acba8">More...</a><br /></td></tr>
<tr class="separator:ga630f8dade381bc0c0c70298a757acba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade10731d5bc6570cc485999da44acd43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gade10731d5bc6570cc485999da44acd43">_Thread_Load_environment</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gade10731d5bc6570cc485999da44acd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes enviroment for a thread.  <a href="#gade10731d5bc6570cc485999da44acd43">More...</a><br /></td></tr>
<tr class="separator:gade10731d5bc6570cc485999da44acd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15433c1ca9df669c036739a50a8d1b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga15433c1ca9df669c036739a50a8d1b9a">_Thread_Entry_adaptor_idle</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:ga15433c1ca9df669c036739a50a8d1b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the start kinds idle entry of the thread.  <a href="#ga15433c1ca9df669c036739a50a8d1b9a">More...</a><br /></td></tr>
<tr class="separator:ga15433c1ca9df669c036739a50a8d1b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9223b77920482b86fba30d4113be119f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga9223b77920482b86fba30d4113be119f">_Thread_Entry_adaptor_numeric</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:ga9223b77920482b86fba30d4113be119f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the start kinds numeric entry of the thread.  <a href="#ga9223b77920482b86fba30d4113be119f">More...</a><br /></td></tr>
<tr class="separator:ga9223b77920482b86fba30d4113be119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2283a605738e5b3fd2e1710ea8b73a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaac2283a605738e5b3fd2e1710ea8b73a">_Thread_Entry_adaptor_pointer</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:gaac2283a605738e5b3fd2e1710ea8b73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the start kinds pointer entry of the thread.  <a href="#gaac2283a605738e5b3fd2e1710ea8b73a">More...</a><br /></td></tr>
<tr class="separator:gaac2283a605738e5b3fd2e1710ea8b73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c3a615798c7cc70dc9ff6d9317df46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae0c3a615798c7cc70dc9ff6d9317df46">_Thread_Handler</a> (void)</td></tr>
<tr class="memdesc:gae0c3a615798c7cc70dc9ff6d9317df46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for all threads.  <a href="#gae0c3a615798c7cc70dc9ff6d9317df46">More...</a><br /></td></tr>
<tr class="separator:gae0c3a615798c7cc70dc9ff6d9317df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7ff215edf64b4611da7b7c1d4e3050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gafd7ff215edf64b4611da7b7c1d4e3050">_Thread_State_acquire_critical</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gafd7ff215edf64b4611da7b7c1d4e3050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock context in a critical section.  <a href="#gafd7ff215edf64b4611da7b7c1d4e3050">More...</a><br /></td></tr>
<tr class="separator:gafd7ff215edf64b4611da7b7c1d4e3050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a583864cdcbb7eaeda8002d05de6912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga9a583864cdcbb7eaeda8002d05de6912">_Thread_State_acquire</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga9a583864cdcbb7eaeda8002d05de6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables interrupts and acquires the lock_context.  <a href="#ga9a583864cdcbb7eaeda8002d05de6912">More...</a><br /></td></tr>
<tr class="separator:ga9a583864cdcbb7eaeda8002d05de6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21404c6b38c1c88748cec78a4bbd25f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga21404c6b38c1c88748cec78a4bbd25f1">_Thread_State_acquire_for_executing</a> (<a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga21404c6b38c1c88748cec78a4bbd25f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables interrupts and acquires the lock context for the currently executing thread.  <a href="#ga21404c6b38c1c88748cec78a4bbd25f1">More...</a><br /></td></tr>
<tr class="separator:ga21404c6b38c1c88748cec78a4bbd25f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab003d620d9c5fc5502cedd90960d59d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab003d620d9c5fc5502cedd90960d59d5">_Thread_State_release_critical</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gab003d620d9c5fc5502cedd90960d59d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the lock context in a critical section.  <a href="#gab003d620d9c5fc5502cedd90960d59d5">More...</a><br /></td></tr>
<tr class="separator:gab003d620d9c5fc5502cedd90960d59d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958218590f858b65855c89802b2cc071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga958218590f858b65855c89802b2cc071">_Thread_State_release</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga958218590f858b65855c89802b2cc071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock context and enables interrupts.  <a href="#ga958218590f858b65855c89802b2cc071">More...</a><br /></td></tr>
<tr class="separator:ga958218590f858b65855c89802b2cc071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga611029596b3c9930b05c97cbaef6cb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga611029596b3c9930b05c97cbaef6cb24">_Thread_Priority_perform_actions</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *start_of_path, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga611029596b3c9930b05c97cbaef6cb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread is owner of the lock of the join queue.  <a href="#ga611029596b3c9930b05c97cbaef6cb24">More...</a><br /></td></tr>
<tr class="separator:ga611029596b3c9930b05c97cbaef6cb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d04f5124606eff3a1da3d42cc79e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga58d04f5124606eff3a1da3d42cc79e2f">_Thread_Priority_add</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPriority__Node.html">Priority_Node</a> *priority_node, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga58d04f5124606eff3a1da3d42cc79e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified thread priority node to the corresponding thread priority aggregation.  <a href="#ga58d04f5124606eff3a1da3d42cc79e2f">More...</a><br /></td></tr>
<tr class="separator:ga58d04f5124606eff3a1da3d42cc79e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1e1030ce5bea3614f62e8be650bbeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga8c1e1030ce5bea3614f62e8be650bbeb">_Thread_Priority_remove</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPriority__Node.html">Priority_Node</a> *priority_node, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga8c1e1030ce5bea3614f62e8be650bbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified thread priority node from the corresponding thread priority aggregation.  <a href="#ga8c1e1030ce5bea3614f62e8be650bbeb">More...</a><br /></td></tr>
<tr class="separator:ga8c1e1030ce5bea3614f62e8be650bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c72bf8623d4e8a6b4e5510cdbc4baac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3c72bf8623d4e8a6b4e5510cdbc4baac">_Thread_Priority_changed</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPriority__Node.html">Priority_Node</a> *priority_node, bool prepend_it, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga3c72bf8623d4e8a6b4e5510cdbc4baac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a thread priority value change in the specified thread priority node to the corresponding thread priority aggregation.  <a href="#ga3c72bf8623d4e8a6b4e5510cdbc4baac">More...</a><br /></td></tr>
<tr class="separator:ga3c72bf8623d4e8a6b4e5510cdbc4baac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a9975ac0b320b0a00678534ab78f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga76a9975ac0b320b0a00678534ab78f10">_Thread_Priority_change</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPriority__Node.html">Priority_Node</a> *priority_node, <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> new_priority, bool prepend_it, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga76a9975ac0b320b0a00678534ab78f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the thread priority value of the specified thread priority node in the corresponding thread priority aggregation.  <a href="#ga76a9975ac0b320b0a00678534ab78f10">More...</a><br /></td></tr>
<tr class="separator:ga76a9975ac0b320b0a00678534ab78f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0fe1a67da542aa18a7cbb3d4e2f47a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga4f0fe1a67da542aa18a7cbb3d4e2f47a">_Thread_Priority_replace</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPriority__Node.html">Priority_Node</a> *victim_node, <a class="el" href="structPriority__Node.html">Priority_Node</a> *replacement_node)</td></tr>
<tr class="memdesc:ga4f0fe1a67da542aa18a7cbb3d4e2f47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the victim priority node with the replacement priority node in the corresponding thread priority aggregation.  <a href="#ga4f0fe1a67da542aa18a7cbb3d4e2f47a">More...</a><br /></td></tr>
<tr class="separator:ga4f0fe1a67da542aa18a7cbb3d4e2f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ec96c6cbed5a748565333d5fd7d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59">_Thread_Priority_update</a> (<a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga424ec96c6cbed5a748565333d5fd7d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the priority of all threads in the set.  <a href="#ga424ec96c6cbed5a748565333d5fd7d59">More...</a><br /></td></tr>
<tr class="separator:ga424ec96c6cbed5a748565333d5fd7d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b89051f9d18144e0203d8b7e50630d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gac2b89051f9d18144e0203d8b7e50630d">_Thread_Priority_less_than</a> (<a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> left, <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> right)</td></tr>
<tr class="memdesc:gac2b89051f9d18144e0203d8b7e50630d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the priority of the thread and changes it sticky level.  <a href="#gac2b89051f9d18144e0203d8b7e50630d">More...</a><br /></td></tr>
<tr class="separator:gac2b89051f9d18144e0203d8b7e50630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17eecd5728b1ccac519b8c31f641d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad17eecd5728b1ccac519b8c31f641d6b">_Thread_Priority_highest</a> (<a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> left, <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> right)</td></tr>
<tr class="memdesc:gad17eecd5728b1ccac519b8c31f641d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest priority of the left and right thread priorities in the intuitive sense of priority.  <a href="#gad17eecd5728b1ccac519b8c31f641d6b">More...</a><br /></td></tr>
<tr class="separator:gad17eecd5728b1ccac519b8c31f641d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291d97d78d5460ffa5539964e417bb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structObjects__Information.html">Objects_Information</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga291d97d78d5460ffa5539964e417bb49">_Thread_Get_objects_information</a> (<a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a> id)</td></tr>
<tr class="memdesc:ga291d97d78d5460ffa5539964e417bb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets object information for the object id.  <a href="#ga291d97d78d5460ffa5539964e417bb49">More...</a><br /></td></tr>
<tr class="separator:ga291d97d78d5460ffa5539964e417bb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc33b4b428dfc134ae1622441433b1a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gadc33b4b428dfc134ae1622441433b1a1">_Thread_Get</a> (<a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a> id, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gadc33b4b428dfc134ae1622441433b1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a thread by its identifier.  <a href="#gadc33b4b428dfc134ae1622441433b1a1">More...</a><br /></td></tr>
<tr class="separator:gadc33b4b428dfc134ae1622441433b1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04310043b907712ed8693fbbbc6ba0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga04310043b907712ed8693fbbbc6ba0be">_Thread_Get_CPU</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *thread)</td></tr>
<tr class="memdesc:ga04310043b907712ed8693fbbbc6ba0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cpu of the thread's scheduler.  <a href="#ga04310043b907712ed8693fbbbc6ba0be">More...</a><br /></td></tr>
<tr class="separator:ga04310043b907712ed8693fbbbc6ba0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47858fc4679031e1dedcc3188fd79589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga47858fc4679031e1dedcc3188fd79589">_Thread_Set_CPU</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu)</td></tr>
<tr class="memdesc:ga47858fc4679031e1dedcc3188fd79589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cpu of the thread's scheduler.  <a href="#ga47858fc4679031e1dedcc3188fd79589">More...</a><br /></td></tr>
<tr class="separator:ga47858fc4679031e1dedcc3188fd79589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad103869e6afbe9aa2516d18ffd7e4190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad103869e6afbe9aa2516d18ffd7e4190">_Thread_Is_executing</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gad103869e6afbe9aa2516d18ffd7e4190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread is the currently executing thread.  <a href="#gad103869e6afbe9aa2516d18ffd7e4190">More...</a><br /></td></tr>
<tr class="separator:gad103869e6afbe9aa2516d18ffd7e4190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0c8b33dbdf05215d0656c251045bec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga1c0c8b33dbdf05215d0656c251045bec">_Thread_Is_heir</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga1c0c8b33dbdf05215d0656c251045bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread is the heir.  <a href="#ga1c0c8b33dbdf05215d0656c251045bec">More...</a><br /></td></tr>
<tr class="separator:ga1c0c8b33dbdf05215d0656c251045bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1234634f1d75c8c0864c5727b526f9a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga1234634f1d75c8c0864c5727b526f9a3">_Thread_Unblock</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga1234634f1d75c8c0864c5727b526f9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks the thread.  <a href="#ga1234634f1d75c8c0864c5727b526f9a3">More...</a><br /></td></tr>
<tr class="separator:ga1234634f1d75c8c0864c5727b526f9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798bc92d66cc45b20ceb5b06049340d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga798bc92d66cc45b20ceb5b06049340d6">_Thread_Is_allocated_fp</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga798bc92d66cc45b20ceb5b06049340d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the floating point context of the thread is currently loaded in the floating point unit.  <a href="#ga798bc92d66cc45b20ceb5b06049340d6">More...</a><br /></td></tr>
<tr class="separator:ga798bc92d66cc45b20ceb5b06049340d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10e7acfe1b219ad258d5342bca2bc63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaa10e7acfe1b219ad258d5342bca2bc63">_Thread_Save_fp</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:gaa10e7acfe1b219ad258d5342bca2bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the executing thread's floating point area.  <a href="#gaa10e7acfe1b219ad258d5342bca2bc63">More...</a><br /></td></tr>
<tr class="separator:gaa10e7acfe1b219ad258d5342bca2bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575076c753d2ea7ee875eea80b638127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga575076c753d2ea7ee875eea80b638127">_Thread_Restore_fp</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:ga575076c753d2ea7ee875eea80b638127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the executing thread's floating point area.  <a href="#ga575076c753d2ea7ee875eea80b638127">More...</a><br /></td></tr>
<tr class="separator:ga575076c753d2ea7ee875eea80b638127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd30edce9fc1961d1f5a35123c41029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga5dd30edce9fc1961d1f5a35123c41029">_Thread_Deallocate_fp</a> (void)</td></tr>
<tr class="memdesc:ga5dd30edce9fc1961d1f5a35123c41029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the currently loaded floating point context.  <a href="#ga5dd30edce9fc1961d1f5a35123c41029">More...</a><br /></td></tr>
<tr class="separator:ga5dd30edce9fc1961d1f5a35123c41029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960061380ad461173f7f190e9d75385d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga960061380ad461173f7f190e9d75385d">_Thread_Is_context_switch_necessary</a> (void)</td></tr>
<tr class="memdesc:ga960061380ad461173f7f190e9d75385d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if dispatching is disabled.  <a href="#ga960061380ad461173f7f190e9d75385d">More...</a><br /></td></tr>
<tr class="separator:ga960061380ad461173f7f190e9d75385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83d0184fec31c3968e595ee8a28033b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gac83d0184fec31c3968e595ee8a28033b">_Thread_Is_null</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gac83d0184fec31c3968e595ee8a28033b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread is NULL.  <a href="#gac83d0184fec31c3968e595ee8a28033b">More...</a><br /></td></tr>
<tr class="separator:gac83d0184fec31c3968e595ee8a28033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbab15663bd69884801378fdeaed47b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7bbab15663bd69884801378fdeaed47b">_Thread_Get_maximum_internal_threads</a> (void)</td></tr>
<tr class="memdesc:ga7bbab15663bd69884801378fdeaed47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of internal threads.  <a href="#ga7bbab15663bd69884801378fdeaed47b">More...</a><br /></td></tr>
<tr class="separator:ga7bbab15663bd69884801378fdeaed47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176ea118dfa11ed7460dd0b072f1c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga176ea118dfa11ed7460dd0b072f1c8a8">_Thread_Internal_allocate</a> (void)</td></tr>
<tr class="memdesc:ga176ea118dfa11ed7460dd0b072f1c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an internal thread and returns it.  <a href="#ga176ea118dfa11ed7460dd0b072f1c8a8">More...</a><br /></td></tr>
<tr class="separator:ga176ea118dfa11ed7460dd0b072f1c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7c2e371fbc36ba623dffe713e6c427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gacd7c2e371fbc36ba623dffe713e6c427">_Thread_Get_heir_and_make_it_executing</a> (<a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self)</td></tr>
<tr class="memdesc:gacd7c2e371fbc36ba623dffe713e6c427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the heir of the processor and makes it executing.  <a href="#gacd7c2e371fbc36ba623dffe713e6c427">More...</a><br /></td></tr>
<tr class="separator:gacd7c2e371fbc36ba623dffe713e6c427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a75f308e726ba3f36a97cd758a8e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga02a75f308e726ba3f36a97cd758a8e7e">_Thread_Update_CPU_time_used</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu)</td></tr>
<tr class="memdesc:ga02a75f308e726ba3f36a97cd758a8e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the cpu time used of the thread.  <a href="#ga02a75f308e726ba3f36a97cd758a8e7e">More...</a><br /></td></tr>
<tr class="separator:ga02a75f308e726ba3f36a97cd758a8e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade6e27239f8126f2c2848e7e2ec7244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaade6e27239f8126f2c2848e7e2ec7244">_Thread_Get_CPU_time_used</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__SuperCoreTimeStamp.html#ga8508036506d5211c98844c88045e2410">Timestamp_Control</a> *cpu_time_used)</td></tr>
<tr class="memdesc:gaade6e27239f8126f2c2848e7e2ec7244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the used cpu time for the heir and dispatches a new heir.  <a href="#gaade6e27239f8126f2c2848e7e2ec7244">More...</a><br /></td></tr>
<tr class="separator:gaade6e27239f8126f2c2848e7e2ec7244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6a5ea33a2380faf75952592f7ff8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga6c6a5ea33a2380faf75952592f7ff8f0">_Thread_Action_control_initialize</a> (<a class="el" href="structThread__Action__control.html">Thread_Action_control</a> *action_control)</td></tr>
<tr class="memdesc:ga6c6a5ea33a2380faf75952592f7ff8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the control chain of the action control.  <a href="#ga6c6a5ea33a2380faf75952592f7ff8f0">More...</a><br /></td></tr>
<tr class="separator:ga6c6a5ea33a2380faf75952592f7ff8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae54223afb793365b74ff959e0d2369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaaae54223afb793365b74ff959e0d2369">_Thread_Action_initialize</a> (<a class="el" href="structThread__Action.html">Thread_Action</a> *action)</td></tr>
<tr class="memdesc:gaaae54223afb793365b74ff959e0d2369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Thread action.  <a href="#gaaae54223afb793365b74ff959e0d2369">More...</a><br /></td></tr>
<tr class="separator:gaaae54223afb793365b74ff959e0d2369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19f3f385804128f7f975c8ed326765a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab19f3f385804128f7f975c8ed326765a">_Thread_Add_post_switch_action</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__Action.html">Thread_Action</a> *action, <a class="el" href="group__RTEMSScoreThread.html#ga3ed91c6271fd8090120d824662541c74">Thread_Action_handler</a> handler)</td></tr>
<tr class="memdesc:gab19f3f385804128f7f975c8ed326765a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a post switch action to the thread with the given handler.  <a href="#gab19f3f385804128f7f975c8ed326765a">More...</a><br /></td></tr>
<tr class="separator:gab19f3f385804128f7f975c8ed326765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02d81e4074320decb23de6713559e215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga02d81e4074320decb23de6713559e215">_Thread_Is_life_restarting</a> (<a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> life_state)</td></tr>
<tr class="memdesc:ga02d81e4074320decb23de6713559e215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread life state is restarting.  <a href="#ga02d81e4074320decb23de6713559e215">More...</a><br /></td></tr>
<tr class="separator:ga02d81e4074320decb23de6713559e215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3103744b22d06bcb9bd69edbb62978e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaf3103744b22d06bcb9bd69edbb62978e">_Thread_Is_life_terminating</a> (<a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> life_state)</td></tr>
<tr class="memdesc:gaf3103744b22d06bcb9bd69edbb62978e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread life state is terminating.  <a href="#gaf3103744b22d06bcb9bd69edbb62978e">More...</a><br /></td></tr>
<tr class="separator:gaf3103744b22d06bcb9bd69edbb62978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff8c9f560a20eda908e44b5d5e47a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7ff8c9f560a20eda908e44b5d5e47a28">_Thread_Is_life_change_allowed</a> (<a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> life_state)</td></tr>
<tr class="memdesc:ga7ff8c9f560a20eda908e44b5d5e47a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread life state allos life change.  <a href="#ga7ff8c9f560a20eda908e44b5d5e47a28">More...</a><br /></td></tr>
<tr class="separator:ga7ff8c9f560a20eda908e44b5d5e47a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5c9f0c663c9604e9491a20b8350a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaab5c9f0c663c9604e9491a20b8350a30">_Thread_Is_life_changing</a> (<a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> life_state)</td></tr>
<tr class="memdesc:gaab5c9f0c663c9604e9491a20b8350a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread life state is life changing.  <a href="#gaab5c9f0c663c9604e9491a20b8350a30">More...</a><br /></td></tr>
<tr class="separator:gaab5c9f0c663c9604e9491a20b8350a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce2f4e36ca425f2ea12da97046b9c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7ce2f4e36ca425f2ea12da97046b9c3a">_Thread_Is_joinable</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga7ce2f4e36ca425f2ea12da97046b9c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the thread is joinable.  <a href="#ga7ce2f4e36ca425f2ea12da97046b9c3a">More...</a><br /></td></tr>
<tr class="separator:ga7ce2f4e36ca425f2ea12da97046b9c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8b030c16456ceae1596e2e3fab9808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gade8b030c16456ceae1596e2e3fab9808">_Thread_Resource_count_increment</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gade8b030c16456ceae1596e2e3fab9808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the thread's resource count.  <a href="#gade8b030c16456ceae1596e2e3fab9808">More...</a><br /></td></tr>
<tr class="separator:gade8b030c16456ceae1596e2e3fab9808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778547cad4f7dd7524abb2b9aec0a239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga778547cad4f7dd7524abb2b9aec0a239">_Thread_Resource_count_decrement</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga778547cad4f7dd7524abb2b9aec0a239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the thread's resource count.  <a href="#ga778547cad4f7dd7524abb2b9aec0a239">More...</a><br /></td></tr>
<tr class="separator:ga778547cad4f7dd7524abb2b9aec0a239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740b780440af6ea6cf7a3c13373629e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> const <a class="el" href="struct__Scheduler__Control.html">Scheduler_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga740b780440af6ea6cf7a3c13373629e3">_Thread_Scheduler_get_home</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga740b780440af6ea6cf7a3c13373629e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the home scheduler of the thread.  <a href="#ga740b780440af6ea6cf7a3c13373629e3">More...</a><br /></td></tr>
<tr class="separator:ga740b780440af6ea6cf7a3c13373629e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080a177afc4fc254a1081485cd89f75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structScheduler__Node.html">Scheduler_Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga080a177afc4fc254a1081485cd89f75d">_Thread_Scheduler_get_home_node</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga080a177afc4fc254a1081485cd89f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scheduler's home node.  <a href="#ga080a177afc4fc254a1081485cd89f75d">More...</a><br /></td></tr>
<tr class="separator:ga080a177afc4fc254a1081485cd89f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03136c6e5b56781aeff0ace838556d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structScheduler__Node.html">Scheduler_Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga03136c6e5b56781aeff0ace838556d67">_Thread_Scheduler_get_node_by_index</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, size_t scheduler_index)</td></tr>
<tr class="memdesc:ga03136c6e5b56781aeff0ace838556d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread's scheduler node by index.  <a href="#ga03136c6e5b56781aeff0ace838556d67">More...</a><br /></td></tr>
<tr class="separator:ga03136c6e5b56781aeff0ace838556d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3107774ee53fe4ac8323ba4a0f48f8bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3107774ee53fe4ac8323ba4a0f48f8bc">_Thread_Get_priority</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga3107774ee53fe4ac8323ba4a0f48f8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the priority of the thread.  <a href="#ga3107774ee53fe4ac8323ba4a0f48f8bc">More...</a><br /></td></tr>
<tr class="separator:ga3107774ee53fe4ac8323ba4a0f48f8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe9824bbef3afafec8782dc3d95b6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga6fe9824bbef3afafec8782dc3d95b6ce">_Thread_Get_unmapped_priority</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga6fe9824bbef3afafec8782dc3d95b6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unmapped priority of the thread.  <a href="#ga6fe9824bbef3afafec8782dc3d95b6ce">More...</a><br /></td></tr>
<tr class="separator:ga6fe9824bbef3afafec8782dc3d95b6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e830e160eb3f7511ae2cab7b11023a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3e830e160eb3f7511ae2cab7b11023a8">_Thread_Get_unmapped_real_priority</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga3e830e160eb3f7511ae2cab7b11023a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unmapped real priority of the thread.  <a href="#ga3e830e160eb3f7511ae2cab7b11023a8">More...</a><br /></td></tr>
<tr class="separator:ga3e830e160eb3f7511ae2cab7b11023a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc47e5ce486029f2311242f2303c66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gafbc47e5ce486029f2311242f2303c66d">_Thread_Wait_acquire_default_critical</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gafbc47e5ce486029f2311242f2303c66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread wait default lock inside a critical section (interrupts disabled).  <a href="#gafbc47e5ce486029f2311242f2303c66d">More...</a><br /></td></tr>
<tr class="separator:gafbc47e5ce486029f2311242f2303c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b50dcc140d5c4e34e4e063339baee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga37b50dcc140d5c4e34e4e063339baee5">_Thread_Wait_acquire_default_for_executing</a> (<a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga37b50dcc140d5c4e34e4e063339baee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread wait default lock and returns the executing thread.  <a href="#ga37b50dcc140d5c4e34e4e063339baee5">More...</a><br /></td></tr>
<tr class="separator:ga37b50dcc140d5c4e34e4e063339baee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafed63d230bdeca7d53b9b9aa2b0abbcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gafed63d230bdeca7d53b9b9aa2b0abbcc">_Thread_Wait_acquire_default</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gafed63d230bdeca7d53b9b9aa2b0abbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread wait default lock and disables interrupts.  <a href="#gafed63d230bdeca7d53b9b9aa2b0abbcc">More...</a><br /></td></tr>
<tr class="separator:gafed63d230bdeca7d53b9b9aa2b0abbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1379d753ea2866e64eed15cd7ea7fb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga1379d753ea2866e64eed15cd7ea7fb38">_Thread_Wait_release_default_critical</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:ga1379d753ea2866e64eed15cd7ea7fb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread wait default lock inside a critical section (interrupts disabled).  <a href="#ga1379d753ea2866e64eed15cd7ea7fb38">More...</a><br /></td></tr>
<tr class="separator:ga1379d753ea2866e64eed15cd7ea7fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea1194022db2bc960f47a74946aed8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gacea1194022db2bc960f47a74946aed8c">_Thread_Wait_release_default</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td></tr>
<tr class="memdesc:gacea1194022db2bc960f47a74946aed8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread wait default lock and restores the previous interrupt status.  <a href="#gacea1194022db2bc960f47a74946aed8c">More...</a><br /></td></tr>
<tr class="separator:gacea1194022db2bc960f47a74946aed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d2b044df5bb8998e4c935fededc17c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga31d2b044df5bb8998e4c935fededc17c">_Thread_Wait_acquire_critical</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:ga31d2b044df5bb8998e4c935fededc17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread wait lock inside a critical section (interrupts disabled).  <a href="#ga31d2b044df5bb8998e4c935fededc17c">More...</a><br /></td></tr>
<tr class="separator:ga31d2b044df5bb8998e4c935fededc17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ad190d2fb384bff871065b7e885c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90">_Thread_Wait_acquire</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gaa8ad190d2fb384bff871065b7e885c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the thread wait default lock and disables interrupts.  <a href="#gaa8ad190d2fb384bff871065b7e885c90">More...</a><br /></td></tr>
<tr class="separator:gaa8ad190d2fb384bff871065b7e885c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae077609cfcf4bf7a741a5fd36020dcb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae077609cfcf4bf7a741a5fd36020dcb4">_Thread_Wait_release_critical</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gae077609cfcf4bf7a741a5fd36020dcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread wait lock inside a critical section (interrupts disabled).  <a href="#gae077609cfcf4bf7a741a5fd36020dcb4">More...</a><br /></td></tr>
<tr class="separator:gae077609cfcf4bf7a741a5fd36020dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb857fbbdbd059ae8e1f6fca8768da96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gacb857fbbdbd059ae8e1f6fca8768da96">_Thread_Wait_release</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gacb857fbbdbd059ae8e1f6fca8768da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the thread wait lock and restores the previous interrupt status.  <a href="#gacb857fbbdbd059ae8e1f6fca8768da96">More...</a><br /></td></tr>
<tr class="separator:gacb857fbbdbd059ae8e1f6fca8768da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032320598e809cb93d80e985906fb393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga032320598e809cb93d80e985906fb393">_Thread_Wait_claim</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue)</td></tr>
<tr class="memdesc:ga032320598e809cb93d80e985906fb393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claims the thread wait queue.  <a href="#ga032320598e809cb93d80e985906fb393">More...</a><br /></td></tr>
<tr class="separator:ga032320598e809cb93d80e985906fb393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd97f74b63bbcfb524464371b06df50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gadd97f74b63bbcfb524464371b06df50a">_Thread_Wait_claim_finalize</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *operations)</td></tr>
<tr class="memdesc:gadd97f74b63bbcfb524464371b06df50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the thread wait queue claim via registration of the corresponding thread queue operations.  <a href="#gadd97f74b63bbcfb524464371b06df50a">More...</a><br /></td></tr>
<tr class="separator:gadd97f74b63bbcfb524464371b06df50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f75b9158cddc463bad914c2f9f51a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad6f75b9158cddc463bad914c2f9f51a1">_Thread_Wait_remove_request</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Lock__context.html">Thread_queue_Lock_context</a> *queue_lock_context)</td></tr>
<tr class="memdesc:gad6f75b9158cddc463bad914c2f9f51a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a thread wait lock request.  <a href="#gad6f75b9158cddc463bad914c2f9f51a1">More...</a><br /></td></tr>
<tr class="separator:gad6f75b9158cddc463bad914c2f9f51a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfaf5eea12b9810ca64404cec7e3763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga3cfaf5eea12b9810ca64404cec7e3763">_Thread_Wait_restore_default</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga3cfaf5eea12b9810ca64404cec7e3763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the default thread wait queue and operations.  <a href="#ga3cfaf5eea12b9810ca64404cec7e3763">More...</a><br /></td></tr>
<tr class="separator:ga3cfaf5eea12b9810ca64404cec7e3763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f9b42638ae02922aa0a94a806f46a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga76f9b42638ae02922aa0a94a806f46a9">_Thread_Wait_tranquilize</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga76f9b42638ae02922aa0a94a806f46a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tranquilizes the thread after a wait on a thread queue.  <a href="#ga76f9b42638ae02922aa0a94a806f46a9">More...</a><br /></td></tr>
<tr class="separator:ga76f9b42638ae02922aa0a94a806f46a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82f6b31f52be120df0ff3b5641b52e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gab82f6b31f52be120df0ff3b5641b52e2">_Thread_Wait_cancel</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *queue_context)</td></tr>
<tr class="memdesc:gab82f6b31f52be120df0ff3b5641b52e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a thread wait on a thread queue.  <a href="#gab82f6b31f52be120df0ff3b5641b52e2">More...</a><br /></td></tr>
<tr class="separator:gab82f6b31f52be120df0ff3b5641b52e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb26230b102f8569856d170145a925c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga8eb26230b102f8569856d170145a925c">_Thread_Wait_flags_set</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> flags)</td></tr>
<tr class="memdesc:ga8eb26230b102f8569856d170145a925c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread's wait flags.  <a href="#ga8eb26230b102f8569856d170145a925c">More...</a><br /></td></tr>
<tr class="separator:ga8eb26230b102f8569856d170145a925c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c33d34fc273256480b86586c6be431e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7c33d34fc273256480b86586c6be431e">_Thread_Wait_flags_get</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga7c33d34fc273256480b86586c6be431e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread's wait flags according to the ATOMIC_ORDER_RELAXED.  <a href="#ga7c33d34fc273256480b86586c6be431e">More...</a><br /></td></tr>
<tr class="separator:ga7c33d34fc273256480b86586c6be431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f70e86f9127bf1dbb0295590c81a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga51f70e86f9127bf1dbb0295590c81a45">_Thread_Wait_flags_get_acquire</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga51f70e86f9127bf1dbb0295590c81a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread's wait flags according to the ATOMIC_ORDER_ACQUIRE.  <a href="#ga51f70e86f9127bf1dbb0295590c81a45">More...</a><br /></td></tr>
<tr class="separator:ga51f70e86f9127bf1dbb0295590c81a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c1e8a25615d5aa88b5029feb8d1a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gac2c1e8a25615d5aa88b5029feb8d1a55">_Thread_Wait_flags_try_change_release</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> expected_flags, <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> desired_flags)</td></tr>
<tr class="memdesc:gac2c1e8a25615d5aa88b5029feb8d1a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to change the thread wait flags with release semantics in case of success.  <a href="#gac2c1e8a25615d5aa88b5029feb8d1a55">More...</a><br /></td></tr>
<tr class="separator:gac2c1e8a25615d5aa88b5029feb8d1a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67314f8bf6da8f2a14b59fcbe275a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae67314f8bf6da8f2a14b59fcbe275a5b">_Thread_Wait_flags_try_change_acquire</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> expected_flags, <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> desired_flags)</td></tr>
<tr class="memdesc:gae67314f8bf6da8f2a14b59fcbe275a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to change the thread wait flags with acquire semantics.  <a href="#gae67314f8bf6da8f2a14b59fcbe275a5b">More...</a><br /></td></tr>
<tr class="separator:gae67314f8bf6da8f2a14b59fcbe275a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6328ea18c90d27d612b075965e88c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gad6328ea18c90d27d612b075965e88c03">_Thread_Wait_get_id</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:gad6328ea18c90d27d612b075965e88c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object identifier of the object containing the current thread wait queue.  <a href="#gad6328ea18c90d27d612b075965e88c03">More...</a><br /></td></tr>
<tr class="separator:gad6328ea18c90d27d612b075965e88c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8eb44ff0357020e3bc2972747cd8fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> Status_Control&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga1a8eb44ff0357020e3bc2972747cd8fb">_Thread_Wait_get_status</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga1a8eb44ff0357020e3bc2972747cd8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the wait return code of the thread.  <a href="#ga1a8eb44ff0357020e3bc2972747cd8fb">More...</a><br /></td></tr>
<tr class="separator:ga1a8eb44ff0357020e3bc2972747cd8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c68c63c9078a21b302b801d351f4721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga0c68c63c9078a21b302b801d351f4721">_Thread_Continue</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, Status_Control status)</td></tr>
<tr class="memdesc:ga0c68c63c9078a21b302b801d351f4721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a blocking operation so that the thread can continue its execution.  <a href="#ga0c68c63c9078a21b302b801d351f4721">More...</a><br /></td></tr>
<tr class="separator:ga0c68c63c9078a21b302b801d351f4721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1870eabe77ae0e3913b3888fe4c47185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga1870eabe77ae0e3913b3888fe4c47185">_Thread_Timeout</a> (<a class="el" href="structWatchdog__Control.html">Watchdog_Control</a> *the_watchdog)</td></tr>
<tr class="memdesc:ga1870eabe77ae0e3913b3888fe4c47185"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose thread wait timeout.  <a href="#ga1870eabe77ae0e3913b3888fe4c47185">More...</a><br /></td></tr>
<tr class="separator:ga1870eabe77ae0e3913b3888fe4c47185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb988363d243a9c060fdeb9a2cf3d401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gacb988363d243a9c060fdeb9a2cf3d401">_Thread_Timer_initialize</a> (<a class="el" href="structThread__Timer__information.html">Thread_Timer_information</a> *timer, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu)</td></tr>
<tr class="memdesc:gacb988363d243a9c060fdeb9a2cf3d401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the thread timer.  <a href="#gacb988363d243a9c060fdeb9a2cf3d401">More...</a><br /></td></tr>
<tr class="separator:gacb988363d243a9c060fdeb9a2cf3d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f508c3f03d4d52fd2420746ce14fe03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga9f508c3f03d4d52fd2420746ce14fe03">_Thread_Add_timeout_ticks</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu, <a class="el" href="group__RTEMSScoreWatchdog.html#gaa1834fd7531ca9bb5c4ca6fd990388d5">Watchdog_Interval</a> ticks)</td></tr>
<tr class="memdesc:ga9f508c3f03d4d52fd2420746ce14fe03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds timeout ticks to the thread.  <a href="#ga9f508c3f03d4d52fd2420746ce14fe03">More...</a><br /></td></tr>
<tr class="separator:ga9f508c3f03d4d52fd2420746ce14fe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21916832cf16bf603f348041e2c04859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga21916832cf16bf603f348041e2c04859">_Thread_Timer_insert_realtime</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu, <a class="el" href="group__RTEMSScoreWatchdog.html#ga6ae5e52f6c4046535272c18a8cba66e1">Watchdog_Service_routine_entry</a> routine, uint64_t expire)</td></tr>
<tr class="memdesc:ga21916832cf16bf603f348041e2c04859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the cpu's watchdog realtime into the thread's timer.  <a href="#ga21916832cf16bf603f348041e2c04859">More...</a><br /></td></tr>
<tr class="separator:ga21916832cf16bf603f348041e2c04859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8483d8009fe0047a5a48de4a5f6f2ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga8483d8009fe0047a5a48de4a5f6f2ad7">_Thread_Timer_remove</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread)</td></tr>
<tr class="memdesc:ga8483d8009fe0047a5a48de4a5f6f2ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the watchdog timer from the thread.  <a href="#ga8483d8009fe0047a5a48de4a5f6f2ad7">More...</a><br /></td></tr>
<tr class="separator:ga8483d8009fe0047a5a48de4a5f6f2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f96739e7d43b6203c1486f82349c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga02f96739e7d43b6203c1486f82349c93">_Thread_Remove_timer_and_unblock</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *queue)</td></tr>
<tr class="memdesc:ga02f96739e7d43b6203c1486f82349c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the watchdog timer from the thread and unblock if necessary.  <a href="#ga02f96739e7d43b6203c1486f82349c93">More...</a><br /></td></tr>
<tr class="separator:ga02f96739e7d43b6203c1486f82349c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a3305be3f9998f42871700abf9f89d"><td class="memItemLeft" align="right" valign="top">Status_Control&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae0a3305be3f9998f42871700abf9f89d">_Thread_Set_name</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, const char *name)</td></tr>
<tr class="memdesc:gae0a3305be3f9998f42871700abf9f89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the thread.  <a href="#gae0a3305be3f9998f42871700abf9f89d">More...</a><br /></td></tr>
<tr class="separator:gae0a3305be3f9998f42871700abf9f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590ea63fba22ecee184711c5d2a98227"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga590ea63fba22ecee184711c5d2a98227">_Thread_Get_name</a> (const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, char *buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:ga590ea63fba22ecee184711c5d2a98227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the thread.  <a href="#ga590ea63fba22ecee184711c5d2a98227">More...</a><br /></td></tr>
<tr class="separator:ga590ea63fba22ecee184711c5d2a98227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd1ad906bc42377d1c7b48aaba36c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gadfd1ad906bc42377d1c7b48aaba36c50">_Thread_Pin</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing)</td></tr>
<tr class="memdesc:gadfd1ad906bc42377d1c7b48aaba36c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin the executing thread.  <a href="#gadfd1ad906bc42377d1c7b48aaba36c50">More...</a><br /></td></tr>
<tr class="separator:gadfd1ad906bc42377d1c7b48aaba36c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc95fd103c5bcd79927f316370080340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gafc95fd103c5bcd79927f316370080340">_Thread_Unpin</a> (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *executing, <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *cpu_self)</td></tr>
<tr class="memdesc:gafc95fd103c5bcd79927f316370080340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpins the thread.  <a href="#gafc95fd103c5bcd79927f316370080340">More...</a><br /></td></tr>
<tr class="separator:gafc95fd103c5bcd79927f316370080340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga60a80015d5ec442d6e0f42c1c7969d0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structThread__Control__add__on.html">Thread_Control_add_on</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga60a80015d5ec442d6e0f42c1c7969d0a">_Thread_Control_add_ons</a> []</td></tr>
<tr class="memdesc:ga60a80015d5ec442d6e0f42c1c7969d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread control add-ons.  <a href="#ga60a80015d5ec442d6e0f42c1c7969d0a">More...</a><br /></td></tr>
<tr class="separator:ga60a80015d5ec442d6e0f42c1c7969d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f9a4600ed05daba5da3a8111393fbb"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga93f9a4600ed05daba5da3a8111393fbb">_Thread_Control_add_on_count</a></td></tr>
<tr class="memdesc:ga93f9a4600ed05daba5da3a8111393fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread control add-on count.  <a href="#ga93f9a4600ed05daba5da3a8111393fbb">More...</a><br /></td></tr>
<tr class="separator:ga93f9a4600ed05daba5da3a8111393fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1626b8af19f26d5f6874121bb3c1cc05"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga1626b8af19f26d5f6874121bb3c1cc05">_Thread_Initial_thread_count</a></td></tr>
<tr class="memdesc:ga1626b8af19f26d5f6874121bb3c1cc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of configured threads.  <a href="#ga1626b8af19f26d5f6874121bb3c1cc05">More...</a><br /></td></tr>
<tr class="separator:ga1626b8af19f26d5f6874121bb3c1cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17e2d6bbad850c7adffc4515ac56087"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gae17e2d6bbad850c7adffc4515ac56087">_Thread_Maximum_name_size</a></td></tr>
<tr class="memdesc:gae17e2d6bbad850c7adffc4515ac56087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a thread name in characters (including the terminating '\0' character).  <a href="#gae17e2d6bbad850c7adffc4515ac56087">More...</a><br /></td></tr>
<tr class="separator:gae17e2d6bbad850c7adffc4515ac56087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165e573eece55768db9b693018222bc3"><td class="memItemLeft" align="right" valign="top"><a id="ga165e573eece55768db9b693018222bc3"></a>
<a class="el" href="structThread__Information.html">Thread_Information</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga165e573eece55768db9b693018222bc3">_Thread_Information</a></td></tr>
<tr class="memdesc:ga165e573eece55768db9b693018222bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal thread objects information. <br /></td></tr>
<tr class="separator:ga165e573eece55768db9b693018222bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8376902a32f888326684fc14078057c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gac8376902a32f888326684fc14078057c">_Thread_Idle_stacks</a> []</td></tr>
<tr class="memdesc:gac8376902a32f888326684fc14078057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The idle thread stacks.  <a href="#gac8376902a32f888326684fc14078057c">More...</a><br /></td></tr>
<tr class="separator:gac8376902a32f888326684fc14078057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc61cd772951a83d83af82eba3ff4613"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#gacc61cd772951a83d83af82eba3ff4613">_Thread_Idle_stack_size</a></td></tr>
<tr class="memdesc:gacc61cd772951a83d83af82eba3ff4613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The idle thread stack size in bytes.  <a href="#gacc61cd772951a83d83af82eba3ff4613">More...</a><br /></td></tr>
<tr class="separator:gacc61cd772951a83d83af82eba3ff4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db3304111f98acc3634f7cc04dcff2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__RTEMSScoreThread.html#ga45e6fd0b5cd35ee2ea9e36be90a84c1b">Thread_Idle_body</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga7db3304111f98acc3634f7cc04dcff2f">_Thread_Idle_body</a></td></tr>
<tr class="memdesc:ga7db3304111f98acc3634f7cc04dcff2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The idle thread body.  <a href="#ga7db3304111f98acc3634f7cc04dcff2f">More...</a><br /></td></tr>
<tr class="separator:ga7db3304111f98acc3634f7cc04dcff2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3416f9db9d594d76db105d8a7ad343"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga2b3416f9db9d594d76db105d8a7ad343">rtems_ada_self</a></td></tr>
<tr class="separator:ga2b3416f9db9d594d76db105d8a7ad343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547b3e17ad8dc24bd9e8385a89479174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga547b3e17ad8dc24bd9e8385a89479174">_Thread_Global_constructor</a></td></tr>
<tr class="memdesc:ga547b3e17ad8dc24bd9e8385a89479174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object identifier of the global constructor thread.  <a href="#ga547b3e17ad8dc24bd9e8385a89479174">More...</a><br /></td></tr>
<tr class="separator:ga547b3e17ad8dc24bd9e8385a89479174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bfa1f152fd21a58c739c76cf260527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTEMSScoreThread.html#ga87bfa1f152fd21a58c739c76cf260527">_Thread_Allocated_fp</a></td></tr>
<tr class="separator:ga87bfa1f152fd21a58c739c76cf260527"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Thread Handler. </p>
<p>This handler encapsulates functionality related to the management of threads. This includes the creation, deletion, and scheduling of threads.</p>
<p>The following variables are maintained as part of the per cpu data structure.</p>
<ul>
<li>Idle thread pointer</li>
<li>Executing thread pointer</li>
<li>Heir thread pointer </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga51a02e6653cabfda359b41cc391a7ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a02e6653cabfda359b41cc391a7ae4">&#9670;&nbsp;</a></span>_Thread_queue_Heads_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _Thread_queue_Heads_size&#160;&#160;&#160;sizeof(<a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the thread queue heads of a particular application. </p>
<p>In SMP configurations, this value is provided via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="gaf826e03e6ef568e8773a98274b64e069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf826e03e6ef568e8773a98274b64e069">&#9670;&nbsp;</a></span>RTEMS_SCORE_ROBUST_THREAD_DISPATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_SCORE_ROBUST_THREAD_DISPATCH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables a robust thread dispatch. </p>
<p>On each change of the thread dispatch disable level from one to zero the interrupt status is checked. In case interrupts are disabled and SMP is enabled or the CPU port needs it, then the system terminates with the fatal internal error INTERNAL_ERROR_BAD_THREAD_DISPATCH_ENVIRONMENT. </p>

</div>
</div>
<a id="gaa8beca1577c24c8107f1d30a0b5c1c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8beca1577c24c8107f1d30a0b5c1c4c">&#9670;&nbsp;</a></span>THREAD_API_FIRST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_API_FIRST&#160;&#160;&#160;<a class="el" href="group__RTEMSScoreThread.html#ggaf87b9c0fbba9460ccb284584454c5280abe3da3f1c02de606c8ff1488564a0a73">THREAD_API_RTEMS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro defines the first API which has threads. </p>

</div>
</div>
<a id="gae9eede8eaa139d657213be4d38a5f756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9eede8eaa139d657213be4d38a5f756">&#9670;&nbsp;</a></span>THREAD_API_LAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_API_LAST&#160;&#160;&#160;<a class="el" href="group__RTEMSScoreThread.html#ggaf87b9c0fbba9460ccb284584454c5280a643780b2fad6bb2de6b6688b2f2423cc">THREAD_API_POSIX</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro defines the last API which has threads. </p>

</div>
</div>
<a id="ga68e095a67ea3f48b97721e9c2be35a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e095a67ea3f48b97721e9c2be35a8a">&#9670;&nbsp;</a></span>THREAD_DEFAULT_MAXIMUM_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_DEFAULT_MAXIMUM_NAME_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default maximum size of a thread name in characters (including the terminating '\0' character). </p>
<p>This is the default value for the application configuration option CONFIGURE_MAXIMUM_THREAD_NAME_SIZE. </p>

</div>
</div>
<a id="ga57b827079acdd2597db9cbb6f69d12b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b827079acdd2597db9cbb6f69d12b4">&#9670;&nbsp;</a></span>THREAD_INFORMATION_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_INFORMATION_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">api, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cls, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="structObjects__Control.html">Objects_Control</a> * \</div><div class="line">name##_Local_table[ _Objects_Maximum_per_allocation( max ) ]; \</div><div class="line">static Thread_Configured_control \</div><div class="line">name##_Objects[ _Objects_Maximum_per_allocation( max ) ]; \</div><div class="line">static Thread_queue_Configured_heads \</div><div class="line">name##_Heads[ _Objects_Maximum_per_allocation( max ) ]; \</div><div class="line">Thread_Information name##_Information = { \</div><div class="line">  { \</div><div class="line">    _Objects_Build_id( api, cls, 1, _Objects_Maximum_per_allocation( max ) ), \</div><div class="line">    name##_Local_table, \</div><div class="line">    _Objects_Is_unlimited( max ) ? \</div><div class="line">      _Thread_Allocate_unlimited : <a class="code" href="group__RTEMSScoreObject.html#ga93a072e4b17ff04e60d29e57e6901ce1">_Objects_Allocate_static</a>, \</div><div class="line">    _Objects_Is_unlimited( max ) ? \</div><div class="line">      _Objects_Free_unlimited : <a class="code" href="group__RTEMSScoreObject.html#ga080ce791a8c319fbad853973fa53cf58">_Objects_Free_static</a>, \</div><div class="line">    0, \</div><div class="line">    _Objects_Is_unlimited( max ) ? _Objects_Maximum_per_allocation( max ) : 0, \</div><div class="line">    sizeof( <a class="code" href="group__RTEMSScoreThread.html#gadf9fc745768399b59fb0ff5e81838540">Thread_Configured_control</a> ), \</div><div class="line">    <a class="code" href="group__RTEMSScoreObject.html#gab28c254ca8b651021dff18d181e053f2">OBJECTS_NO_STRING_NAME</a>, \</div><div class="line">    <a class="code" href="group__RTEMSScoreChain.html#ga837c307db69277bfb97d3ed4c22bc420">CHAIN_INITIALIZER_EMPTY</a>( name##_Information.Objects.Inactive ), \</div><div class="line">    <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a>, \</div><div class="line">    <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a>, \</div><div class="line">    &amp;name##_Objects[ 0 ].Control.Object \</div><div class="line">    OBJECTS_INFORMATION_MP( name##_Information.Objects, <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a> ) \</div><div class="line">  }, { \</div><div class="line">    &amp;name##_Heads[ 0 ] \</div><div class="line">  } \</div><div class="line">}</div><div class="ttc" id="structObjects__Control_html"><div class="ttname"><a href="structObjects__Control.html">Objects_Control</a></div><div class="ttdef"><b>Definition:</b> objectdata.h:39</div></div>
<div class="ttc" id="group__RTEMSScoreObject_html_gab28c254ca8b651021dff18d181e053f2"><div class="ttname"><a href="group__RTEMSScoreObject.html#gab28c254ca8b651021dff18d181e053f2">OBJECTS_NO_STRING_NAME</a></div><div class="ttdeci">#define OBJECTS_NO_STRING_NAME</div><div class="ttdoc">Constant for the object information string name length to indicate that this object class has no stri...</div><div class="ttdef"><b>Definition:</b> objectdata.h:101</div></div>
<div class="ttc" id="group__RTEMSScoreChain_html_ga837c307db69277bfb97d3ed4c22bc420"><div class="ttname"><a href="group__RTEMSScoreChain.html#ga837c307db69277bfb97d3ed4c22bc420">CHAIN_INITIALIZER_EMPTY</a></div><div class="ttdeci">#define CHAIN_INITIALIZER_EMPTY(name)</div><div class="ttdoc">Chain initializer for an empty chain with designator name.</div><div class="ttdef"><b>Definition:</b> chainimpl.h:39</div></div>
<div class="ttc" id="group__RTEMSScoreObject_html_ga080ce791a8c319fbad853973fa53cf58"><div class="ttname"><a href="group__RTEMSScoreObject.html#ga080ce791a8c319fbad853973fa53cf58">_Objects_Free_static</a></div><div class="ttdeci">void _Objects_Free_static(Objects_Information *information, Objects_Control *the_object)</div><div class="ttdoc">Free the object.</div><div class="ttdef"><b>Definition:</b> objectfreestatic.c:41</div></div>
<div class="ttc" id="group__RTEMSScoreThread_html_gadf9fc745768399b59fb0ff5e81838540"><div class="ttname"><a href="group__RTEMSScoreThread.html#gadf9fc745768399b59fb0ff5e81838540">Thread_Configured_control</a></div><div class="ttdeci">struct Thread_Configured_control Thread_Configured_control</div><div class="ttdoc">The configured thread control block.</div><div class="ttdef"><b>Definition:</b> thread.h:969</div></div>
<div class="ttc" id="group__RTEMSScoreObject_html_ga93a072e4b17ff04e60d29e57e6901ce1"><div class="ttname"><a href="group__RTEMSScoreObject.html#ga93a072e4b17ff04e60d29e57e6901ce1">_Objects_Allocate_static</a></div><div class="ttdeci">Objects_Control * _Objects_Allocate_static(Objects_Information *information)</div><div class="ttdoc">Return an inactive object or NULL.</div><div class="ttdef"><b>Definition:</b> objectallocatestatic.c:41</div></div>
<div class="ttc" id="bestcomm__api_8h_html_a872bb74de61c3689ccd5b41873fce42c"><div class="ttname"><a href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Requests a GPIO pin group configuration.</div><div class="ttdef"><b>Definition:</b> bestcomm_api.h:77</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gabcd41a9bcb4638f354c0ca1f721ff500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd41a9bcb4638f354c0ca1f721ff500">&#9670;&nbsp;</a></span>THREAD_INFORMATION_DEFINE_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_INFORMATION_DEFINE_ZERO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">api, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cls&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="structThread__Information.html">Thread_Information</a> name##_Information = { \</div><div class="line">  { \</div><div class="line">    _Objects_Build_id( api, cls, 1, 0 ), \</div><div class="line">    NULL, \</div><div class="line">    _Objects_Allocate_none, \</div><div class="line">    NULL, \</div><div class="line">    0, \</div><div class="line">    0, \</div><div class="line">    0, \</div><div class="line">    0, \</div><div class="line">    CHAIN_INITIALIZER_EMPTY( name##_Information.Objects.Inactive ), \</div><div class="line">    NULL, \</div><div class="line">    NULL, \</div><div class="line">    NULL \</div><div class="line">    OBJECTS_INFORMATION_MP( name##_Information.Objects, <a class="code" href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a> ), \</div><div class="line">  }, { \</div><div class="line">    NULL \</div><div class="line">  } \</div><div class="line">}</div><div class="ttc" id="structThread__Information_html"><div class="ttname"><a href="structThread__Information.html">Thread_Information</a></div><div class="ttdoc">The thread object information.</div><div class="ttdef"><b>Definition:</b> thread.h:997</div></div>
<div class="ttc" id="bestcomm__api_8h_html_a872bb74de61c3689ccd5b41873fce42c"><div class="ttname"><a href="bestcomm__api_8h.html#a872bb74de61c3689ccd5b41873fce42c">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Requests a GPIO pin group configuration.</div><div class="ttdef"><b>Definition:</b> bestcomm_api.h:77</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga82059fe7353c5129db4c812b7c82f6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82059fe7353c5129db4c812b7c82f6bf">&#9670;&nbsp;</a></span>THREAD_WAIT_STATE_INTEND_TO_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_WAIT_STATE_INTEND_TO_BLOCK&#160;&#160;&#160;0x1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that the thread begins with the blocking operation. </p>
<p>A blocking operation consists of an optional watchdog initialization and the setting of the appropriate thread blocking state with the corresponding scheduler block operation. </p>

</div>
</div>
<a id="gac00cb9ccdda63a4731f4d80a89371ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00cb9ccdda63a4731f4d80a89371ea0">&#9670;&nbsp;</a></span>THREAD_WAIT_STATE_READY_AGAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_WAIT_STATE_READY_AGAIN&#160;&#160;&#160;0x4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a condition to end the thread wait occurred. </p>
<p>This could be a timeout, a signal, an event or a resource availability. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3ed91c6271fd8090120d824662541c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed91c6271fd8090120d824662541c74">&#9670;&nbsp;</a></span>Thread_Action_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * Thread_Action_handler) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *the_thread, <a class="el" href="structThread__Action.html">Thread_Action</a> *action, <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *lock_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread action handler. </p>
<p>The thread action handler will be called with interrupts disabled and a corresponding lock acquired, e.g. <a class="el" href="group__RTEMSScoreThread.html#ga9a583864cdcbb7eaeda8002d05de6912" title="Disables interrupts and acquires the lock_context.">_Thread_State_acquire()</a>. The handler must release the corresponding lock, e.g. <a class="el" href="group__RTEMSScoreThread.html#ga958218590f858b65855c89802b2cc071" title="Releases the lock context and enables interrupts.">_Thread_State_release()</a>. So, the corresponding lock may be used to protect private data used by the particular action.</p>
<p>Since the action is passed to the handler additional data may be accessed via <a class="el" href="group__RTEMSScoreBaseDefs.html#gab2e7a0141fd898ae358fa9b134aa2610" title="Returns a pointer to the container of a specified member pointer.">RTEMS_CONTAINER_OF()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the_thread</td><td>The thread performing the action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>The thread action. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_context</td><td>The lock context to use for the lock release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf9fc745768399b59fb0ff5e81838540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf9fc745768399b59fb0ff5e81838540">&#9670;&nbsp;</a></span>Thread_Configured_control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__RTEMSScoreThread.html#gadf9fc745768399b59fb0ff5e81838540">Thread_Configured_control</a> <a class="el" href="group__RTEMSScoreThread.html#gadf9fc745768399b59fb0ff5e81838540">Thread_Configured_control</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The configured thread control block. </p>
<p>This type is defined in &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt; and depends on the application configuration. </p>

</div>
</div>
<a id="ga2f15cbe9653e5bfcb2595454e9ffd14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f15cbe9653e5bfcb2595454e9ffd14a">&#9670;&nbsp;</a></span>Thread_CPU_budget_algorithm_callout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Thread_CPU_budget_algorithm_callout) (<a class="el" href="struct__Thread__Control.html">Thread_Control</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This defines thes the entry point for the thread specific timeslice budget management algorithm. </p>

</div>
</div>
<a id="gab56e437830bb9a4af5b27ac7ec503b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56e437830bb9a4af5b27ac7ec503b6a">&#9670;&nbsp;</a></span>Thread_Entry_numeric_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__RTEMSScoreCPUARM.html#ga9fca17f81f850e128fcc8ed5b87ff2ab">CPU_Uint32ptr</a> <a class="el" href="group__RTEMSScoreThread.html#gab56e437830bb9a4af5b27ac7ec503b6a">Thread_Entry_numeric_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the numeric argument of a thread entry function with at least one numeric argument. </p>
<p>This numeric argument type designates an unsigned integer type with the property that any valid pointer to void can be converted to this type and then converted back to a pointer to void. The result will compare equal to the original pointer. </p>

</div>
</div>
<a id="gac2edd6c043930e8159685c0cb2e19ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2edd6c043930e8159685c0cb2e19ca7">&#9670;&nbsp;</a></span>Thread_queue_Configured_heads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__RTEMSScoreThreadQueue.html#gaebac32033b009cc8f606a90bd389f8e9">Thread_queue_Heads</a> <a class="el" href="group__RTEMSScoreThread.html#gac2edd6c043930e8159685c0cb2e19ca7">Thread_queue_Configured_heads</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The configured thread queue heads. </p>
<p>In SMP configurations, this type is defined in &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt; and depends on the application configuration. </p>

</div>
</div>
<a id="ga9a047ae9c77bc90a258203d4f2cc57db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a047ae9c77bc90a258203d4f2cc57db">&#9670;&nbsp;</a></span>Thread_Wait_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This type is able to contain several flags used to control the wait class and state of a thread. </p>
<p>The mutually exclusive wait class flags are</p><ul>
<li><a class="el" href="group__RTEMSScoreThread.html#gaefe28b0cc1c352513a17974207cf9f4b">THREAD_WAIT_CLASS_EVENT</a>,</li>
<li><a class="el" href="group__RTEMSScoreThread.html#gad87c9c823f1022eb0843801438b91f29">THREAD_WAIT_CLASS_SYSTEM_EVENT</a>, and</li>
<li><a class="el" href="group__RTEMSScoreThread.html#ga8ad326b1eb2ad7ab1c74a69052aac37c">THREAD_WAIT_CLASS_OBJECT</a>.</li>
</ul>
<p>The mutually exclusive wait state flags are</p><ul>
<li><a class="el" href="group__RTEMSScoreThread.html#ga82059fe7353c5129db4c812b7c82f6bf">THREAD_WAIT_STATE_INTEND_TO_BLOCK</a>,</li>
<li><a class="el" href="group__RTEMSScoreThread.html#gaa9487eb8db998d29cb1f712155769583">THREAD_WAIT_STATE_BLOCKED</a>, and</li>
<li><a class="el" href="group__RTEMSScoreThread.html#gac00cb9ccdda63a4731f4d80a89371ea0">THREAD_WAIT_STATE_READY_AGAIN</a>. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf87b9c0fbba9460ccb284584454c5280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf87b9c0fbba9460ccb284584454c5280">&#9670;&nbsp;</a></span>Thread_APIs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__RTEMSScoreThread.html#gaf87b9c0fbba9460ccb284584454c5280">Thread_APIs</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following record defines the control block used to manage each thread.</p>
<dl class="section note"><dt>Note</dt><dd>It is critical that proxies and threads have identical memory images for the shared part. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf87b9c0fbba9460ccb284584454c5280abe3da3f1c02de606c8ff1488564a0a73"></a>THREAD_API_RTEMS&#160;</td><td class="fielddoc"><p>This value is for the Classic RTEMS API. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf87b9c0fbba9460ccb284584454c5280a643780b2fad6bb2de6b6688b2f2423cc"></a>THREAD_API_POSIX&#160;</td><td class="fielddoc"><p>This value is for the POSIX API. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab6f48556812ffc781a69df144ef49be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6f48556812ffc781a69df144ef49be0">&#9670;&nbsp;</a></span>Thread_CPU_budget_algorithms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__RTEMSScoreThread.html#gab6f48556812ffc781a69df144ef49be0">Thread_CPU_budget_algorithms</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following lists the algorithms used to manage the thread cpu budget.</p>
<p>Reset Timeslice: At each context switch, reset the time quantum. Exhaust Timeslice: Only reset the quantum once it is consumed. Callout: Execute routine when budget is consumed. </p>

</div>
</div>
<a id="ga0b4c61e432a0c21855e3122bb394583d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4c61e432a0c21855e3122bb394583d">&#9670;&nbsp;</a></span>Thread_Life_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread life states. </p>
<p>The thread life states are orthogonal to the thread states used for synchronization primitives and blocking operations. They reflect the state changes triggered with thread restart and delete requests.</p>
<p>The individual state values must be a power of two to allow use of bit operations to manipulate and evaluate the thread life state. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6c6a5ea33a2380faf75952592f7ff8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c6a5ea33a2380faf75952592f7ff8f0">&#9670;&nbsp;</a></span>_Thread_Action_control_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Action_control_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__Action__control.html">Thread_Action_control</a> *&#160;</td>
          <td class="paramname"><em>action_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the control chain of the action control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">action_control</td><td>The action control to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaae54223afb793365b74ff959e0d2369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae54223afb793365b74ff959e0d2369">&#9670;&nbsp;</a></span>_Thread_Action_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Action_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__Action.html">Thread_Action</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Thread action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">action</td><td>The <a class="el" href="structThread__Action.html" title="Thread action.">Thread_Action</a> to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab19f3f385804128f7f975c8ed326765a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab19f3f385804128f7f975c8ed326765a">&#9670;&nbsp;</a></span>_Thread_Add_post_switch_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Add_post_switch_action </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__Action.html">Thread_Action</a> *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga3ed91c6271fd8090120d824662541c74">Thread_Action_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a post switch action to the thread with the given handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">action</td><td>The action to add. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">handler</td><td>The handler for the action. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f508c3f03d4d52fd2420746ce14fe03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f508c3f03d4d52fd2420746ce14fe03">&#9670;&nbsp;</a></span>_Thread_Add_timeout_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Add_timeout_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreWatchdog.html#gaa1834fd7531ca9bb5c4ca6fd990388d5">Watchdog_Interval</a>&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds timeout ticks to the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to add the timeout ticks to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu</td><td>The cpu for the operation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ticks</td><td>The ticks to add to the timeout ticks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cb5db6d9e872bde5dc6d3d3489bcc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cb5db6d9e872bde5dc6d3d3489bcc19">&#9670;&nbsp;</a></span>_Thread_Allocate_unlimited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structObjects__Control.html">Objects_Control</a>* _Thread_Allocate_unlimited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structObjects__Information.html">Objects_Information</a> *&#160;</td>
          <td class="paramname"><em>information</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an inactive thread object or NULL. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>No inactive object is available. </td></tr>
    <tr><td class="paramname">object</td><td>An inactive object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1fb3719c77dc89881e4686fad81eeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1fb3719c77dc89881e4686fad81eeee">&#9670;&nbsp;</a></span>_Thread_Cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exit_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to cancel. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">exit_value</td><td>The exit value for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e2c11aa0d3c505d0d3e264fbb6bbe7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e2c11aa0d3c505d0d3e264fbb6bbe7e">&#9670;&nbsp;</a></span>_Thread_Change_life()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> _Thread_Change_life </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>clear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the currently executing thread to a new state with the sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear</td><td>States to clear. </td></tr>
    <tr><td class="paramname">set</td><td>States to set. </td></tr>
    <tr><td class="paramname">ignore</td><td>States to ignore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous state the thread was in. </dd></dl>

</div>
</div>
<a id="ga7e35e9ebb9a5364d00f1f1b1e166e701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e35e9ebb9a5364d00f1f1b1e166e701">&#9670;&nbsp;</a></span>_Thread_Clear_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> _Thread_Clear_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified thread state. </p>
<p>In the case the previous state is a non-ready state and the next state is the ready state, then the thread is unblocked by the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>The state to clear. It must not be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous state. </dd></dl>

</div>
</div>
<a id="gae54a6095e8c9f868b54545fdbfc8f061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae54a6095e8c9f868b54545fdbfc8f061">&#9670;&nbsp;</a></span>_Thread_Clear_state_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> _Thread_Clear_state_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified thread state without locking the lock context. </p>
<p>In the case the previous state is a non-ready state and the next state is the ready state, then the thread is unblocked by the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>The state to clear. It must not be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's previous state. </dd></dl>

</div>
</div>
<a id="gaf42a844061758d4a5bda639ffc21b8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf42a844061758d4a5bda639ffc21b8f5">&#9670;&nbsp;</a></span>_Thread_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__Close__context.html">Thread_Close_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the thread. </p>
<p>Closes the thread object and starts the thread termination sequence. In case the executing thread is not terminated, then this function waits until the terminating thread reached the zombie state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread</td><td>The thread to close. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The thread close context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c68c63c9078a21b302b801d351f4721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c68c63c9078a21b302b801d351f4721">&#9670;&nbsp;</a></span>_Thread_Continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Continue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status_Control&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels a blocking operation so that the thread can continue its execution. </p>
<p>In case this function actually cancelled the blocking operation, then the thread wait return code is set to the specified status.</p>
<p>A specialization of this function is <a class="el" href="group__RTEMSScoreThread.html#ga1870eabe77ae0e3913b3888fe4c47185" title="General purpose thread wait timeout.">_Thread_Timeout()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">status</td><td>The thread wait status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86a9db1abab176f3d74f4f46a423c2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86a9db1abab176f3d74f4f46a423c2c3">&#9670;&nbsp;</a></span>_Thread_Create_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Create_idle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates idle thread. </p>
<p>This routine creates the idle thread.</p>
<dl class="section warning"><dt>Warning</dt><dd>No thread should be created before this one. </dd></dl>

</div>
</div>
<a id="ga5dd30edce9fc1961d1f5a35123c41029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd30edce9fc1961d1f5a35123c41029">&#9670;&nbsp;</a></span>_Thread_Deallocate_fp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Deallocate_fp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the currently loaded floating point context. </p>
<p>This routine is invoked when the currently loaded floating point context is now longer associated with an active thread. </p>

</div>
</div>
<a id="ga14e949c0f400cda43b1e7547e50b088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14e949c0f400cda43b1e7547e50b088d">&#9670;&nbsp;</a></span>_Thread_Dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Dispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a thread dispatch if necessary. </p>
<p>This routine is responsible for transferring control of the processor from the executing thread to the heir thread. Once the heir is running an attempt is made to run the pending post-switch thread actions.</p>
<p>As part of this process, it is responsible for the following actions</p><ul>
<li>update timing information of the executing thread,</li>
<li>save the context of the executing thread,</li>
<li>invokation of the thread switch user extensions,</li>
<li>restore the context of the heir thread, and</li>
<li>run of pending post-switch thread actions of the resulting executing thread.</li>
</ul>
<p>On entry the thread dispatch level must be equal to zero. </p>

</div>
</div>
<a id="gab4251559fe6a0c06762de333bca275f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4251559fe6a0c06762de333bca275f5">&#9670;&nbsp;</a></span>_Thread_Dispatch_direct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Dispatch_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly do a thread dispatch. </p>
<p>Must be called with a thread dispatch disable level of one, otherwise the INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur. This function is useful for operations which synchronously block, e.g. self restart, self deletion, yield, sleep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_self</td><td>The current processor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga14e949c0f400cda43b1e7547e50b088d" title="Performs a thread dispatch if necessary.">_Thread_Dispatch()</a>. </dd></dl>

</div>
</div>
<a id="ga044bfb6e9317180d21b05c5338cedd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga044bfb6e9317180d21b05c5338cedd1a">&#9670;&nbsp;</a></span>_Thread_Dispatch_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a>* _Thread_Dispatch_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables thread dispatching. </p>
<dl class="section return"><dt>Returns</dt><dd>The current processor. </dd></dl>

</div>
</div>
<a id="ga5ffeb81480c63293a317f69efc74dec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffeb81480c63293a317f69efc74dec3">&#9670;&nbsp;</a></span>_Thread_Dispatch_disable_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a>* _Thread_Dispatch_disable_critical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables thread dispatching inside a critical section (interrupts disabled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_context</td><td>The lock context of the corresponding <a class="el" href="group__RTEMSScoreISRLocks.html#ga36d91ceed1df931ce6291d7bc9e60573" title="Disables interrupts and saves the previous interrupt state in the ISR lock context.">_ISR_lock_ISR_disable()</a> that started the critical section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current processor. </dd></dl>

</div>
</div>
<a id="ga80a71da4ea096f7ea92781a872b955ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a71da4ea096f7ea92781a872b955ae">&#9670;&nbsp;</a></span>_Thread_Dispatch_disable_with_CPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a>* _Thread_Dispatch_disable_with_CPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables thread dispatching inside a critical section (interrupts disabled) with the current processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
    <tr><td class="paramname">lock_context</td><td>The lock context of the corresponding <a class="el" href="group__RTEMSScoreISRLocks.html#ga36d91ceed1df931ce6291d7bc9e60573" title="Disables interrupts and saves the previous interrupt state in the ISR lock context.">_ISR_lock_ISR_disable()</a> that started the critical section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current processor. </dd></dl>

</div>
</div>
<a id="gab0c773b97624be1dc304a2d3d038f19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0c773b97624be1dc304a2d3d038f19a">&#9670;&nbsp;</a></span>_Thread_Dispatch_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Dispatch_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables thread dispatching. </p>
<p>May perform a thread dispatch if necessary as a side-effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f098a76c363d6d1daff302c5d7a9d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f098a76c363d6d1daff302c5d7a9d9b">&#9670;&nbsp;</a></span>_Thread_Dispatch_get_disable_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uint32_t _Thread_Dispatch_get_disable_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets thread dispatch disable level. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the thread dispatch level. </dd></dl>

</div>
</div>
<a id="gae1b097ce535f591840d891f691812759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1b097ce535f591840d891f691812759">&#9670;&nbsp;</a></span>_Thread_Dispatch_initialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Dispatch_initialization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread dispatch initialization. </p>
<p>This routine initializes the thread dispatching subsystem. </p>

</div>
</div>
<a id="gaa847ae7c8e3c4cf3f3f3f082124eac8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa847ae7c8e3c4cf3f3f3f082124eac8e">&#9670;&nbsp;</a></span>_Thread_Dispatch_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Dispatch_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if the executing thread is inside a thread dispatch critical section. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Thread dispatching is enabled. </td></tr>
    <tr><td class="paramname">false</td><td>The executing thread is inside a thread dispatch critical section and dispatching is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga216a6330c178a36afc4eb50a4a66ba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216a6330c178a36afc4eb50a4a66ba4a">&#9670;&nbsp;</a></span>_Thread_Dispatch_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Dispatch_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests a thread dispatch on the target processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_target</td><td>The target processor to request a thread dispatch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89324d5b965715261d6fa55527297b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89324d5b965715261d6fa55527297b1a">&#9670;&nbsp;</a></span>_Thread_Dispatch_unnest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Dispatch_unnest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unnests thread dispatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0ea5fef985f18cd60d85d9cedab4c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ea5fef985f18cd60d85d9cedab4c6c">&#9670;&nbsp;</a></span>_Thread_Do_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Do_dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreISR.html#gad1af728587ebcefec5b5cf94fc7909b9">ISR_Level</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a thread dispatch on the current processor. </p>
<p>On entry the thread dispatch disable level must be equal to one and interrupts must be disabled.</p>
<p>This function assumes that a thread dispatch is necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
    <tr><td class="paramname">level</td><td>The previous interrupt level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga14e949c0f400cda43b1e7547e50b088d" title="Performs a thread dispatch if necessary.">_Thread_Dispatch()</a>. </dd></dl>

</div>
</div>
<a id="ga15433c1ca9df669c036739a50a8d1b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15433c1ca9df669c036739a50a8d1b9a">&#9670;&nbsp;</a></span>_Thread_Entry_adaptor_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Entry_adaptor_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the start kinds idle entry of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9223b77920482b86fba30d4113be119f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9223b77920482b86fba30d4113be119f">&#9670;&nbsp;</a></span>_Thread_Entry_adaptor_numeric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Entry_adaptor_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the start kinds numeric entry of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac2283a605738e5b3fd2e1710ea8b73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac2283a605738e5b3fd2e1710ea8b73a">&#9670;&nbsp;</a></span>_Thread_Entry_adaptor_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Entry_adaptor_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the start kinds pointer entry of the thread. </p>
<p>Stores the return value in the Wait.return_argument of the thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99bebb00c256fb08bd5c1bdf546c5e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99bebb00c256fb08bd5c1bdf546c5e1f">&#9670;&nbsp;</a></span>_Thread_Exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exit_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exits the currently executing thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">set</td><td>The states to set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exit_value</td><td>Contains the exit value of the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc33b4b428dfc134ae1622441433b1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc33b4b428dfc134ae1622441433b1a1">&#9670;&nbsp;</a></span>_Thread_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a thread by its identifier. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreObject.html#gaccc5682133e4f65b8cb374eab9be2c9d" title="Maps the specified object identifier to the associated local object control block.">_Objects_Get()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the thread. </td></tr>
    <tr><td class="paramname">lock_context</td><td>The lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga04310043b907712ed8693fbbbc6ba0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04310043b907712ed8693fbbbc6ba0be">&#9670;&nbsp;</a></span>_Thread_Get_CPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a>* _Thread_Get_CPU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the cpu of the thread's scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cpu of the thread's scheduler. </dd></dl>

</div>
</div>
<a id="gaade6e27239f8126f2c2848e7e2ec7244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaade6e27239f8126f2c2848e7e2ec7244">&#9670;&nbsp;</a></span>_Thread_Get_CPU_time_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Get_CPU_time_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SuperCoreTimeStamp.html#ga8508036506d5211c98844c88045e2410">Timestamp_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_time_used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the used cpu time for the heir and dispatches a new heir. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_self</td><td>The current processor. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_for_heir</td><td>The processor to do a dispatch on. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">heir</td><td>The new heir for <em>cpu_for_heir.Gets</em> the used cpu time of the thread and stores it in the given Timestamp_Control.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">the_thread</td><td>The thread to get the used cpu time of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cpu_time_used</td><td>Stores the used cpu time of <em>the_thread</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd7c2e371fbc36ba623dffe713e6c427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd7c2e371fbc36ba623dffe713e6c427">&#9670;&nbsp;</a></span>_Thread_Get_heir_and_make_it_executing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_Get_heir_and_make_it_executing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the heir of the processor and makes it executing. </p>
<p>Must be called with interrupts disabled. The thread dispatch necessary indicator is cleared as a side-effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cpu_self</td><td>The processor to get the heir of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The heir thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga14e949c0f400cda43b1e7547e50b088d" title="Performs a thread dispatch if necessary.">_Thread_Dispatch()</a>, <a class="el" href="group__RTEMSScoreThread.html#gab27215302814d0aa0ec3306b165ea247" title="Starts thread multitasking.">_Thread_Start_multitasking()</a> and _Thread_Dispatch_update_heir(). </dd></dl>

</div>
</div>
<a id="ga7bbab15663bd69884801378fdeaed47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bbab15663bd69884801378fdeaed47b">&#9670;&nbsp;</a></span>_Thread_Get_maximum_internal_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> uint32_t _Thread_Get_maximum_internal_threads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum number of internal threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of internal threads. </dd></dl>

</div>
</div>
<a id="ga590ea63fba22ecee184711c5d2a98227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590ea63fba22ecee184711c5d2a98227">&#9670;&nbsp;</a></span>_Thread_Get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _Thread_Get_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread</td><td>The thread to get the name of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Contains the thread's name. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>The size of <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied to <em>buffer</em>. </dd></dl>

</div>
</div>
<a id="ga291d97d78d5460ffa5539964e417bb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga291d97d78d5460ffa5539964e417bb49">&#9670;&nbsp;</a></span>_Thread_Get_objects_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structObjects__Information.html">Objects_Information</a>* _Thread_Get_objects_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets object information for the object id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the object information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>The object information for this id. </td></tr>
    <tr><td class="paramname">NULL</td><td>The object id is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3107774ee53fe4ac8323ba4a0f48f8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3107774ee53fe4ac8323ba4a0f48f8bc">&#9670;&nbsp;</a></span>_Thread_Get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> _Thread_Get_priority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the priority of the thread. </p>
<p>Returns the user API and thread wait information relevant thread priority. This includes temporary thread priority adjustments due to locking protocols, a job release or the POSIX sporadic server for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread of which to get the priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread. </dd></dl>

</div>
</div>
<a id="ga6fe9824bbef3afafec8782dc3d95b6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe9824bbef3afafec8782dc3d95b6ce">&#9670;&nbsp;</a></span>_Thread_Get_unmapped_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> _Thread_Get_unmapped_priority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unmapped priority of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread of which to get the unmapped priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unmapped priority of the thread. </dd></dl>

</div>
</div>
<a id="ga3e830e160eb3f7511ae2cab7b11023a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e830e160eb3f7511ae2cab7b11023a8">&#9670;&nbsp;</a></span>_Thread_Get_unmapped_real_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> _Thread_Get_unmapped_real_priority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unmapped real priority of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread of which to get the unmapped real priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unmapped real priority of the thread. </dd></dl>

</div>
</div>
<a id="gae0c3a615798c7cc70dc9ff6d9317df46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0c3a615798c7cc70dc9ff6d9317df46">&#9670;&nbsp;</a></span>_Thread_Handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for all threads. </p>
<p>This routine is the wrapper function for all threads. It is the starting point for all threads. The user provided thread entry point is invoked by this routine. Operations which must be performed immediately before and after the user's thread executes are found here.</p>
<dl class="section note"><dt>Note</dt><dd>On entry, it is assumed all interrupts are blocked and that this routine needs to set the initial isr level. This may or may not actually be needed by the context switch routine and as a result interrupts may already be at there proper level. Either way, setting the initial isr level properly here is safe. </dd></dl>

</div>
</div>
<a id="ga439268e164b067a866d2901085c8c672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga439268e164b067a866d2901085c8c672">&#9670;&nbsp;</a></span>_Thread_Handler_initialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Handler_initialization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes thread handler. </p>
<p>This routine performs the initialization necessary for this handler. </p>

</div>
</div>
<a id="gab4f561fd816d0b93318afa48f609fad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f561fd816d0b93318afa48f609fad2">&#9670;&nbsp;</a></span>_Thread_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Thread_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__Information.html">Thread_Information</a> *&#160;</td>
          <td class="paramname"><em>information</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__Configuration.html">Thread_Configuration</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes thread. </p>
<p>This routine initializes the specified the thread. It allocates all memory associated with this thread. It completes by adding the thread to the local object table so operations on this thread id are allowed.</p>
<dl class="section note"><dt>Note</dt><dd>If stack_area is NULL, it is allocated from the workspace.</dd>
<dd>
If the stack is allocated from the workspace, then it is guaranteed to be of at least minimum size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">information</td><td>The thread information. </td></tr>
    <tr><td class="paramname">the_thread</td><td>The thread to initialize. </td></tr>
    <tr><td class="paramname">config</td><td>The configuration of the thread to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread initialization was successful. </td></tr>
    <tr><td class="paramname">false</td><td>The thread initialization failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd86ef6b0e5fb19ec14d7fe51e3868e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd86ef6b0e5fb19ec14d7fe51e3868e2">&#9670;&nbsp;</a></span>_Thread_Initialize_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Initialize_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__Information.html">Thread_Information</a> *&#160;</td>
          <td class="paramname"><em>information</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the thread information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">information</td><td>Information to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga176ea118dfa11ed7460dd0b072f1c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga176ea118dfa11ed7460dd0b072f1c8a8">&#9670;&nbsp;</a></span>_Thread_Internal_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_Internal_allocate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an internal thread and returns it. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>Pointer to the allocated Thread_Control. </td></tr>
    <tr><td class="paramname">NULL</td><td>The operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga798bc92d66cc45b20ceb5b06049340d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga798bc92d66cc45b20ceb5b06049340d6">&#9670;&nbsp;</a></span>_Thread_Is_allocated_fp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_allocated_fp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the floating point context of the thread is currently loaded in the floating point unit. </p>
<p>This function returns true if the floating point context of the_thread is currently loaded in the floating point unit, and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The floating point context of <em>the_thread</em> is currently loaded in the floating point unit. </td></tr>
    <tr><td class="paramname">false</td><td>The floating point context of <em>the_thread</em> is currently not loaded in the floating point unit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga960061380ad461173f7f190e9d75385d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga960061380ad461173f7f190e9d75385d">&#9670;&nbsp;</a></span>_Thread_Is_context_switch_necessary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_context_switch_necessary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if dispatching is disabled. </p>
<p>This function returns true if dispatching is disabled, and false otherwise.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Dispatching is disabled. </td></tr>
    <tr><td class="paramname">false</td><td>Dispatching is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad103869e6afbe9aa2516d18ffd7e4190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad103869e6afbe9aa2516d18ffd7e4190">&#9670;&nbsp;</a></span>_Thread_Is_executing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_executing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread is the currently executing thread. </p>
<p>This function returns true if the_thread is the currently executing thread, and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to verify if it is the currently executing thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>the_thread</em> is the currently executing one. </td></tr>
    <tr><td class="paramname">false</td><td><em>the_thread</em> is not the currently executing one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c0c8b33dbdf05215d0656c251045bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0c8b33dbdf05215d0656c251045bec">&#9670;&nbsp;</a></span>_Thread_Is_heir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_heir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread is the heir. </p>
<p>This function returns true if the_thread is the heir thread, and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>the_thread</em> is the heir. </td></tr>
    <tr><td class="paramname">false</td><td><em>the_thread</em> is not the heir. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ce2f4e36ca425f2ea12da97046b9c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ce2f4e36ca425f2ea12da97046b9c3a">&#9670;&nbsp;</a></span>_Thread_Is_joinable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_joinable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread is joinable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>life_state</em> is joinable. </td></tr>
    <tr><td class="paramname">false</td><td><em>life_state</em> is not joinable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ff8c9f560a20eda908e44b5d5e47a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ff8c9f560a20eda908e44b5d5e47a28">&#9670;&nbsp;</a></span>_Thread_Is_life_change_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_life_change_allowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>life_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread life state allos life change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">life_state</td><td>The thread life state for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>life_state</em> allows life change. </td></tr>
    <tr><td class="paramname">false</td><td><em>life_state</em> does not allow life change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab5c9f0c663c9604e9491a20b8350a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5c9f0c663c9604e9491a20b8350a30">&#9670;&nbsp;</a></span>_Thread_Is_life_changing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_life_changing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>life_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread life state is life changing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">life_state</td><td>The thread life state for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>life_state</em> is life changing. </td></tr>
    <tr><td class="paramname">false</td><td><em>life_state</em> is not life changing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga02d81e4074320decb23de6713559e215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02d81e4074320decb23de6713559e215">&#9670;&nbsp;</a></span>_Thread_Is_life_restarting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_life_restarting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>life_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread life state is restarting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">life_state</td><td>The thread life state for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>life_state</em> is restarting. </td></tr>
    <tr><td class="paramname">false</td><td><em>life_state</em> is not restarting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3103744b22d06bcb9bd69edbb62978e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3103744b22d06bcb9bd69edbb62978e">&#9670;&nbsp;</a></span>_Thread_Is_life_terminating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_life_terminating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>life_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread life state is terminating. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">life_state</td><td>The thread life state for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td><em>life_state</em> is terminating. </td></tr>
    <tr><td class="paramname">false</td><td><em>life_state</em> is not terminating. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac83d0184fec31c3968e595ee8a28033b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac83d0184fec31c3968e595ee8a28033b">&#9670;&nbsp;</a></span>_Thread_Is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread is NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">false</td><td>The thread is not <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4493fc6ffddc8fd05987cb405f9cf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4493fc6ffddc8fd05987cb405f9cf71">&#9670;&nbsp;</a></span>_Thread_Is_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Is_ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread is ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to check if it is ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread is currently in the ready state. </td></tr>
    <tr><td class="paramname">false</td><td>The thread is currently not ready. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccf2d81d16187ed8808e76addc8da0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf2d81d16187ed8808e76addc8da0ed">&#9670;&nbsp;</a></span>_Thread_Iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Iterate </td>
          <td>(</td>
          <td class="paramtype">Thread_Visitor&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the visitor with all threads and the given argument until it is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Function that gets a thread and <em>arg</em> as parameters and returns if it is done. </td></tr>
    <tr><td class="paramname">arg</td><td>Parameter for <em>visitor</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga659bc82bc257e001d0b94f10436fbab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga659bc82bc257e001d0b94f10436fbab2">&#9670;&nbsp;</a></span>_Thread_Join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td>
          <td class="paramname"><em>waiting_for_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins the currently executing thread with the given thread to wait for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to wait for. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">waiting_for_join</td><td>The states control for the join. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga986b5354464f933956a6ea28ba9b74a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga986b5354464f933956a6ea28ba9b74a2">&#9670;&nbsp;</a></span>_Thread_Kill_zombies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Kill_zombies </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kills all zombie threads in the system. </p>
<p>Threads change into the zombie state as the last step in the thread termination sequence right before a context switch to the heir thread is initiated. Since the thread stack is still in use during this phase we have to postpone the thread stack reclamation until this point. On SMP configurations we may have to busy wait for context switch completion here. </p>

</div>
</div>
<a id="gade10731d5bc6570cc485999da44acd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade10731d5bc6570cc485999da44acd43">&#9670;&nbsp;</a></span>_Thread_Load_environment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Load_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes enviroment for a thread. </p>
<p>This routine initializes the context of <em>the_thread</em> to its appropriate starting state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The pointer to the thread control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfd1ad906bc42377d1c7b48aaba36c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd1ad906bc42377d1c7b48aaba36c50">&#9670;&nbsp;</a></span>_Thread_Pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Pin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pin the executing thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58d04f5124606eff3a1da3d42cc79e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58d04f5124606eff3a1da3d42cc79e2f">&#9670;&nbsp;</a></span>_Thread_Priority_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Priority_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPriority__Node.html">Priority_Node</a> *&#160;</td>
          <td class="paramname"><em>priority_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified thread priority node to the corresponding thread priority aggregation. </p>
<p>The caller must be the owner of the thread wait lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramname">priority_node</td><td>The thread priority node to add. </td></tr>
    <tr><td class="paramname">queue_context</td><td>The thread queue context to return an updated set of threads for <a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59" title="Updates the priority of all threads in the set.">_Thread_Priority_update()</a>. The thread queue context must be initialized via <a class="el" href="group__RTEMSScoreThreadQueue.html#gab84f558bc470437d43ce863f8024534e" title="Clears the priority update count of the thread queue context.">_Thread_queue_Context_clear_priority_updates()</a> before a call of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </dd></dl>

</div>
</div>
<a id="ga76a9975ac0b320b0a00678534ab78f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76a9975ac0b320b0a00678534ab78f10">&#9670;&nbsp;</a></span>_Thread_Priority_change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Priority_change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPriority__Node.html">Priority_Node</a> *&#160;</td>
          <td class="paramname"><em>priority_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td>
          <td class="paramname"><em>new_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the thread priority value of the specified thread priority node in the corresponding thread priority aggregation. </p>
<p>The caller must be the owner of the thread wait lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priority_node</td><td>The thread priority node to change. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_priority</td><td>The new thread priority value of the thread priority node to change. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prepend_it</td><td>In case this is true, then the thread is prepended to its priority group in its home scheduler instance, otherwise it is appended. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context to return an updated set of threads for <a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59" title="Updates the priority of all threads in the set.">_Thread_Priority_update()</a>. The thread queue context must be initialized via <a class="el" href="group__RTEMSScoreThreadQueue.html#gab84f558bc470437d43ce863f8024534e" title="Clears the priority update count of the thread queue context.">_Thread_queue_Context_clear_priority_updates()</a> before a call of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </dd></dl>

</div>
</div>
<a id="ga3c72bf8623d4e8a6b4e5510cdbc4baac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c72bf8623d4e8a6b4e5510cdbc4baac">&#9670;&nbsp;</a></span>_Thread_Priority_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Priority_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPriority__Node.html">Priority_Node</a> *&#160;</td>
          <td class="paramname"><em>priority_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates a thread priority value change in the specified thread priority node to the corresponding thread priority aggregation. </p>
<p>The caller must be the owner of the thread wait lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priority_node</td><td>The thread priority node to change. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prepend_it</td><td>In case this is true, then the thread is prepended to its priority group in its home scheduler instance, otherwise it is appended. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context to return an updated set of threads for <a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59" title="Updates the priority of all threads in the set.">_Thread_Priority_update()</a>. The thread queue context must be initialized via <a class="el" href="group__RTEMSScoreThreadQueue.html#gab84f558bc470437d43ce863f8024534e" title="Clears the priority update count of the thread queue context.">_Thread_queue_Context_clear_priority_updates()</a> before a call of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </dd></dl>

</div>
</div>
<a id="gad17eecd5728b1ccac519b8c31f641d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad17eecd5728b1ccac519b8c31f641d6b">&#9670;&nbsp;</a></span>_Thread_Priority_highest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a> _Thread_Priority_highest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the highest priority of the left and right thread priorities in the intuitive sense of priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left thread priority. </td></tr>
    <tr><td class="paramname">right</td><td>The right thread priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest priority in the intuitive sense of priority. </dd></dl>

</div>
</div>
<a id="gac2b89051f9d18144e0203d8b7e50630d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2b89051f9d18144e0203d8b7e50630d">&#9670;&nbsp;</a></span>_Thread_Priority_less_than()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Priority_less_than </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScorePriority.html#ga59d02b58072d31a9a1cfe644557aefe2">Priority_Control</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the priority of the thread and changes it sticky level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramname">sticky_level_change</td><td>The new value for the sticky level.Checks if the left thread priority is less than the right thread priority in the intuitive sense of priority.</td></tr>
    <tr><td class="paramname">left</td><td>The left thread priority. </td></tr>
    <tr><td class="paramname">right</td><td>The right thread priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The left priority is less in the intuitive sense. </td></tr>
    <tr><td class="paramname">false</td><td>The left priority is greater or equal in the intuitive sense. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga611029596b3c9930b05c97cbaef6cb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga611029596b3c9930b05c97cbaef6cb24">&#9670;&nbsp;</a></span>_Thread_Priority_perform_actions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Priority_perform_actions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>start_of_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the thread is owner of the lock of the join queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread for the verification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread is owner of the lock of the join queue. </td></tr>
    <tr><td class="paramname">false</td><td>The thread is not owner of the lock of the join queue.Performs the priority actions specified by the thread queue context along the thread queue path.</td></tr>
  </table>
  </dd>
</dl>
<p>The caller must be the owner of the thread wait lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_of_path</td><td>The start thread of the thread queue path. </td></tr>
    <tr><td class="paramname">queue_context</td><td>The thread queue context specifying the thread queue path and initial thread priority actions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>_Thread_queue_Path_acquire_critical(). </dd></dl>

</div>
</div>
<a id="ga8c1e1030ce5bea3614f62e8be650bbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1e1030ce5bea3614f62e8be650bbeb">&#9670;&nbsp;</a></span>_Thread_Priority_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Priority_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPriority__Node.html">Priority_Node</a> *&#160;</td>
          <td class="paramname"><em>priority_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified thread priority node from the corresponding thread priority aggregation. </p>
<p>The caller must be the owner of the thread wait lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramname">priority_node</td><td>The thread priority node to remove. </td></tr>
    <tr><td class="paramname">queue_context</td><td>The thread queue context to return an updated set of threads for <a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59" title="Updates the priority of all threads in the set.">_Thread_Priority_update()</a>. The thread queue context must be initialized via <a class="el" href="group__RTEMSScoreThreadQueue.html#gab84f558bc470437d43ce863f8024534e" title="Clears the priority update count of the thread queue context.">_Thread_queue_Context_clear_priority_updates()</a> before a call of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </dd></dl>

</div>
</div>
<a id="ga4f0fe1a67da542aa18a7cbb3d4e2f47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f0fe1a67da542aa18a7cbb3d4e2f47a">&#9670;&nbsp;</a></span>_Thread_Priority_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Priority_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPriority__Node.html">Priority_Node</a> *&#160;</td>
          <td class="paramname"><em>victim_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPriority__Node.html">Priority_Node</a> *&#160;</td>
          <td class="paramname"><em>replacement_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the victim priority node with the replacement priority node in the corresponding thread priority aggregation. </p>
<p>The caller must be the owner of the thread wait lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramname">victim_node</td><td>The victim thread priority node. </td></tr>
    <tr><td class="paramname">replacement_node</td><td>The replacement thread priority node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </dd></dl>

</div>
</div>
<a id="ga424ec96c6cbed5a748565333d5fd7d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424ec96c6cbed5a748565333d5fd7d59">&#9670;&nbsp;</a></span>_Thread_Priority_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Priority_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the priority of all threads in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_context</td><td>The thread queue context to return an updated set of threads for <a class="el" href="group__RTEMSScoreThread.html#ga424ec96c6cbed5a748565333d5fd7d59" title="Updates the priority of all threads in the set.">_Thread_Priority_update()</a>. The thread queue context must be initialized via <a class="el" href="group__RTEMSScoreThreadQueue.html#gab84f558bc470437d43ce863f8024534e" title="Clears the priority update count of the thread queue context.">_Thread_queue_Context_clear_priority_updates()</a> before a call of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga58d04f5124606eff3a1da3d42cc79e2f" title="Adds the specified thread priority node to the corresponding thread priority aggregation.">_Thread_Priority_add()</a>, <a class="el" href="group__RTEMSScoreThread.html#ga76a9975ac0b320b0a00678534ab78f10" title="Changes the thread priority value of the specified thread priority node in the corresponding thread p...">_Thread_Priority_change()</a>, <a class="el" href="group__RTEMSScoreThread.html#ga3c72bf8623d4e8a6b4e5510cdbc4baac" title="Propagates a thread priority value change in the specified thread priority node to the corresponding ...">_Thread_Priority_changed()</a> and <a class="el" href="group__RTEMSScoreThread.html#ga8c1e1030ce5bea3614f62e8be650bbeb" title="Removes the specified thread priority node from the corresponding thread priority aggregation.">_Thread_Priority_remove()</a>. </dd></dl>

</div>
</div>
<a id="ga02f96739e7d43b6203c1486f82349c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f96739e7d43b6203c1486f82349c93">&#9670;&nbsp;</a></span>_Thread_Remove_timer_and_unblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Remove_timer_and_unblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the watchdog timer from the thread and unblock if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to remove the watchdog from and unblock if necessary. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>The thread queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga778547cad4f7dd7524abb2b9aec0a239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778547cad4f7dd7524abb2b9aec0a239">&#9670;&nbsp;</a></span>_Thread_Resource_count_decrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Resource_count_decrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the thread's resource count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to decrement the resource count of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade8b030c16456ceae1596e2e3fab9808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade8b030c16456ceae1596e2e3fab9808">&#9670;&nbsp;</a></span>_Thread_Resource_count_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Resource_count_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the thread's resource count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to increase the resource count of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga509001fb716aaf996d70507d74b769ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga509001fb716aaf996d70507d74b769ea">&#9670;&nbsp;</a></span>_Thread_Restart_other()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Thread_Restart_other </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to restart. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entry</td><td>The start entry information for <em>the_thread</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lock_context</td><td>The lock context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">false</td><td>The operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecbbb447ef2795643c4055ecd2b0f714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecbbb447ef2795643c4055ecd2b0f714">&#9670;&nbsp;</a></span>_Thread_Restart_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Restart_self </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts the currently executing thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">entry</td><td>The start entry information for <em>executing</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lock_context</td><td>The lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga575076c753d2ea7ee875eea80b638127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575076c753d2ea7ee875eea80b638127">&#9670;&nbsp;</a></span>_Thread_Restore_fp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Restore_fp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the executing thread's floating point area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa10e7acfe1b219ad258d5342bca2bc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa10e7acfe1b219ad258d5342bca2bc63">&#9670;&nbsp;</a></span>_Thread_Save_fp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Save_fp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the executing thread's floating point area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga740b780440af6ea6cf7a3c13373629e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga740b780440af6ea6cf7a3c13373629e3">&#9670;&nbsp;</a></span>_Thread_Scheduler_get_home()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> const <a class="el" href="struct__Scheduler__Control.html">Scheduler_Control</a>* _Thread_Scheduler_get_home </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the home scheduler of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to get the home scheduler of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's home scheduler. </dd></dl>

</div>
</div>
<a id="ga080a177afc4fc254a1081485cd89f75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga080a177afc4fc254a1081485cd89f75d">&#9670;&nbsp;</a></span>_Thread_Scheduler_get_home_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structScheduler__Node.html">Scheduler_Node</a>* _Thread_Scheduler_get_home_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the scheduler's home node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to get the home node of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's home node. </dd></dl>

</div>
</div>
<a id="ga03136c6e5b56781aeff0ace838556d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03136c6e5b56781aeff0ace838556d67">&#9670;&nbsp;</a></span>_Thread_Scheduler_get_node_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="structScheduler__Node.html">Scheduler_Node</a>* _Thread_Scheduler_get_node_by_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>scheduler_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread's scheduler node by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread of which to get a scheduler node. </td></tr>
    <tr><td class="paramname">scheduler_index</td><td>The index of the desired scheduler node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scheduler node with the specified index. </dd></dl>

</div>
</div>
<a id="ga47858fc4679031e1dedcc3188fd79589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47858fc4679031e1dedcc3188fd79589">&#9670;&nbsp;</a></span>_Thread_Set_CPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Set_CPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cpu of the thread's scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu</td><td>The cpu to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5aaea7af4482aebd880403fb9c238af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5aaea7af4482aebd880403fb9c238af">&#9670;&nbsp;</a></span>_Thread_Set_life_protection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a> _Thread_Set_life_protection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga0b4c61e432a0c21855e3122bb394583d">Thread_Life_state</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread to life protected. </p>
<p>Calls _Thread_Change_life with the given state AND THREAD_LIFE_PROTECTED to set and THREAD_LIFE_PROTECTED to clear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The states to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous state the thread was in. </dd></dl>

</div>
</div>
<a id="gae0a3305be3f9998f42871700abf9f89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a3305be3f9998f42871700abf9f89d">&#9670;&nbsp;</a></span>_Thread_Set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status_Control _Thread_Set_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">the_thread</td><td>The thread to change the name of. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The new name for the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_SUCCESSFUL</td><td>The operation succeeded. </td></tr>
    <tr><td class="paramname">STATUS_RESULT_TOO_LARGE</td><td>The name was too long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga630f8dade381bc0c0c70298a757acba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630f8dade381bc0c0c70298a757acba8">&#9670;&nbsp;</a></span>_Thread_Set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> _Thread_Set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified thread state. </p>
<p>In the case the previous state is the ready state, then the thread is blocked by the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>The state to set. It must not be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous state. </dd></dl>

</div>
</div>
<a id="gad6439dfd95e92d9d3b2679d2b7c6891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6439dfd95e92d9d3b2679d2b7c6891a">&#9670;&nbsp;</a></span>_Thread_Set_state_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a> _Thread_Set_state_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreStates.html#gaeebbea0bfca162709b124fd519cf99d3">States_Control</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified thread state without locking the lock context. </p>
<p>In the case the previous state is the ready state, then the thread is blocked by the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>The state to set. It must not be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous state. </dd></dl>

</div>
</div>
<a id="ga03378c6b7617ec1b5fcc541423e662e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03378c6b7617ec1b5fcc541423e662e5">&#9670;&nbsp;</a></span>_Thread_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _Thread_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__Entry__information.html">Thread_Entry_information</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes thread and executes it. </p>
<p>This routine initializes the executable information for a thread and makes it ready to execute. After this routine executes, the thread competes with all other threads for CPU time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to be started. </td></tr>
    <tr><td class="paramname">entry</td><td>The thread entry information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab27215302814d0aa0ec3306b165ea247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab27215302814d0aa0ec3306b165ea247">&#9670;&nbsp;</a></span>_Thread_Start_multitasking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Start_multitasking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts thread multitasking. </p>
<p>This routine initiates multitasking. It is invoked only as part of initialization and its invocation is the last act of the non-multitasking part of the system initialization. </p>

</div>
</div>
<a id="ga9a583864cdcbb7eaeda8002d05de6912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a583864cdcbb7eaeda8002d05de6912">&#9670;&nbsp;</a></span>_Thread_State_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_State_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables interrupts and acquires the lock_context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to acquire the lock context. </td></tr>
    <tr><td class="paramname">lock_context</td><td>The lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd7ff215edf64b4611da7b7c1d4e3050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd7ff215edf64b4611da7b7c1d4e3050">&#9670;&nbsp;</a></span>_Thread_State_acquire_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_State_acquire_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the lock context in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to acquire the lock context. </td></tr>
    <tr><td class="paramname">lock_context</td><td>The lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21404c6b38c1c88748cec78a4bbd25f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21404c6b38c1c88748cec78a4bbd25f1">&#9670;&nbsp;</a></span>_Thread_State_acquire_for_executing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_State_acquire_for_executing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables interrupts and acquires the lock context for the currently executing thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_context</td><td>The lock context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currently executing thread. </dd></dl>

</div>
</div>
<a id="ga958218590f858b65855c89802b2cc071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958218590f858b65855c89802b2cc071">&#9670;&nbsp;</a></span>_Thread_State_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_State_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock context and enables interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to release the lock context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab003d620d9c5fc5502cedd90960d59d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab003d620d9c5fc5502cedd90960d59d5">&#9670;&nbsp;</a></span>_Thread_State_release_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_State_release_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the lock context in a critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to release the lock context. </td></tr>
    <tr><td class="paramname">lock_context</td><td>The lock context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1870eabe77ae0e3913b3888fe4c47185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1870eabe77ae0e3913b3888fe4c47185">&#9670;&nbsp;</a></span>_Thread_Timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWatchdog__Control.html">Watchdog_Control</a> *&#160;</td>
          <td class="paramname"><em>the_watchdog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose thread wait timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_watchdog</td><td>The thread timer watchdog. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb988363d243a9c060fdeb9a2cf3d401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb988363d243a9c060fdeb9a2cf3d401">&#9670;&nbsp;</a></span>_Thread_Timer_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Timer_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structThread__Timer__information.html">Thread_Timer_information</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the thread timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timer</td><td>The timer to initialize. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu</td><td>The cpu for the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21916832cf16bf603f348041e2c04859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21916832cf16bf603f348041e2c04859">&#9670;&nbsp;</a></span>_Thread_Timer_insert_realtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Timer_insert_realtime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreWatchdog.html#ga6ae5e52f6c4046535272c18a8cba66e1">Watchdog_Service_routine_entry</a>&#160;</td>
          <td class="paramname"><em>routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>expire</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the cpu's watchdog realtime into the thread's timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>for the operation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu</td><td>The cpu to get the watchdog header from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">routine</td><td>The watchdog routine for the thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">expire</td><td>Expiration for the watchdog. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8483d8009fe0047a5a48de4a5f6f2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8483d8009fe0047a5a48de4a5f6f2ad7">&#9670;&nbsp;</a></span>_Thread_Timer_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Timer_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the watchdog timer from the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to remove the watchdog from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1234634f1d75c8c0864c5727b526f9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1234634f1d75c8c0864c5727b526f9a3">&#9670;&nbsp;</a></span>_Thread_Unblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Unblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblocks the thread. </p>
<p>This routine clears any blocking state for the_thread. It performs any necessary scheduling operations including the selection of a new heir thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to unblock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc95fd103c5bcd79927f316370080340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc95fd103c5bcd79927f316370080340">&#9670;&nbsp;</a></span>_Thread_Unpin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Unpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu_self</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpins the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executing</td><td>The currently executing thread. </td></tr>
    <tr><td class="paramname">cpu_self</td><td>The cpu for the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga02a75f308e726ba3f36a97cd758a8e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02a75f308e726ba3f36a97cd758a8e7e">&#9670;&nbsp;</a></span>_Thread_Update_CPU_time_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Update_CPU_time_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPer__CPU__Control.html">Per_CPU_Control</a> *&#160;</td>
          <td class="paramname"><em>cpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the cpu time used of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to add additional cpu time that is used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cpu</td><td>The cpu. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8ad190d2fb384bff871065b7e885c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8ad190d2fb384bff871065b7e885c90">&#9670;&nbsp;</a></span>_Thread_Wait_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread wait default lock and disables interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context for the corresponding <a class="el" href="group__RTEMSScoreThread.html#gacb857fbbdbd059ae8e1f6fca8768da96" title="Releases the thread wait lock and restores the previous interrupt status.">_Thread_Wait_release()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31d2b044df5bb8998e4c935fededc17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d2b044df5bb8998e4c935fededc17c">&#9670;&nbsp;</a></span>_Thread_Wait_acquire_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_acquire_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread wait lock inside a critical section (interrupts disabled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context for the corresponding <a class="el" href="group__RTEMSScoreThread.html#gae077609cfcf4bf7a741a5fd36020dcb4" title="Releases the thread wait lock inside a critical section (interrupts disabled).">_Thread_Wait_release_critical()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafed63d230bdeca7d53b9b9aa2b0abbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafed63d230bdeca7d53b9b9aa2b0abbcc">&#9670;&nbsp;</a></span>_Thread_Wait_acquire_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_acquire_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread wait default lock and disables interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The lock context used for the corresponding lock release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gacea1194022db2bc960f47a74946aed8c" title="Releases the thread wait default lock and restores the previous interrupt status.">_Thread_Wait_release_default()</a>. </dd></dl>

</div>
</div>
<a id="gafbc47e5ce486029f2311242f2303c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbc47e5ce486029f2311242f2303c66d">&#9670;&nbsp;</a></span>_Thread_Wait_acquire_default_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_acquire_default_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread wait default lock inside a critical section (interrupts disabled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lock_context</td><td>The lock context used for the corresponding lock release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga1379d753ea2866e64eed15cd7ea7fb38" title="Releases the thread wait default lock inside a critical section (interrupts disabled).">_Thread_Wait_release_default_critical()</a>. </dd></dl>

</div>
</div>
<a id="ga37b50dcc140d5c4e34e4e063339baee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37b50dcc140d5c4e34e4e063339baee5">&#9670;&nbsp;</a></span>_Thread_Wait_acquire_default_for_executing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_Wait_acquire_default_for_executing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the thread wait default lock and returns the executing thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_context</td><td>The lock context used for the corresponding lock release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The executing thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gacea1194022db2bc960f47a74946aed8c" title="Releases the thread wait default lock and restores the previous interrupt status.">_Thread_Wait_release_default()</a>. </dd></dl>

</div>
</div>
<a id="gab82f6b31f52be120df0ff3b5641b52e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab82f6b31f52be120df0ff3b5641b52e2">&#9670;&nbsp;</a></span>_Thread_Wait_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels a thread wait on a thread queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_context</td><td>The thread queue context used for corresponding <a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga032320598e809cb93d80e985906fb393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032320598e809cb93d80e985906fb393">&#9670;&nbsp;</a></span>_Thread_Wait_claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Queue.html">Thread_queue_Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claims the thread wait queue. </p>
<p>The caller must not be the owner of the default thread wait lock. The caller must be the owner of the corresponding thread queue lock. The registration of the corresponding thread queue operations is deferred and done after the deadlock detection. This is crucial to support timeouts on SMP configurations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue</td><td>The new thread queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#gadd97f74b63bbcfb524464371b06df50a" title="Finalizes the thread wait queue claim via registration of the corresponding thread queue operations.">_Thread_Wait_claim_finalize()</a> and <a class="el" href="group__RTEMSScoreThread.html#ga3cfaf5eea12b9810ca64404cec7e3763" title="Restores the default thread wait queue and operations.">_Thread_Wait_restore_default()</a>. </dd></dl>

</div>
</div>
<a id="gadd97f74b63bbcfb524464371b06df50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd97f74b63bbcfb524464371b06df50a">&#9670;&nbsp;</a></span>_Thread_Wait_claim_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_claim_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structThread__queue__Operations.html">Thread_queue_Operations</a> *&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the thread wait queue claim via registration of the corresponding thread queue operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operations</td><td>The corresponding thread queue operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c33d34fc273256480b86586c6be431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c33d34fc273256480b86586c6be431e">&#9670;&nbsp;</a></span>_Thread_Wait_flags_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> _Thread_Wait_flags_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread's wait flags according to the ATOMIC_ORDER_RELAXED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to get the wait flags of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's wait flags. </dd></dl>

</div>
</div>
<a id="ga51f70e86f9127bf1dbb0295590c81a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f70e86f9127bf1dbb0295590c81a45">&#9670;&nbsp;</a></span>_Thread_Wait_flags_get_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> <a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a> _Thread_Wait_flags_get_acquire </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread's wait flags according to the ATOMIC_ORDER_ACQUIRE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to get the wait flags of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's wait flags. </dd></dl>

</div>
</div>
<a id="ga8eb26230b102f8569856d170145a925c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eb26230b102f8569856d170145a925c">&#9670;&nbsp;</a></span>_Thread_Wait_flags_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_flags_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the thread's wait flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread to set the wait flags of. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>The flags to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae67314f8bf6da8f2a14b59fcbe275a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae67314f8bf6da8f2a14b59fcbe275a5b">&#9670;&nbsp;</a></span>_Thread_Wait_flags_try_change_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Wait_flags_try_change_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td>
          <td class="paramname"><em>expected_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td>
          <td class="paramname"><em>desired_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to change the thread wait flags with acquire semantics. </p>
<p>In case the wait flags are equal to the expected wait flags, then the wait flags are set to the desired wait flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramname">expected_flags</td><td>The expected wait flags. </td></tr>
    <tr><td class="paramname">desired_flags</td><td>The desired wait flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The wait flags were equal to the expected wait flags. </td></tr>
    <tr><td class="paramname">false</td><td>The wait flags were not equal to the expected wait flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2c1e8a25615d5aa88b5029feb8d1a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c1e8a25615d5aa88b5029feb8d1a55">&#9670;&nbsp;</a></span>_Thread_Wait_flags_try_change_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> bool _Thread_Wait_flags_try_change_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td>
          <td class="paramname"><em>expected_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__RTEMSScoreThread.html#ga9a047ae9c77bc90a258203d4f2cc57db">Thread_Wait_flags</a>&#160;</td>
          <td class="paramname"><em>desired_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to change the thread wait flags with release semantics in case of success. </p>
<p>Must be called inside a critical section (interrupts disabled).</p>
<p>In case the wait flags are equal to the expected wait flags, then the wait flags are set to the desired wait flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramname">expected_flags</td><td>The expected wait flags. </td></tr>
    <tr><td class="paramname">desired_flags</td><td>The desired wait flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The wait flags were equal to the expected wait flags. </td></tr>
    <tr><td class="paramname">false</td><td>The wait flags were not equal to the expected wait flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6328ea18c90d27d612b075965e88c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6328ea18c90d27d612b075965e88c03">&#9670;&nbsp;</a></span>_Thread_Wait_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a> _Thread_Wait_get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the object identifier of the object containing the current thread wait queue. </p>
<p>This function may be used for debug and system information purposes. The caller must be the owner of the thread lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The thread waits on no thread queue currently, the thread wait queue is not contained in an object, or the current thread state provides insufficient information, e.g. the thread is in the middle of a blocking operation. </td></tr>
    <tr><td class="paramname">other</td><td>The object identifier of the object containing the thread wait queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a8eb44ff0357020e3bc2972747cd8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8eb44ff0357020e3bc2972747cd8fb">&#9670;&nbsp;</a></span>_Thread_Wait_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> Status_Control _Thread_Wait_get_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the wait return code of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread to get the status of the wait return code of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb857fbbdbd059ae8e1f6fca8768da96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb857fbbdbd059ae8e1f6fca8768da96">&#9670;&nbsp;</a></span>_Thread_Wait_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread wait lock and restores the previous interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context used for corresponding <a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae077609cfcf4bf7a741a5fd36020dcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae077609cfcf4bf7a741a5fd36020dcb4">&#9670;&nbsp;</a></span>_Thread_Wait_release_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_release_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Context.html">Thread_queue_Context</a> *&#160;</td>
          <td class="paramname"><em>queue_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread wait lock inside a critical section (interrupts disabled). </p>
<p>The previous interrupt status is not restored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_context</td><td>The thread queue context used for corresponding <a class="el" href="group__RTEMSScoreThread.html#ga31d2b044df5bb8998e4c935fededc17c" title="Acquires the thread wait lock inside a critical section (interrupts disabled).">_Thread_Wait_acquire_critical()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacea1194022db2bc960f47a74946aed8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea1194022db2bc960f47a74946aed8c">&#9670;&nbsp;</a></span>_Thread_Wait_release_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_release_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread wait default lock and restores the previous interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_context</td><td>The lock context used for the corresponding lock acquire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1379d753ea2866e64eed15cd7ea7fb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1379d753ea2866e64eed15cd7ea7fb38">&#9670;&nbsp;</a></span>_Thread_Wait_release_default_critical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_release_default_critical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structISR__lock__Context.html">ISR_lock_Context</a> *&#160;</td>
          <td class="paramname"><em>lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the thread wait default lock inside a critical section (interrupts disabled). </p>
<p>The previous interrupt status is not restored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lock_context</td><td>The lock context used for the corresponding lock acquire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6f75b9158cddc463bad914c2f9f51a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f75b9158cddc463bad914c2f9f51a1">&#9670;&nbsp;</a></span>_Thread_Wait_remove_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_remove_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structThread__queue__Lock__context.html">Thread_queue_Lock_context</a> *&#160;</td>
          <td class="paramname"><em>queue_lock_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a thread wait lock request. </p>
<p>On SMP configurations, removes a thread wait lock request.</p>
<p>On other configurations, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue_lock_context</td><td>The thread queue lock context used for corresponding <a class="el" href="group__RTEMSScoreThread.html#gaa8ad190d2fb384bff871065b7e885c90" title="Acquires the thread wait default lock and disables interrupts.">_Thread_Wait_acquire()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cfaf5eea12b9810ca64404cec7e3763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cfaf5eea12b9810ca64404cec7e3763">&#9670;&nbsp;</a></span>_Thread_Wait_restore_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_restore_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the default thread wait queue and operations. </p>
<p>The caller must be the owner of the current thread wait queue lock.</p>
<p>On SMP configurations, the pending requests are updated to use the stale thread queue operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">the_thread</td><td>The thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga032320598e809cb93d80e985906fb393" title="Claims the thread wait queue.">_Thread_Wait_claim()</a>. </dd></dl>

</div>
</div>
<a id="ga76f9b42638ae02922aa0a94a806f46a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76f9b42638ae02922aa0a94a806f46a9">&#9670;&nbsp;</a></span>_Thread_Wait_tranquilize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreBaseDefs.html#gac216239df231d5dbd15e3520b0b9313f">RTEMS_INLINE_ROUTINE</a> void _Thread_Wait_tranquilize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>the_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tranquilizes the thread after a wait on a thread queue. </p>
<p>After the violent blocking procedure this function makes the thread calm and peaceful again so that it can carry out its normal work.</p>
<p>On SMP configurations, ensures that all pending thread wait lock requests completed before the thread is able to begin a new thread wait procedure.</p>
<p>On other configurations, this function does nothing.</p>
<p>It must be called after a <a class="el" href="group__RTEMSScoreThread.html#ga032320598e809cb93d80e985906fb393" title="Claims the thread wait queue.">_Thread_Wait_claim()</a> exactly once</p><ul>
<li>after the corresponding thread queue lock was released, and</li>
<li>the default wait state is restored or some other processor is about to do this.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_thread</td><td>The thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82c1e28e7fcc27135782ff978dcdcb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c1e28e7fcc27135782ff978dcdcb8f">&#9670;&nbsp;</a></span>_Thread_Yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _Thread_Yield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Thread__Control.html">Thread_Control</a> *&#160;</td>
          <td class="paramname"><em>executing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields the currently executing thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">executing</td><td>The thread that performs a yield. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5dc64d34fc67591fa08d18fb6aa055ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dc64d34fc67591fa08d18fb6aa055ca">&#9670;&nbsp;</a></span>rtems_iterate_over_all_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_iterate_over_all_threads </td>
          <td>(</td>
          <td class="paramtype">rtems_per_thread_routine&#160;</td>
          <td class="paramname"><em>routine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated, use <a class="el" href="group__ClassicTasks.html#ga7255f41eb20238aebe5ce139d5dfd97d" title="Iterates over all tasks in the system.">rtems_task_iterate()</a> instead. </p>
<p>Use <a class="el" href="group__ClassicTasks.html#ga7255f41eb20238aebe5ce139d5dfd97d" title="Iterates over all tasks in the system.">rtems_task_iterate()</a> instead. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga87bfa1f152fd21a58c739c76cf260527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87bfa1f152fd21a58c739c76cf260527">&#9670;&nbsp;</a></span>_Thread_Allocated_fp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Thread__Control.html">Thread_Control</a>* _Thread_Allocated_fp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following points to the thread whose floating point context is currently loaded. </p>

</div>
</div>
<a id="ga93f9a4600ed05daba5da3a8111393fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93f9a4600ed05daba5da3a8111393fbb">&#9670;&nbsp;</a></span>_Thread_Control_add_on_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t _Thread_Control_add_on_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread control add-on count. </p>
<p>Count of entries in _Thread_Control_add_ons.</p>
<p>This value is provided via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="ga60a80015d5ec442d6e0f42c1c7969d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60a80015d5ec442d6e0f42c1c7969d0a">&#9670;&nbsp;</a></span>_Thread_Control_add_ons</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structThread__Control__add__on.html">Thread_Control_add_on</a> _Thread_Control_add_ons[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread control add-ons. </p>
<p>The thread control block contains fields that point to application configuration dependent memory areas, like the scheduler information, the API control blocks, the user extension context table, and the Newlib re-entrancy support. Account for these areas in the configuration and avoid extra workspace allocations for these areas.</p>
<p>This array is provided via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__RTEMSScoreThread.html#ga93f9a4600ed05daba5da3a8111393fbb" title="Thread control add-on count.">_Thread_Control_add_on_count</a>. </dd></dl>

</div>
</div>
<a id="ga547b3e17ad8dc24bd9e8385a89479174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga547b3e17ad8dc24bd9e8385a89479174">&#9670;&nbsp;</a></span>_Thread_Global_constructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__RTEMSScoreObject.html#ga5821f52a51072941bdd603e542d0863e">Objects_Id</a> _Thread_Global_constructor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object identifier of the global constructor thread. </p>
<p>This variable is set by _RTEMS_tasks_Initialize_user_tasks_body() or _POSIX_Threads_Initialize_user_threads_body().</p>
<p>It is consumed by <a class="el" href="group__RTEMSScoreThread.html#gae0c3a615798c7cc70dc9ff6d9317df46" title="Wrapper function for all threads.">_Thread_Handler()</a>. </p>

</div>
</div>
<a id="ga7db3304111f98acc3634f7cc04dcff2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db3304111f98acc3634f7cc04dcff2f">&#9670;&nbsp;</a></span>_Thread_Idle_body</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__RTEMSScoreThread.html#ga45e6fd0b5cd35ee2ea9e36be90a84c1b">Thread_Idle_body</a> _Thread_Idle_body</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The idle thread body. </p>
<p>This constant is defined by the application configuration via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="gacc61cd772951a83d83af82eba3ff4613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc61cd772951a83d83af82eba3ff4613">&#9670;&nbsp;</a></span>_Thread_Idle_stack_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t _Thread_Idle_stack_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The idle thread stack size in bytes. </p>
<p>This constant is defined by the application configuration via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="gac8376902a32f888326684fc14078057c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8376902a32f888326684fc14078057c">&#9670;&nbsp;</a></span>_Thread_Idle_stacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char _Thread_Idle_stacks[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The idle thread stacks. </p>
<p>Provided by the application via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="ga1626b8af19f26d5f6874121bb3c1cc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1626b8af19f26d5f6874121bb3c1cc05">&#9670;&nbsp;</a></span>_Thread_Initial_thread_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t _Thread_Initial_thread_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count of configured threads. </p>
<p>This value is provided via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="gae17e2d6bbad850c7adffc4515ac56087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae17e2d6bbad850c7adffc4515ac56087">&#9670;&nbsp;</a></span>_Thread_Maximum_name_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t _Thread_Maximum_name_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of a thread name in characters (including the terminating '\0' character). </p>
<p>This value is provided via &lt;<a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">rtems/confdefs.h</a>&gt;. </p>

</div>
</div>
<a id="ga2b3416f9db9d594d76db105d8a7ad343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b3416f9db9d594d76db105d8a7ad343">&#9670;&nbsp;</a></span>rtems_ada_self</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtems_ada_self</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Self for the GNU Ada Run-Time </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
