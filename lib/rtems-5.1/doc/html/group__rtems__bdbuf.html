<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTEMS: Block Device Buffer Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rtemslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTEMS
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Block Device Buffer Management<div class="ingroups"><a class="el" href="group__RTEMSDeviceDrivers.html">Device Drivers</a> &raquo; <a class="el" href="group__rtems__libblock.html">Block Device Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:bdbuf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdbuf_8h.html">bdbuf.h</a></td></tr>
<tr class="memdesc:bdbuf_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block Device Buffer Management. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:bdbuf_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdbuf_8c.html">bdbuf.c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtems__bdbuf__group.html">rtems_bdbuf_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtems__bdbuf__config.html">rtems_bdbuf_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaae5144ea7d6721e55dfeda0c8df8d370"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gaae5144ea7d6721e55dfeda0c8df8d370">RTEMS_BDBUF_MAX_READ_AHEAD_BLOCKS_DEFAULT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gaae5144ea7d6721e55dfeda0c8df8d370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9572529188b3c315f4f0b0b160129dba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga9572529188b3c315f4f0b0b160129dba">RTEMS_BDBUF_MAX_WRITE_BLOCKS_DEFAULT</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga9572529188b3c315f4f0b0b160129dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4389b6ef4328f397e91288e8479a944c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga4389b6ef4328f397e91288e8479a944c">RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT</a>&#160;&#160;&#160;15</td></tr>
<tr class="separator:ga4389b6ef4328f397e91288e8479a944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2286d9fcac2fdd6f19497da7faa82f81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga2286d9fcac2fdd6f19497da7faa82f81">RTEMS_BDBUF_SWAPOUT_TASK_SWAP_PERIOD_DEFAULT</a>&#160;&#160;&#160;250</td></tr>
<tr class="separator:ga2286d9fcac2fdd6f19497da7faa82f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5083de2064c8c45031afe425b65812d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gab5083de2064c8c45031afe425b65812d">RTEMS_BDBUF_SWAPOUT_TASK_BLOCK_HOLD_DEFAULT</a>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:gab5083de2064c8c45031afe425b65812d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a9167effd55601db78237e927c0288"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga43a9167effd55601db78237e927c0288">RTEMS_BDBUF_SWAPOUT_WORKER_TASKS_DEFAULT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga43a9167effd55601db78237e927c0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a9f2ff52d57ceb4f3897da82942fee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga49a9f2ff52d57ceb4f3897da82942fee">RTEMS_BDBUF_SWAPOUT_WORKER_TASK_PRIORITY_DEFAULT</a>&#160;&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#ga4389b6ef4328f397e91288e8479a944c">RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT</a></td></tr>
<tr class="separator:ga49a9f2ff52d57ceb4f3897da82942fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e516e2a5ff9d285cef0aacb6c0768c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga6e516e2a5ff9d285cef0aacb6c0768c1">RTEMS_BDBUF_READ_AHEAD_TASK_PRIORITY_DEFAULT</a>&#160;&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#ga4389b6ef4328f397e91288e8479a944c">RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT</a></td></tr>
<tr class="separator:ga6e516e2a5ff9d285cef0aacb6c0768c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a54490a2930a1a321c5b06cc5e3e54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga39a54490a2930a1a321c5b06cc5e3e54">RTEMS_BDBUF_TASK_STACK_SIZE_DEFAULT</a>&#160;&#160;&#160;<a class="el" href="group__RTEMSAPIClassic.html#ga2e35188053c5e97a85df8e3aa4d23d2f">RTEMS_MINIMUM_STACK_SIZE</a></td></tr>
<tr class="separator:ga39a54490a2930a1a321c5b06cc5e3e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb4bb2bf0d5333d78272725eab143f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga2bb4bb2bf0d5333d78272725eab143f8">RTEMS_BDBUF_CACHE_MEMORY_SIZE_DEFAULT</a>&#160;&#160;&#160;(64 * 512)</td></tr>
<tr class="separator:ga2bb4bb2bf0d5333d78272725eab143f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad496ebd5fc85425bc1d8545955051ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gaad496ebd5fc85425bc1d8545955051ca">RTEMS_BDBUF_BUFFER_MIN_SIZE_DEFAULT</a>&#160;&#160;&#160;(512)</td></tr>
<tr class="separator:gaad496ebd5fc85425bc1d8545955051ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de9417ce0cc9bce90e924796c191cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga3de9417ce0cc9bce90e924796c191cc2">RTEMS_BDBUF_BUFFER_MAX_SIZE_DEFAULT</a>&#160;&#160;&#160;(4096)</td></tr>
<tr class="separator:ga3de9417ce0cc9bce90e924796c191cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac1425c77af823674c78f853694284a44"><td class="memItemLeft" align="right" valign="top"><a id="gac1425c77af823674c78f853694284a44"></a>
typedef struct <a class="el" href="structrtems__bdbuf__group.html">rtems_bdbuf_group</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtems_bdbuf_group</b></td></tr>
<tr class="separator:gac1425c77af823674c78f853694284a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce5a2661bea8023c1b5097f7566f051"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gacce5a2661bea8023c1b5097f7566f051">rtems_bdbuf_buffer</a></td></tr>
<tr class="separator:gacce5a2661bea8023c1b5097f7566f051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f5fc331dd33379471c78d5459c69f7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrtems__bdbuf__config.html">rtems_bdbuf_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gaf4f5fc331dd33379471c78d5459c69f7">rtems_bdbuf_config</a></td></tr>
<tr class="separator:gaf4f5fc331dd33379471c78d5459c69f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0169f36547d36f0723b6456172eeef0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga0169f36547d36f0723b6456172eeef0a">rtems_bdbuf_buf_state</a> { <br />
&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aa71f15d80aec284191be9dd7aa16ba12c">RTEMS_BDBUF_STATE_FREE</a> = 0, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aaf20ea6300aa6f0c306411e459e346655">RTEMS_BDBUF_STATE_EMPTY</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aac3b227c132567db236f300a26b092a69">RTEMS_BDBUF_STATE_CACHED</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aa366b8d851fe5a11f4733c00b1409df7d">RTEMS_BDBUF_STATE_ACCESS_CACHED</a>, 
<br />
&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aab079a61b153c4b0313bcc2a788131e02">RTEMS_BDBUF_STATE_ACCESS_MODIFIED</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aa4939e1384db29ded8d98dff95580a4ed">RTEMS_BDBUF_STATE_ACCESS_EMPTY</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aa4ae71d01cced39a3dc2339a68d5fdb3c">RTEMS_BDBUF_STATE_ACCESS_PURGED</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aad4ad56ebb96642f2c35a59d50e04cdc8">RTEMS_BDBUF_STATE_MODIFIED</a>, 
<br />
&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aa2c826ea2246ca7a4bab97a5879cbf99d">RTEMS_BDBUF_STATE_SYNC</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aa50fc56fabf62a4753588ad64aabb2c9c">RTEMS_BDBUF_STATE_TRANSFER</a>, 
<a class="el" href="group__rtems__bdbuf.html#gga0169f36547d36f0723b6456172eeef0aacef35ec154e4f4fe26262af3ed685ca7">RTEMS_BDBUF_STATE_TRANSFER_PURGED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga0169f36547d36f0723b6456172eeef0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of a buffer of the cache.  <a href="group__rtems__bdbuf.html#ga0169f36547d36f0723b6456172eeef0a">More...</a><br /></td></tr>
<tr class="separator:ga0169f36547d36f0723b6456172eeef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf19ee8ba7815e24767b6a91e200a78bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init</a> (void)</td></tr>
<tr class="separator:gaf19ee8ba7815e24767b6a91e200a78bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fa34cc25ade6d09797b0dc88cf33e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga05fa34cc25ade6d09797b0dc88cf33e1">rtems_bdbuf_get</a> (<a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd, <a class="el" href="group__rtems__disk.html#ga5fbcfd40b657bff6c54d9e393fab3274">rtems_blkdev_bnum</a> block, <a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> **bd)</td></tr>
<tr class="separator:ga05fa34cc25ade6d09797b0dc88cf33e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8546cefc842eef10cdb5b38a6cead9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga8546cefc842eef10cdb5b38a6cead9f7">rtems_bdbuf_read</a> (<a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd, <a class="el" href="group__rtems__disk.html#ga5fbcfd40b657bff6c54d9e393fab3274">rtems_blkdev_bnum</a> block, <a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> **bd)</td></tr>
<tr class="separator:ga8546cefc842eef10cdb5b38a6cead9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga005a3a396079975d67eac6de5640d744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga005a3a396079975d67eac6de5640d744">rtems_bdbuf_release</a> (<a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> *bd)</td></tr>
<tr class="separator:ga005a3a396079975d67eac6de5640d744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8af85cf0abcb0858811f74130aa6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga3f8af85cf0abcb0858811f74130aa6c7">rtems_bdbuf_release_modified</a> (<a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> *bd)</td></tr>
<tr class="separator:ga3f8af85cf0abcb0858811f74130aa6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a49c1519760b60eace0463277af50ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga9a49c1519760b60eace0463277af50ee">rtems_bdbuf_sync</a> (<a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> *bd)</td></tr>
<tr class="separator:ga9a49c1519760b60eace0463277af50ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f02deb0d0ca33a6b9da04b9f3f2078d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga1f02deb0d0ca33a6b9da04b9f3f2078d">rtems_bdbuf_syncdev</a> (<a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd)</td></tr>
<tr class="separator:ga1f02deb0d0ca33a6b9da04b9f3f2078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7712bcd488ea249f4a84d362126d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gadc7712bcd488ea249f4a84d362126d46">rtems_bdbuf_purge_dev</a> (<a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd)</td></tr>
<tr class="memdesc:gadc7712bcd488ea249f4a84d362126d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purges all buffers corresponding to the disk device <em>dd</em>.  <a href="#gadc7712bcd488ea249f4a84d362126d46">More...</a><br /></td></tr>
<tr class="separator:gadc7712bcd488ea249f4a84d362126d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649b3b4fb368921f579a0204552a7a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga649b3b4fb368921f579a0204552a7a60">rtems_bdbuf_set_block_size</a> (<a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd, uint32_t block_size, bool <a class="el" href="sync_8c.html#ac4fa2e6d36e97983d62b9377cc4f6c73">sync</a>)</td></tr>
<tr class="memdesc:ga649b3b4fb368921f579a0204552a7a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the block size of a disk device.  <a href="#ga649b3b4fb368921f579a0204552a7a60">More...</a><br /></td></tr>
<tr class="separator:ga649b3b4fb368921f579a0204552a7a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd6ce1ba113683d019a29d04861f33d"><td class="memItemLeft" align="right" valign="top"><a id="ga9dd6ce1ba113683d019a29d04861f33d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga9dd6ce1ba113683d019a29d04861f33d">rtems_bdbuf_get_device_stats</a> (const <a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd, <a class="el" href="structrtems__blkdev__stats.html">rtems_blkdev_stats</a> *stats)</td></tr>
<tr class="memdesc:ga9dd6ce1ba113683d019a29d04861f33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block device statistics. <br /></td></tr>
<tr class="separator:ga9dd6ce1ba113683d019a29d04861f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f88a5110e6063af34b36063edd291f1"><td class="memItemLeft" align="right" valign="top"><a id="ga2f88a5110e6063af34b36063edd291f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#ga2f88a5110e6063af34b36063edd291f1">rtems_bdbuf_reset_device_stats</a> (<a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *dd)</td></tr>
<tr class="memdesc:ga2f88a5110e6063af34b36063edd291f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the block device statistics. <br /></td></tr>
<tr class="separator:ga2f88a5110e6063af34b36063edd291f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac1ab295c43675e17b20a7af3956c2a72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrtems__bdbuf__config.html">rtems_bdbuf_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtems__bdbuf.html#gac1ab295c43675e17b20a7af3956c2a72">rtems_bdbuf_configuration</a></td></tr>
<tr class="separator:gac1ab295c43675e17b20a7af3956c2a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Block Device Buffer Management implements a cache between the disk devices and file systems. The code provides read-ahead and write queuing to the drivers and fast cache look-up using an AVL tree.</p>
<p>The block size used by a file system can be set at runtime and must be a multiple of the disk device block size. The disk device's physical block size is called the media block size. The file system can set the block size it uses to a larger multiple of the media block size. The driver must be able to handle buffers sizes larger than one media block.</p>
<p>The user configures the amount of memory to be used as buffers in the cache, and the minimum and maximum buffer size. The cache will allocate additional memory for the buffer descriptors and groups. There are enough buffer descriptors allocated so all the buffer memory can be used as minimum sized buffers.</p>
<p>The cache is a single pool of buffers. The buffer memory is divided into groups where the size of buffer memory allocated to a group is the maximum buffer size. A group's memory can be divided down into small buffer sizes that are a multiple of 2 of the minimum buffer size. A group is the minimum allocation unit for buffers of a specific size. If a buffer of maximum size is request the group will have a single buffer. If a buffer of minimum size is requested the group is divided into minimum sized buffers and the remaining buffers are held ready for use. A group keeps track of which buffers are with a file system or driver and groups who have buffer in use cannot be realloced. Groups with no buffers in use can be taken and realloced to a new size. This is how buffers of different sizes move around the cache.</p>
<p>The buffers are held in various lists in the cache. All buffers follow this state machine:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
</div>
<p>Empty or cached buffers are added to the LRU list and removed from this queue when a caller requests a buffer. This is referred to as getting a buffer in the code and the event get in the state diagram. The buffer is assigned to a block and inserted to the AVL based on the block/device key. If the block is to be read by the user and not in the cache it is transfered from the disk into memory. If no buffers are on the LRU list the modified list is checked. If buffers are on the modified the swap out task will be woken. The request blocks until a buffer is available for recycle.</p>
<p>A block being accessed is given to the file system layer and not accessible to another requester until released back to the cache. The same goes to a buffer in the transfer state. The transfer state means being read or written. If the file system has modified the block and releases it as modified it placed on the cache's modified list and a hold timer initialised. The buffer is held for the hold time before being written to disk. Buffers are held for a configurable period of time on the modified list as a write sets the state to transfer and this locks the buffer out from the file system until the write completes. Buffers are often accessed and modified in a series of small updates so if sent to the disk when released as modified the user would have to block waiting until it had been written. This would be a performance problem.</p>
<p>The code performs multiple block reads and writes. Multiple block reads or read-ahead increases performance with hardware that supports it. It also helps with a large cache as the disk head movement is reduced. It however is a speculative operation so excessive use can remove valuable and needed blocks from the cache. The read-ahead is triggered after two misses of ascending consecutive blocks or a read hit of a block read by the most-resent read-ahead transfer. The read-ahead works per disk, but all transfers are issued by the read-ahead task.</p>
<p>The cache has the following lists of buffers:</p><ul>
<li>LRU: Accessed or transfered buffers released in least recently used order. Empty buffers will be placed to the front.</li>
<li>Modified: Buffers waiting to be written to disk.</li>
<li>Sync: Buffers to be synchronized with the disk.</li>
</ul>
<p>A cache look-up will be performed to find a suitable buffer. A suitable buffer is one that matches the same allocation size as the device the buffer is for. The a buffer's group has no buffers in use with the file system or driver the group is reallocated. This means the buffers in the group are invalidated, resized and placed on the LRU queue. There is a performance issue with this design. The reallocation of a group may forced recently accessed buffers out of the cache when they should not. The design should be change to have groups on a LRU list if they have no buffers in use. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3de9417ce0cc9bce90e924796c191cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3de9417ce0cc9bce90e924796c191cc2">&#9670;&nbsp;</a></span>RTEMS_BDBUF_BUFFER_MAX_SIZE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_BUFFER_MAX_SIZE_DEFAULT&#160;&#160;&#160;(4096)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default maximum size of buffers. </p>

</div>
</div>
<a id="gaad496ebd5fc85425bc1d8545955051ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad496ebd5fc85425bc1d8545955051ca">&#9670;&nbsp;</a></span>RTEMS_BDBUF_BUFFER_MIN_SIZE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_BUFFER_MIN_SIZE_DEFAULT&#160;&#160;&#160;(512)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default minimum size of buffers. </p>

</div>
</div>
<a id="ga2bb4bb2bf0d5333d78272725eab143f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb4bb2bf0d5333d78272725eab143f8">&#9670;&nbsp;</a></span>RTEMS_BDBUF_CACHE_MEMORY_SIZE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_CACHE_MEMORY_SIZE_DEFAULT&#160;&#160;&#160;(64 * 512)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default size of memory allocated to the cache. </p>

</div>
</div>
<a id="gaae5144ea7d6721e55dfeda0c8df8d370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae5144ea7d6721e55dfeda0c8df8d370">&#9670;&nbsp;</a></span>RTEMS_BDBUF_MAX_READ_AHEAD_BLOCKS_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_MAX_READ_AHEAD_BLOCKS_DEFAULT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default value for the maximum read-ahead blocks disables the read-ahead feature. </p>

</div>
</div>
<a id="ga9572529188b3c315f4f0b0b160129dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9572529188b3c315f4f0b0b160129dba">&#9670;&nbsp;</a></span>RTEMS_BDBUF_MAX_WRITE_BLOCKS_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_MAX_WRITE_BLOCKS_DEFAULT&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default maximum number of blocks to write at once. </p>

</div>
</div>
<a id="ga6e516e2a5ff9d285cef0aacb6c0768c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e516e2a5ff9d285cef0aacb6c0768c1">&#9670;&nbsp;</a></span>RTEMS_BDBUF_READ_AHEAD_TASK_PRIORITY_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_READ_AHEAD_TASK_PRIORITY_DEFAULT&#160;&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#ga4389b6ef4328f397e91288e8479a944c">RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default read-ahead task priority. The same as the swap-out task. </p>

</div>
</div>
<a id="gab5083de2064c8c45031afe425b65812d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5083de2064c8c45031afe425b65812d">&#9670;&nbsp;</a></span>RTEMS_BDBUF_SWAPOUT_TASK_BLOCK_HOLD_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_SWAPOUT_TASK_BLOCK_HOLD_DEFAULT&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default swap-out task block hold time in milli seconds. </p>

</div>
</div>
<a id="ga4389b6ef4328f397e91288e8479a944c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4389b6ef4328f397e91288e8479a944c">&#9670;&nbsp;</a></span>RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default swap-out task priority. </p>

</div>
</div>
<a id="ga2286d9fcac2fdd6f19497da7faa82f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2286d9fcac2fdd6f19497da7faa82f81">&#9670;&nbsp;</a></span>RTEMS_BDBUF_SWAPOUT_TASK_SWAP_PERIOD_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_SWAPOUT_TASK_SWAP_PERIOD_DEFAULT&#160;&#160;&#160;250</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default swap-out task swap period in milli seconds. </p>

</div>
</div>
<a id="ga49a9f2ff52d57ceb4f3897da82942fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a9f2ff52d57ceb4f3897da82942fee">&#9670;&nbsp;</a></span>RTEMS_BDBUF_SWAPOUT_WORKER_TASK_PRIORITY_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_SWAPOUT_WORKER_TASK_PRIORITY_DEFAULT&#160;&#160;&#160;<a class="el" href="group__rtems__bdbuf.html#ga4389b6ef4328f397e91288e8479a944c">RTEMS_BDBUF_SWAPOUT_TASK_PRIORITY_DEFAULT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default swap-out worker task priority. The same as the swap-out task. </p>

</div>
</div>
<a id="ga43a9167effd55601db78237e927c0288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43a9167effd55601db78237e927c0288">&#9670;&nbsp;</a></span>RTEMS_BDBUF_SWAPOUT_WORKER_TASKS_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_SWAPOUT_WORKER_TASKS_DEFAULT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default swap-out worker tasks. Currently disabled. </p>

</div>
</div>
<a id="ga39a54490a2930a1a321c5b06cc5e3e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a54490a2930a1a321c5b06cc5e3e54">&#9670;&nbsp;</a></span>RTEMS_BDBUF_TASK_STACK_SIZE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTEMS_BDBUF_TASK_STACK_SIZE_DEFAULT&#160;&#160;&#160;<a class="el" href="group__RTEMSAPIClassic.html#ga2e35188053c5e97a85df8e3aa4d23d2f">RTEMS_MINIMUM_STACK_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default task stack size for swap-out and worker tasks. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacce5a2661bea8023c1b5097f7566f051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce5a2661bea8023c1b5097f7566f051">&#9670;&nbsp;</a></span>rtems_bdbuf_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a>  <a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To manage buffers we using buffer descriptors (BD). A BD holds a buffer plus a range of other information related to managing the buffer in the cache. To speed-up buffer lookup descriptors are organized in AVL-Tree. The fields 'dd' and 'block' are search keys. </p>

</div>
</div>
<a id="gaf4f5fc331dd33379471c78d5459c69f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4f5fc331dd33379471c78d5459c69f7">&#9670;&nbsp;</a></span>rtems_bdbuf_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrtems__bdbuf__config.html">rtems_bdbuf_config</a>  <a class="el" href="structrtems__bdbuf__config.html">rtems_bdbuf_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffering configuration definition. See <a class="el" href="confdefs_8h.html" title="Evaluate Configuration Options.">confdefs.h</a> for support on using this structure. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0169f36547d36f0723b6456172eeef0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0169f36547d36f0723b6456172eeef0a">&#9670;&nbsp;</a></span>rtems_bdbuf_buf_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtems__bdbuf.html#ga0169f36547d36f0723b6456172eeef0a">rtems_bdbuf_buf_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of a buffer of the cache. </p>
<p>The state has several implications. Depending on the state a buffer can be in the AVL tree, in a list, in use by an entity and a group user or not.</p>
<table class="doxtable">
<tr>
<th>State</th><th>Valid Data</th><th>AVL Tree </th><th>LRU List</th><th>Modified List</th><th>Synchronization List </th><th>Group User</th><th>External User  </th></tr>
<tr>
<td>FREE</td><td></td><td></td><td>X</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>EMPTY</td><td></td><td>X </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>CACHED</td><td>X</td><td>X </td><td>X</td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ACCESS CACHED</td><td>X</td><td>X </td><td></td><td></td><td></td><td>X</td><td>X  </td></tr>
<tr>
<td>ACCESS MODIFIED</td><td>X</td><td>X </td><td></td><td></td><td></td><td>X</td><td>X  </td></tr>
<tr>
<td>ACCESS EMPTY</td><td></td><td>X </td><td></td><td></td><td></td><td>X</td><td>X  </td></tr>
<tr>
<td>ACCESS PURGED</td><td></td><td>X </td><td></td><td></td><td></td><td>X</td><td>X  </td></tr>
<tr>
<td>MODIFIED</td><td>X</td><td>X </td><td></td><td>X</td><td></td><td>X</td><td></td></tr>
<tr>
<td>SYNC</td><td>X</td><td>X </td><td></td><td></td><td>X</td><td>X</td><td></td></tr>
<tr>
<td>TRANSFER</td><td>X</td><td>X </td><td></td><td></td><td></td><td>X</td><td>X  </td></tr>
<tr>
<td>TRANSFER PURGED</td><td></td><td>X </td><td></td><td></td><td></td><td>X</td><td>X  </td></tr>
</table>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aa71f15d80aec284191be9dd7aa16ba12c"></a>RTEMS_BDBUF_STATE_FREE&#160;</td><td class="fielddoc"><p>Free. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aaf20ea6300aa6f0c306411e459e346655"></a>RTEMS_BDBUF_STATE_EMPTY&#160;</td><td class="fielddoc"><p>Empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aac3b227c132567db236f300a26b092a69"></a>RTEMS_BDBUF_STATE_CACHED&#160;</td><td class="fielddoc"><p>Cached. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aa366b8d851fe5a11f4733c00b1409df7d"></a>RTEMS_BDBUF_STATE_ACCESS_CACHED&#160;</td><td class="fielddoc"><p>Accessed by upper layer with cached data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aab079a61b153c4b0313bcc2a788131e02"></a>RTEMS_BDBUF_STATE_ACCESS_MODIFIED&#160;</td><td class="fielddoc"><p>Accessed by upper layer with modified data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aa4939e1384db29ded8d98dff95580a4ed"></a>RTEMS_BDBUF_STATE_ACCESS_EMPTY&#160;</td><td class="fielddoc"><p>Accessed by upper layer with invalid data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aa4ae71d01cced39a3dc2339a68d5fdb3c"></a>RTEMS_BDBUF_STATE_ACCESS_PURGED&#160;</td><td class="fielddoc"><p>Accessed by upper layer with purged data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aad4ad56ebb96642f2c35a59d50e04cdc8"></a>RTEMS_BDBUF_STATE_MODIFIED&#160;</td><td class="fielddoc"><p>Modified by upper layer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aa2c826ea2246ca7a4bab97a5879cbf99d"></a>RTEMS_BDBUF_STATE_SYNC&#160;</td><td class="fielddoc"><p>Scheduled for synchronization. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aa50fc56fabf62a4753588ad64aabb2c9c"></a>RTEMS_BDBUF_STATE_TRANSFER&#160;</td><td class="fielddoc"><p>In transfer by block device driver. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0169f36547d36f0723b6456172eeef0aacef35ec154e4f4fe26262af3ed685ca7"></a>RTEMS_BDBUF_STATE_TRANSFER_PURGED&#160;</td><td class="fielddoc"><p>In transfer by block device driver and purged. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga05fa34cc25ade6d09797b0dc88cf33e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05fa34cc25ade6d09797b0dc88cf33e1">&#9670;&nbsp;</a></span>rtems_bdbuf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtems__disk.html#ga5fbcfd40b657bff6c54d9e393fab3274">rtems_blkdev_bnum</a>&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> **&#160;</td>
          <td class="paramname"><em>bd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get block buffer for data to be written into. The buffers is set to the access or modified access state. If the buffer is in the cache and modified the state is access modified else the state is access. This buffer contents are not initialised if the buffer is not already in the cache. If the block is already resident in memory it is returned how-ever if not in memory the buffer is not read from disk. This call is used when writing the whole block on a disk rather than just changing a part of it. If there is no buffers available this call will block. A buffer obtained with this call will not be involved in a transfer request and will not be returned to another user until released. If the buffer is already with a user when this call is made the call is blocked until the buffer is returned. The highest priority waiter will obtain the buffer first.</p>
<p>The block number is the linear block number. This is relative to the start of the partition on the media.</p>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>[in] The disk device. </td></tr>
    <tr><td class="paramname">block</td><td>[in] Linear media block number. </td></tr>
    <tr><td class="paramname">bd</td><td>[out] Reference to the buffer descriptor pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_ID</td><td>Invalid block number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf19ee8ba7815e24767b6a91e200a78bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf19ee8ba7815e24767b6a91e200a78bc">&#9670;&nbsp;</a></span>rtems_bdbuf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare buffering layer to work - initialize buffer descritors and (if it is neccessary) buffers. After initialization all blocks is placed into the ready state.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_CALLED_FROM_ISR</td><td>Called from an interrupt context. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_NUMBER</td><td>The buffer maximum is not an integral multiple of the buffer minimum. The maximum read-ahead blocks count is too large. </td></tr>
    <tr><td class="paramname">RTEMS_RESOURCE_IN_USE</td><td>Already initialized. </td></tr>
    <tr><td class="paramname">RTEMS_UNSATISFIED</td><td>Not enough resources. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc7712bcd488ea249f4a84d362126d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc7712bcd488ea249f4a84d362126d46">&#9670;&nbsp;</a></span>rtems_bdbuf_purge_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtems_bdbuf_purge_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Purges all buffers corresponding to the disk device <em>dd</em>. </p>
<p>This may result in loss of data. The read-ahead state of this device is reset.</p>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>[in] The disk device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8546cefc842eef10cdb5b38a6cead9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8546cefc842eef10cdb5b38a6cead9f7">&#9670;&nbsp;</a></span>rtems_bdbuf_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtems__disk.html#ga5fbcfd40b657bff6c54d9e393fab3274">rtems_blkdev_bnum</a>&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> **&#160;</td>
          <td class="paramname"><em>bd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the block buffer and if not already in the cache read from the disk. If specified block already cached return. The buffer is set to the access or modified access state. If the buffer is in the cache and modified the state is access modified else the state is access. If block is already being read from disk for being written to disk this call blocks. If the buffer is waiting to be written it is removed from modified queue and returned to the user. If the buffer is not in the cache a new buffer is obtained and the data read from disk. The call may block until these operations complete. A buffer obtained with this call will not be involved in a transfer request and will not be returned to another user until released. If the buffer is already with a user when this call is made the call is blocked until the buffer is returned. The highest priority waiter will obtain the buffer first.</p>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>[in] The disk device. </td></tr>
    <tr><td class="paramname">block</td><td>[in] Linear media block number. </td></tr>
    <tr><td class="paramname">bd</td><td>[out] Reference to the buffer descriptor pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_ID</td><td>Invalid block number. </td></tr>
    <tr><td class="paramname">RTEMS_IO_ERROR</td><td><a class="el" href="structIO.html">IO</a> error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga005a3a396079975d67eac6de5640d744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005a3a396079975d67eac6de5640d744">&#9670;&nbsp;</a></span>rtems_bdbuf_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> *&#160;</td>
          <td class="paramname"><em>bd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the buffer obtained by a read call back to the cache. If the buffer was obtained by a get call and was not already in the cache the release modified call should be used. A buffer released with this call obtained by a get call may not be in sync with the contents on disk. If the buffer was in the cache and modified before this call it will be returned to the modified queue. The buffers is returned to the end of the LRU list.</p>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd</td><td>[in] Reference to the buffer descriptor. The buffer descriptor reference must not be <code>NULL</code> and must be obtained via <a class="el" href="group__rtems__bdbuf.html#ga05fa34cc25ade6d09797b0dc88cf33e1">rtems_bdbuf_get()</a> or <a class="el" href="group__rtems__bdbuf.html#ga8546cefc842eef10cdb5b38a6cead9f7">rtems_bdbuf_read()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_ADDRESS</td><td>The reference is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f8af85cf0abcb0858811f74130aa6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8af85cf0abcb0858811f74130aa6c7">&#9670;&nbsp;</a></span>rtems_bdbuf_release_modified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_release_modified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> *&#160;</td>
          <td class="paramname"><em>bd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the buffer allocated with a get or read call placing it on the modified list. If the buffer was not released modified before the hold timer is set to the configuration value. If the buffer had been released modified before but not written to disk the hold timer is not updated. The buffer will be written to disk when the hold timer has expired, there are not more buffers available in the cache and a get or read buffer needs one or a sync call has been made. If the buffer is obtained with a get or read before the hold timer has expired the buffer will be returned to the user.</p>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd</td><td>[in] Reference to the buffer descriptor. The buffer descriptor reference must not be <code>NULL</code> and must be obtained via <a class="el" href="group__rtems__bdbuf.html#ga05fa34cc25ade6d09797b0dc88cf33e1">rtems_bdbuf_get()</a> or <a class="el" href="group__rtems__bdbuf.html#ga8546cefc842eef10cdb5b38a6cead9f7">rtems_bdbuf_read()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_ADDRESS</td><td>The reference is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga649b3b4fb368921f579a0204552a7a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga649b3b4fb368921f579a0204552a7a60">&#9670;&nbsp;</a></span>rtems_bdbuf_set_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_set_block_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the block size of a disk device. </p>
<p>This will set the block size derived fields of the disk device. If requested the disk device is synchronized before the block size change occurs. Since the cache is unlocked during the synchronization operation some tasks may access the disk device in the meantime. This may result in loss of data. After the synchronization the disk device is purged to ensure a consistent cache state and the block size change occurs. This also resets the read-ahead state of this disk device. Due to the purge operation this may result in loss of data.</p>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>[in, out] The disk device. </td></tr>
    <tr><td class="paramname">block_size</td><td>[in] The new block size in bytes. </td></tr>
    <tr><td class="paramname">sync</td><td>[in] If <code>true</code>, then synchronize the disk device before the block size change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_NUMBER</td><td>Invalid block size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a49c1519760b60eace0463277af50ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a49c1519760b60eace0463277af50ee">&#9670;&nbsp;</a></span>rtems_bdbuf_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__bdbuf__buffer.html">rtems_bdbuf_buffer</a> *&#160;</td>
          <td class="paramname"><em>bd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the buffer as modified and wait until it has been synchronized with the disk by writing it. This buffer will be the first to be transfer to disk and other buffers may also be written if the maximum number of blocks in a requests allows it.</p>
<dl class="section note"><dt>Note</dt><dd>This code does not lock the sync mutex and stop additions to the modified queue.</dd></dl>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd</td><td>[in] Reference to the buffer descriptor. The buffer descriptor reference must not be <code>NULL</code> and must be obtained via <a class="el" href="group__rtems__bdbuf.html#ga05fa34cc25ade6d09797b0dc88cf33e1">rtems_bdbuf_get()</a> or <a class="el" href="group__rtems__bdbuf.html#ga8546cefc842eef10cdb5b38a6cead9f7">rtems_bdbuf_read()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
    <tr><td class="paramname">RTEMS_INVALID_ADDRESS</td><td>The reference is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f02deb0d0ca33a6b9da04b9f3f2078d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f02deb0d0ca33a6b9da04b9f3f2078d">&#9670;&nbsp;</a></span>rtems_bdbuf_syncdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ClassicStatus.html#ga545d41846817eaba6143d52ee4d9e9fe">rtems_status_code</a> rtems_bdbuf_syncdev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtems__disk__device.html">rtems_disk_device</a> *&#160;</td>
          <td class="paramname"><em>dd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize all modified buffers for this device with the disk and wait until the transfers have completed. The sync mutex for the cache is locked stopping the addition of any further modified buffers. It is only the currently modified buffers that are written.</p>
<dl class="section note"><dt>Note</dt><dd>Nesting calls to sync multiple devices will be handled sequentially. A nested call will be blocked until the first sync request has complete.</dd></dl>
<p>Before you can use this function, the <a class="el" href="group__rtems__bdbuf.html#gaf19ee8ba7815e24767b6a91e200a78bc">rtems_bdbuf_init()</a> routine must be called at least once to initialize the cache, otherwise a fatal error will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>[in] The disk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTEMS_SUCCESSFUL</td><td>Successful operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gac1ab295c43675e17b20a7af3956c2a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1ab295c43675e17b20a7af3956c2a72">&#9670;&nbsp;</a></span>rtems_bdbuf_configuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrtems__bdbuf__config.html">rtems_bdbuf_config</a> rtems_bdbuf_configuration</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External reference to the configuration.</p>
<p>The configuration is provided by the application. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
